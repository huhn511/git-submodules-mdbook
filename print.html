<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js iota">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>IOTA Documentation</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
        <link rel="stylesheet" href="open-in.css">
        
        <link rel="stylesheet" href="./theme/custom/sidebar.css">
        

        

        <script src='public/build/bundle.js'></script>

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "iota";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('iota')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="docs/welcome.html"><strong aria-hidden="true">1.</strong> Welcome</a></li><li class="chapter-item expanded "><a href="networks/index.html"><strong aria-hidden="true">2.</strong> Networks</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="networks/chrysalis-docs/docs/introduction/welcome.html"><strong aria-hidden="true">2.1.</strong> Chrysalis</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="networks/chrysalis-docs/docs/introduction/what_is_chrysalis.html"><strong aria-hidden="true">2.1.1.</strong> What is Chrysalis?</a></li><li class="chapter-item expanded "><a href="networks/chrysalis-docs/docs/introduction/path_to_chrysalis.html"><strong aria-hidden="true">2.1.2.</strong> Path to Chrysalis</a></li><li class="chapter-item expanded "><a href="networks/chrysalis-docs/docs/node-software/node-software.html"><strong aria-hidden="true">2.1.3.</strong> Node Software</a></li><li class="chapter-item expanded "><a href="networks/chrysalis-docs/docs/libraries/overview.html"><strong aria-hidden="true">2.1.4.</strong> Libraries</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="networks/chrysalis-docs/docs/libraries/client.html"><strong aria-hidden="true">2.1.4.1.</strong> Client Lib</a></li><li class="chapter-item expanded "><a href="networks/chrysalis-docs/docs/libraries/wallet.html"><strong aria-hidden="true">2.1.4.2.</strong> Wallet Lib</a></li></ol></li><li class="chapter-item expanded "><a href="networks/chrysalis-docs/docs/guides/index.html"><strong aria-hidden="true">2.1.5.</strong> Guides</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="networks/chrysalis-docs/docs/guides/dev_guide.html"><strong aria-hidden="true">2.1.5.1.</strong> Developer</a></li><li class="chapter-item expanded "><a href="networks/chrysalis-docs/docs/guides/exchange_guide.html"><strong aria-hidden="true">2.1.5.2.</strong> Exchange</a></li><li class="chapter-item expanded "><a href="networks/chrysalis-docs/docs/guides/hub_guide.html"><strong aria-hidden="true">2.1.5.3.</strong> Hub Migration</a></li><li class="chapter-item expanded "><a href="networks/chrysalis-docs/docs/guides/backup_security.html"><strong aria-hidden="true">2.1.5.4.</strong> Backup and Security</a></li></ol></li><li class="chapter-item expanded "><a href="networks/chrysalis-docs/docs/testnet.html"><strong aria-hidden="true">2.1.6.</strong> Testnet</a></li><li class="chapter-item expanded "><a href="networks/chrysalis-docs/docs/rfc.html"><strong aria-hidden="true">2.1.7.</strong> Protocol RFCs</a></li><li class="chapter-item expanded "><a href="networks/chrysalis-docs/docs/resources.html"><strong aria-hidden="true">2.1.8.</strong> Resources</a></li><li class="chapter-item expanded "><a href="networks/chrysalis-docs/docs/faq.html"><strong aria-hidden="true">2.1.9.</strong> FAQ</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="libraries/index.html"><strong aria-hidden="true">3.</strong> Libraries</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="libraries/client-lib/docs/welcome.html"><strong aria-hidden="true">3.1.</strong> CLient Library</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="libraries/client-lib/docs/overview/index.html"><strong aria-hidden="true">3.1.1.</strong> Overview</a></li><li class="chapter-item expanded "><a href="libraries/client-lib/docs/libraries/index.html"><strong aria-hidden="true">3.1.2.</strong> Libraries</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="libraries/client-lib/docs/libraries/rust/index.html"><strong aria-hidden="true">3.1.2.1.</strong> Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="libraries/client-lib/docs/libraries/rust/getting_started.html"><strong aria-hidden="true">3.1.2.1.1.</strong> Getting Started</a></li><li class="chapter-item expanded "><a href="libraries/client-lib/docs/libraries/rust/examples.html"><strong aria-hidden="true">3.1.2.1.2.</strong> Examples</a></li><li class="chapter-item expanded "><a href="libraries/client-lib/docs/libraries/rust/api_reference.html"><strong aria-hidden="true">3.1.2.1.3.</strong> API Reference</a></li><li class="chapter-item expanded "><a href="libraries/client-lib/docs/libraries/rust/troubleshooting.html"><strong aria-hidden="true">3.1.2.1.4.</strong> Troubleshooting</a></li></ol></li><li class="chapter-item expanded "><a href="libraries/client-lib/docs/libraries/nodejs/index.html"><strong aria-hidden="true">3.1.2.2.</strong> Node.js</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="libraries/client-lib/docs/libraries/nodejs/getting_started.html"><strong aria-hidden="true">3.1.2.2.1.</strong> Getting Started</a></li><li class="chapter-item expanded "><a href="libraries/client-lib/docs/libraries/nodejs/examples.html"><strong aria-hidden="true">3.1.2.2.2.</strong> Examples</a></li><li class="chapter-item expanded "><a href="libraries/client-lib/docs/libraries/nodejs/api_reference.html"><strong aria-hidden="true">3.1.2.2.3.</strong> API Reference</a></li><li class="chapter-item expanded "><a href="libraries/client-lib/docs/libraries/nodejs/troubleshooting.html"><strong aria-hidden="true">3.1.2.2.4.</strong> Troubleshooting</a></li></ol></li><li class="chapter-item expanded "><a href="libraries/client-lib/docs/libraries/python/index.html"><strong aria-hidden="true">3.1.2.3.</strong> Python</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="libraries/client-lib/docs/libraries/python/getting_started.html"><strong aria-hidden="true">3.1.2.3.1.</strong> Getting Started</a></li><li class="chapter-item expanded "><a href="libraries/client-lib/docs/libraries/python/examples.html"><strong aria-hidden="true">3.1.2.3.2.</strong> Examples</a></li><li class="chapter-item expanded "><a href="libraries/client-lib/docs/libraries/python/api_reference.html"><strong aria-hidden="true">3.1.2.3.3.</strong> API Reference</a></li><li class="chapter-item expanded "><a href="libraries/client-lib/docs/libraries/python/troubleshooting.html"><strong aria-hidden="true">3.1.2.3.4.</strong> Troubleshooting</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="libraries/client-lib/docs/specs/index.html"><strong aria-hidden="true">3.1.3.</strong> Specification</a></li><li class="chapter-item expanded "><a href="libraries/client-lib/docs/contribute.html"><strong aria-hidden="true">3.1.4.</strong> Contribute</a></li></ol></li><li class="chapter-item expanded "><a href="libraries/wallet-lib/docs/welcome.html"><strong aria-hidden="true">3.2.</strong> Wallet Library</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="libraries/wallet-lib/docs/overview/index.html"><strong aria-hidden="true">3.2.1.</strong> Overview</a></li><li class="chapter-item expanded "><a href="libraries/wallet-lib/docs/libraries/index.html"><strong aria-hidden="true">3.2.2.</strong> Libraries</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="libraries/wallet-lib/docs/libraries/rust/index.html"><strong aria-hidden="true">3.2.2.1.</strong> Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="libraries/wallet-lib/docs/libraries/rust/getting_started.html"><strong aria-hidden="true">3.2.2.1.1.</strong> Getting Started</a></li><li class="chapter-item expanded "><a href="libraries/wallet-lib/docs/libraries/rust/examples.html"><strong aria-hidden="true">3.2.2.1.2.</strong> Examples</a></li><li class="chapter-item expanded "><a href="libraries/wallet-lib/docs/libraries/rust/api_reference.html"><strong aria-hidden="true">3.2.2.1.3.</strong> API Reference</a></li><li class="chapter-item expanded "><a href="libraries/wallet-lib/docs/libraries/rust/troubleshooting.html"><strong aria-hidden="true">3.2.2.1.4.</strong> Troubleshooting</a></li></ol></li><li class="chapter-item expanded "><a href="libraries/wallet-lib/docs/libraries/nodejs/index.html"><strong aria-hidden="true">3.2.2.2.</strong> Node.js</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="libraries/wallet-lib/docs/libraries/nodejs/getting_started.html"><strong aria-hidden="true">3.2.2.2.1.</strong> Getting Started</a></li><li class="chapter-item expanded "><a href="libraries/wallet-lib/docs/libraries/nodejs/examples.html"><strong aria-hidden="true">3.2.2.2.2.</strong> Examples</a></li><li class="chapter-item expanded "><a href="libraries/wallet-lib/docs/libraries/nodejs/api_reference.html"><strong aria-hidden="true">3.2.2.2.3.</strong> API Reference</a></li><li class="chapter-item expanded "><a href="libraries/wallet-lib/docs/libraries/nodejs/troubleshooting.html"><strong aria-hidden="true">3.2.2.2.4.</strong> Troubleshooting</a></li></ol></li><li class="chapter-item expanded "><a href="libraries/wallet-lib/docs/libraries/python/index.html"><strong aria-hidden="true">3.2.2.3.</strong> Python</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="libraries/wallet-lib/docs/libraries/python/getting_started.html"><strong aria-hidden="true">3.2.2.3.1.</strong> Getting Started</a></li><li class="chapter-item expanded "><a href="libraries/wallet-lib/docs/libraries/python/examples.html"><strong aria-hidden="true">3.2.2.3.2.</strong> Examples</a></li><li class="chapter-item expanded "><a href="libraries/wallet-lib/docs/libraries/python/api_reference.html"><strong aria-hidden="true">3.2.2.3.3.</strong> API Reference</a></li><li class="chapter-item expanded "><a href="libraries/wallet-lib/docs/libraries/python/troubleshooting.html"><strong aria-hidden="true">3.2.2.3.4.</strong> Troubleshooting</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="libraries/wallet-lib/docs/specs/index.html"><strong aria-hidden="true">3.2.3.</strong> Specification</a></li><li class="chapter-item expanded "><a href="libraries/wallet-lib/docs/contribute.html"><strong aria-hidden="true">3.2.4.</strong> Contribute</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="node-software/index.html"><strong aria-hidden="true">4.</strong> Node Software</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="node-software/hornet/docs/welcome.html"><strong aria-hidden="true">4.1.</strong> HORNET</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="node-software/hornet/docs/tutorials/index.html"><strong aria-hidden="true">4.1.1.</strong> Tutorials</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="node-software/hornet/docs/tutorials/1.0/index.html"><strong aria-hidden="true">4.1.1.1.</strong> IOTA 1.0</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="node-software/hornet/docs/tutorials/1.0/setup.html"><strong aria-hidden="true">4.1.1.1.1.</strong> Setup HORNET</a></li><li class="chapter-item expanded "><a href="node-software/hornet/docs/tutorials/1.0/private_tangle.html"><strong aria-hidden="true">4.1.1.1.2.</strong> Run a private Tangle</a></li><li class="chapter-item expanded "><a href="node-software/hornet/docs/tutorials/1.0/entry_node.html"><strong aria-hidden="true">4.1.1.1.3.</strong> Hosting An Entry Node</a></li></ol></li><li class="chapter-item expanded "><a href="node-software/hornet/docs/tutorials/1.5/index.html"><strong aria-hidden="true">4.1.1.2.</strong> Chrysalis IOTA 1.5</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="node-software/hornet/docs/tutorials/1.5/build.html"><strong aria-hidden="true">4.1.1.2.1.</strong> Build HORNET</a></li><li class="chapter-item expanded "><a href="node-software/hornet/docs/tutorials/1.5/run.html"><strong aria-hidden="true">4.1.1.2.2.</strong> Run HORNET</a></li><li class="chapter-item expanded "><a href="node-software/hornet/docs/tutorials/1.5/private_tangle.html"><strong aria-hidden="true">4.1.1.2.3.</strong> Run a private tangle</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="node-software/hornet/docs/configuration/index.html"><strong aria-hidden="true">4.1.2.</strong> Configuration</a></li><li class="chapter-item expanded "><a href="node-software/hornet/docs/configuration/config.html"><strong aria-hidden="true">4.1.3.</strong> config.json</a></li><li class="chapter-item expanded "><a href="node-software/hornet/docs/configuration/peering.html"><strong aria-hidden="true">4.1.4.</strong> peering.json</a></li><li class="chapter-item expanded "><a href="node-software/hornet/docs/api-reference.html"><strong aria-hidden="true">4.1.5.</strong> API Reference</a></li><li class="chapter-item expanded "><a href="node-software/hornet/docs/troubleshooting.html"><strong aria-hidden="true">4.1.6.</strong> Troubleshooting</a></li><li class="chapter-item expanded "><a href="faq.html"><strong aria-hidden="true">4.1.7.</strong> FAQ</a></li><li class="chapter-item expanded "><a href="node-software/hornet/docs/Contribution.html"><strong aria-hidden="true">4.1.8.</strong> Contribution</a></li><li class="chapter-item expanded "><a href="node-software/hornet/docs/code_of_conduct.html"><strong aria-hidden="true">4.1.9.</strong> Code of Conduct</a></li></ol></li><li class="chapter-item expanded "><a href="node-software/Bee/docs/welcome.html"><strong aria-hidden="true">4.2.</strong> Bee</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="node-software/Bee/docs/overview.html"><strong aria-hidden="true">4.2.1.</strong> Overview</a></li><li class="chapter-item expanded "><a href="node-software/Bee/docs/node/index.html"><strong aria-hidden="true">4.2.2.</strong> Setup a Node</a></li><li class="chapter-item expanded "><a href="node-software/Bee/docs/contribution.html"><strong aria-hidden="true">4.2.3.</strong> Contribution</a></li></ol></li><li class="chapter-item expanded "><a href="node-software/goshimmer/docs/goshimmer.html"><strong aria-hidden="true">4.3.</strong> GoShimmer</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="node-software/goshimmer/docs/faq.html"><strong aria-hidden="true">4.3.1.</strong> FAQ</a></li><li class="chapter-item expanded "><a href="node-software/goshimmer/docs/tutorials.html"><strong aria-hidden="true">4.3.2.</strong> Tutorials</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="node-software/goshimmer/docs/tutorials/setup.html"><strong aria-hidden="true">4.3.2.1.</strong> Setting up a GoShimmer node</a></li><li class="chapter-item expanded "><a href="node-software/goshimmer/docs/tutorials/request_funds.html"><strong aria-hidden="true">4.3.2.2.</strong> Obtaining tokens from the faucet</a></li><li class="chapter-item expanded "><a href="node-software/goshimmer/docs/tutorials/wallet.html"><strong aria-hidden="true">4.3.2.3.</strong> The wallet library</a></li><li class="chapter-item expanded "><a href="node-software/goshimmer/docs/tutorials/dApp.html"><strong aria-hidden="true">4.3.2.4.</strong> Writing a dApp</a></li><li class="chapter-item expanded "><a href="node-software/goshimmer/docs/tutorials/syncbeacon.html"><strong aria-hidden="true">4.3.2.5.</strong> How to run a sync beacon</a></li><li class="chapter-item expanded "><a href="node-software/goshimmer/docs/tutorials/follow_syncbeacon.html"><strong aria-hidden="true">4.3.2.6.</strong> How to configure followed sync beacon nodes</a></li><li class="chapter-item expanded "><a href="node-software/goshimmer/docs/tutorials/static_identity.html"><strong aria-hidden="true">4.3.2.7.</strong> How to create a static identity</a></li><li class="chapter-item expanded "><a href="node-software/goshimmer/docs/tutorials/custom_dRNG.html"><strong aria-hidden="true">4.3.2.8.</strong> How to setup a custom dRNG committee</a></li><li class="chapter-item expanded "><a href="node-software/goshimmer/docs/tutorials/monitoring.html"><strong aria-hidden="true">4.3.2.9.</strong> Setting up Monitoring Dashboard</a></li></ol></li><li class="chapter-item expanded "><a href="node-software/goshimmer/docs/application_logic.html"><strong aria-hidden="true">4.3.3.</strong> Application logic</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="node-software/goshimmer/docs/application_logic/protocol.html"><strong aria-hidden="true">4.3.3.1.</strong> Protocol high level overview</a></li></ol></li><li class="chapter-item expanded "><a href="node-software/goshimmer/docs/implementation_design.html"><strong aria-hidden="true">4.3.4.</strong> Implementation design</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="node-software/goshimmer/docs/implementation_design/event_driven_model.html"><strong aria-hidden="true">4.3.4.1.</strong> Event driven model</a></li><li class="chapter-item expanded "><a href="node-software/goshimmer/docs/implementation_design/packages_plugins.html"><strong aria-hidden="true">4.3.4.2.</strong> Packages and plugins</a></li><li class="chapter-item expanded "><a href="node-software/goshimmer/docs/implementation_design/plugin.html"><strong aria-hidden="true">4.3.4.3.</strong> Plugin</a></li><li class="chapter-item expanded "><a href="node-software/goshimmer/docs/implementation_design/configuration_parameters.html"><strong aria-hidden="true">4.3.4.4.</strong> Configuration parameters</a></li><li class="chapter-item expanded "><a href="node-software/goshimmer/docs/implementation_design/object_storage.html"><strong aria-hidden="true">4.3.4.5.</strong> Object storage</a></li></ol></li><li class="chapter-item expanded "><a href="node-software/goshimmer/docs/api.html"><strong aria-hidden="true">4.3.5.</strong> API</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="node-software/goshimmer/docs/apis/api.html"><strong aria-hidden="true">4.3.5.1.</strong> Client Lib</a></li><li class="chapter-item expanded "><a href="node-software/goshimmer/docs/apis/webAPI.html"><strong aria-hidden="true">4.3.5.2.</strong> WebAPI</a></li><li class="chapter-item expanded "><a href="node-software/goshimmer/docs/apis/mana.html"><strong aria-hidden="true">4.3.5.3.</strong> Mana</a></li><li class="chapter-item expanded "><a href="node-software/goshimmer/docs/apis/dRNG.html"><strong aria-hidden="true">4.3.5.4.</strong> dRNG</a></li><li class="chapter-item expanded "><a href="node-software/goshimmer/docs/apis/communication.html"><strong aria-hidden="true">4.3.5.5.</strong> Communication</a></li><li class="chapter-item expanded "><a href="node-software/goshimmer/docs/apis/value.html"><strong aria-hidden="true">4.3.5.6.</strong> Value layer</a></li></ol></li><li class="chapter-item expanded "><a href="node-software/goshimmer/docs/tooling.html"><strong aria-hidden="true">4.3.6.</strong> Tooling</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="node-software/goshimmer/docs/tooling/docker_private_network.html"><strong aria-hidden="true">4.3.6.1.</strong> Docker private network</a></li></ol></li><li class="chapter-item expanded "><a href="node-software/goshimmer/docs/specification.html"><strong aria-hidden="true">4.3.7.</strong> Specification of Implementation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="node-software/goshimmer/docs/specification/001-mana.html"><strong aria-hidden="true">4.3.7.1.</strong> Mana</a></li><li class="chapter-item expanded "><a href="node-software/goshimmer/docs/specification/003-markers.html"><strong aria-hidden="true">4.3.7.2.</strong> Markers</a></li></ol></li><li class="chapter-item expanded "><a href="node-software/goshimmer/docs/concepts.html"><strong aria-hidden="true">4.3.8.</strong> Concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="node-software/goshimmer/docs/concepts/glossary.html"><strong aria-hidden="true">4.3.8.1.</strong> Glossary</a></li><li class="chapter-item expanded "><a href="node-software/goshimmer/docs/concepts/layers.html"><strong aria-hidden="true">4.3.8.2.</strong> Layers</a></li></ol></li><li class="chapter-item expanded "><a href="node-software/goshimmer/docs/team_resources.html"><strong aria-hidden="true">4.3.9.</strong> Team Resources</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="node-software/goshimmer/docs/teamresources/release.html"><strong aria-hidden="true">4.3.9.1.</strong> How to do a release</a></li><li class="chapter-item expanded "><a href="node-software/goshimmer/docs/teamresources/guidelines.html"><strong aria-hidden="true">4.3.9.2.</strong> Code Guidelines</a></li><li class="chapter-item expanded "><a href="node-software/goshimmer/docs/teamresources/local_development.html"><strong aria-hidden="true">4.3.9.3.</strong> Local development</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="node-software/wasp/docs/welcome.html"><strong aria-hidden="true">4.4.</strong> WASP</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="node-software/wasp/docs/tutorial/index.html"><strong aria-hidden="true">4.4.1.</strong> Tutorials</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="node-software/wasp/docs/tutorial/01.html"><strong aria-hidden="true">4.4.1.1.</strong> The Solo package</a></li><li class="chapter-item expanded "><a href="node-software/wasp/docs/tutorial/02.html"><strong aria-hidden="true">4.4.1.2.</strong> Tokens and the Value Tangle</a></li><li class="chapter-item expanded "><a href="node-software/wasp/docs/tutorial/03.html"><strong aria-hidden="true">4.4.1.3.</strong> Creating a chain. Core contacts</a></li><li class="chapter-item expanded "><a href="node-software/wasp/docs/tutorial/04.html"><strong aria-hidden="true">4.4.1.4.</strong> Deploying and running Rust smart contract</a></li><li class="chapter-item expanded "><a href="node-software/wasp/docs/tutorial/05.html"><strong aria-hidden="true">4.4.1.5.</strong> Structure of the smart contract</a></li><li class="chapter-item expanded "><a href="node-software/wasp/docs/tutorial/06.html"><strong aria-hidden="true">4.4.1.6.</strong> Invoking smart contract. Sending a request</a></li><li class="chapter-item expanded "><a href="node-software/wasp/docs/tutorial/07.html"><strong aria-hidden="true">4.4.1.7.</strong> Calling a view from the Solo environment</a></li><li class="chapter-item expanded "><a href="node-software/wasp/docs/tutorial/08.html"><strong aria-hidden="true">4.4.1.8.</strong> Sending and receiving tokens with the address</a></li><li class="chapter-item expanded "><a href="node-software/wasp/docs/tutorial/09.html"><strong aria-hidden="true">4.4.1.9.</strong> Sending tokens to the smart contract</a></li><li class="chapter-item expanded "><a href="node-software/wasp/docs/tutorial/10.html"><strong aria-hidden="true">4.4.1.10.</strong> Return of tokens in case of failure</a></li><li class="chapter-item expanded "><a href="node-software/wasp/docs/tutorial/11.html"><strong aria-hidden="true">4.4.1.11.</strong> Sending iotas from smart contract to address</a></li></ol></li><li class="chapter-item expanded "><a href="node-software/wasp/docs/setup_wasp.html"><strong aria-hidden="true">4.4.2.</strong> Setup a private ISCP Cluster</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="products/index.html"><strong aria-hidden="true">5.</strong> Products</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="products/stronghold/docs/welcome.html"><strong aria-hidden="true">5.1.</strong> Stronghold</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="products/stronghold/docs/overview/index.html"><strong aria-hidden="true">5.1.1.</strong> Overview</a></li><li class="chapter-item expanded "><a href="products/stronghold/docs/libraries/index.html"><strong aria-hidden="true">5.1.2.</strong> Libraries</a></li><li class="chapter-item expanded "><a href="products/stronghold/docs/specs/demo-spec.html"><strong aria-hidden="true">5.1.3.</strong> Specification</a></li><li class="chapter-item expanded "><a href="products/stronghold/docs/contribute.html"><strong aria-hidden="true">5.1.4.</strong> Contribute</a></li></ol></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="iota">IOTA (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">IOTA Documentation</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        <a href="https://github.com/huhn511/git-submodules-mdbook" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="welcome-to-iota-documentation"><a class="header" href="#welcome-to-iota-documentation">Welcome to IOTA Documentation</a></h1>
<p>Everything you need to know, if you want to work with IOTA.  Here you can learn how to setup a Node, learn more about the Tangle or use a library to include IOTA to you project.</p>
<h2 id="the-new-dawn-of-documentation"><a class="header" href="#the-new-dawn-of-documentation">The new dawn of Documentation</a></h2>
<p>Chrysalis (IOTA 1.5) is the biggest update to the IOTA Network in History. There ary many improvments and alot of changes to the network, the clients and also for node operators. With the time, the IOTA Founcaiton also did grow on the amount of projects, and we come with a new soultion for docs, insprired by a distributed approach. For the legacy Network (IOTA 1.0), please visit the <a href="https://legacy.docs.iota.org">legacy documentation portal</a>.</p>
<p>Each project has now a own documentation page. On this page, you can discover all our projects and get all updates.</p>
<h2 id="discover-the-new-project-documentation-pages"><a class="header" href="#discover-the-new-project-documentation-pages">Discover the new project documentation pages:</a></h2>
<project-list /><h1 id="networks"><a class="header" href="#networks">Networks</a></h1>
<ul>
<li><a href="networks/./chrysalis-docs/docs/introduction/welcome.html">Chrysalis</a></li>
</ul>
<h1 id="welcome"><a class="header" href="#welcome">Welcome</a></h1>
<p>This page outlines the fundamental changes to the IOTA protocol which will be deployed in 2021 in a release called Chrysalis.</p>
<p><img src="networks/chrysalis-docs/docs/introduction/./assets/01_butterfly.png" alt="" /></p>
<h1 id="what-is-chrysalis"><a class="header" href="#what-is-chrysalis">What is Chrysalis</a></h1>
<p>The objective of the IOTA Foundation is to optimize the IOTA mainnet before Coordicide and to offer an enterprise-ready solution for our ecosystem. This will be achieved by an intermediate update called <code>Chrysalis</code>. This post explains what the Chrysalis upgrade entails.</p>
<p><img src="networks/chrysalis-docs/docs/introduction/./assets/what_is_chrysalis/00.gif" alt="" /></p>
<p>A chrysalis is “the form a caterpillar takes before it emerges from its cocoon as a fully-formed moth or butterfly”. In the context of IOTA, Chrysalis is the mainnet’s intermediate stage before Coordicide is complete. The main purpose of Chrysalis is to improve the usability of the current IOTA mainnet, for users and developers alike.</p>
<p><img src="networks/chrysalis-docs/docs/introduction/./assets/02_path_to.png" alt="" /></p>
<p>Why is this process of adopting major protocol improvements relatively unique to IOTA among permissionless DLTs? The simple answer is the absence of miners. In most permissionless DLTs, the miners’ economic incentives differ from those of regular network users. Changes to throughput and network latencies can disrupt the fee market the miners rely on. This in turn makes them likely to object to network upgrades as it affects their bottom line.</p>
<p>In IOTA, validators and users are one and the same. There is no conflict of interests between parties with different motivations, meaning there is a much smoother path to network improvements. This is why we are able to incrementally and smoothly upgrade the network before Coordicide.</p>
<p>What are the specific Chrysalis upgrades?</p>
<h2 id="white-flag-approach"><a class="header" href="#white-flag-approach">White-flag approach</a></h2>
<p><img src="networks/chrysalis-docs/docs/introduction/../docs/assets/what_is_chrysalis/01.png" alt="" />
<a href="https://iota.cafe/t/conflict-white-flag-mitigate-conflict-spamming-by-ignoring-conflicts/233">The White-flag approach</a> which is used for calculating balances. It is a simpler, conflict-ignoring approach that improves the speed and efficiency of tip selection, eliminates many network attacks, and significantly reduces the need for reattachments.</p>
<h2 id="new-milestone-selection-algorithm"><a class="header" href="#new-milestone-selection-algorithm">New milestone selection algorithm</a></h2>
<p><img src="networks/chrysalis-docs/docs/introduction/./assets/what_is_chrysalis/02.png" alt="" />
<a href="https://iota.cafe/t/coordinator-improvements/310">A new milestone selection algorithm for the coordinator</a>, that focuses on allowing the network to support much more confirmed transactions per second (CTPS) than before with higher computational efficiency.</p>
<h2 id="urts-tip-selection"><a class="header" href="#urts-tip-selection">URTS tip selection</a></h2>
<p><img src="networks/chrysalis-docs/docs/introduction/./assets/what_is_chrysalis/03.png" alt="" />
A new <a href="https://github.com/iotaledger/protocol-rfcs/blob/master/text/0008-uniform-random-tip-selection/0008-uniform-random-tip-selection.md">Uniform random tip selection</a> in node software. It is significantly faster and more efficient than the previous tip selection algorithm.</p>
<h2 id="ed25519-signature-scheme"><a class="header" href="#ed25519-signature-scheme">Ed25519 signature scheme</a></h2>
<p><img src="networks/chrysalis-docs/docs/introduction/./assets/what_is_chrysalis/04.png" alt="" />
<a href="https://github.com/iotaledger/protocol-rfcs/blob/ee07797acb5940b7dbb5c3411b184ccdc6afdbb1/text/0000-ed25519-signature-scheme/0000-ed25519-signature-scheme.md">The Ed25519 signature scheme</a> has been added to the network, replacing the current Winternitz one time signature scheme (W-OTS) signature scheme. Using an EdDSA signature scheme allows the protocol and clients using the protocol to run more efficiently on established hardware. Unlike W-OTS, the scheme also allows for the re-use of private keys, and, with that, introduces reusable addresses to the protocol. This change also dramatically reduces the transaction size, saving network bandwidth and processing time.</p>
<h2 id="atomic-transactions"><a class="header" href="#atomic-transactions">Atomic transactions</a></h2>
<p><img src="networks/chrysalis-docs/docs/introduction/./assets/what_is_chrysalis/05.png" alt="" />
<a href="https://github.com/luca-moser/protocol-rfcs/blob/signed-tx-payload/text/0000-transaction-payload/0000-transaction-payload.md">Atomic transactions</a> that move the protocol from the current, complicated, bundle construct and use simpler atomic transactions instead. This results in much simpler development and more adaptable and maintainable code of the core software. In addition, atomic transactions reduce network overhead, reduce transaction validation and signature verification load, and improve spam protection and congestion control.</p>
<h2 id="switch-to-utxo-model"><a class="header" href="#switch-to-utxo-model">Switch to UTXO Model</a></h2>
<p><img src="networks/chrysalis-docs/docs/introduction/./assets/what_is_chrysalis/06.png" alt="" />
<a href="https://iota.cafe/t/switching-to-utxo-model-for-balances-colored-coins-easier-conflict-resolution/229">A switch to the UTXO model</a> from the current account model. Every coin on an address becomes uniquely identifiable and every spend names the exact coins that it wants to move. This allows for faster and more exact conflict handling and improves resilience and security of the protocol. In addition, switching to UTXO makes other functionalities, such as colored tokens, on the protocol possible in the future.</p>
<h2 id="internal-binary-representation"><a class="header" href="#internal-binary-representation">Internal Binary Representation</a></h2>
<p><img src="networks/chrysalis-docs/docs/introduction/./assets/what_is_chrysalis/07.png" alt="" />
<a href="https://github.com/luca-moser/protocol-rfcs/blob/signed-tx-payload/text/0000-transaction-payload/0000-transaction-payload.md">A switch to an internal binary representation of the trinary transaction</a>. This allows us to work on binary data for validation, IO, and other processing without the current reliance on binary-ternary conversions as in the pre-Chrysalis software node software. The switch to binary transactions further reduces the transaction size, saving network bandwidth and processing time.</p>
<h2 id="new-node-api-and-client-libraries"><a class="header" href="#new-node-api-and-client-libraries">New node API and client libraries</a></h2>
<p>With Chrysalis, we wanted to offer a more standard API on both the node and client library level. Node implementations provide a completely redesigned <a href="https://editor.swagger.io/?url=https://raw.githubusercontent.com/rufsam/protocol-rfcs/master/text/0026-rest-api/rest-api.yaml">RESTful</a> and <a href="https://playground.asyncapi.io/?load=https://raw.githubusercontent.com/luca-moser/protocol-rfcs/rfc/node-event-api/text/0033-node-event-api/0033-node-event-api.yml">eventful</a> API implementations.</p>
<p>Our <a href="networks/chrysalis-docs/docs/introduction/../libraries/overview.html">client libraries</a> provide high level abstractions that allow developers to build solutions that are easier to develop and cheaper to maintain.</p>
<h1 id="path-to-chrysalis"><a class="header" href="#path-to-chrysalis">Path to Chrysalis</a></h1>
<p>One of the IOTA Foundation’s primary roles is defining and delivering on a development roadmap that aligns with the Foundation's strategy to reach production-readiness and adoption.</p>
<p>The IOTA mainnet has been operational since 2016 and the overall engineering strategy evolved significantly based on industry demand and feedback.</p>
<p>Progress in Coordicide research has resulted in identifying many concepts that could already be implemented on the current IOTA mainnet and provides significant value to users of the protocol before Coordicide. This led to the formalization of our engineering strategy around Chrysalis: a series of upgrades to the protocol that achieves production-readiness before Coordicide.</p>
<p>The benefit of this approach is that many of the protocol properties will remain the same, or almost the same, for Coordicide. That, together with a better set of developer tools, will make the transition to Coordicide much simpler.</p>
<p>The intended outcomes for Chrysalis are:</p>
<ul>
<li><strong>Simpler transition to Coordicide</strong> - With Coordicide making significant progress, we want to ensure that all developers and companies that build and deploy on Chrysalis will have as smooth a transition to Coordicide as possible.</li>
<li><strong>Substantial performance improvements</strong> - With the changes introduced by Chrysalis, we will see a substantial improvement in the scalability and reliability of the IOTA Mainnet.</li>
<li><strong>Improved developer and user experience</strong> - The new protocol features, new libraries, and the new wallet will make IOTA one of the best platforms to build on, removing the friction which developers experience today while allowing solutions built on top of the protocol to provide better user experience.</li>
<li><strong>Accelerated adoption</strong> - Chrysalis will make IOTA production-ready; becoming a stable protocol, with a reliable set of developer tools and frameworks that will enable startups, corporations, and governments to develop and launch products powered by IOTA.</li>
</ul>
<h2 id="the-stages-to-chrysalis"><a class="header" href="#the-stages-to-chrysalis">The stages to Chrysalis</a></h2>
<p><img src="networks/chrysalis-docs/docs/introduction//Users/charlesthompson/chrysalis-docs/docs/introduction/assets/path_to_chrysalis/01.png" alt="" /></p>
<p>The Chrysalis upgrade is a complex undertaking. We are coordinating a number of distinct products to ensure a smooth transition for IOTA’s current users and partners. In addition to the core node software, we also need to update our wallet software, our libraries, and the entire infrastructure.</p>
<p>Another important requirement is the ease of transition to the future Coordicide network. By carefully planning the breaking changes introduced along the way, and providing support in our developer tools, we will ensure that our growing ecosystem of developers, startups, and corporations can reliably develop and launch new innovative products on IOTA.</p>
<p>The plan for implementing Chrysalis is divided into two phases.</p>
<p><strong>The first phase</strong> consisted of improved tip selection (URTS), milestone selection, and White flag. These were implemented in the node software gradually. This phase required an upgrade of all nodes, including the coordinator node, and did not require a snapshot.</p>
<p>The first phase of Chrysalis resulted in:</p>
<ul>
<li>Transaction confirmation times of around 10 seconds</li>
<li>Transactions rarely needing reattachment</li>
<li>A substantial TPS increase</li>
<li>Performance and reliability improvements for nodes</li>
</ul>
<p><strong>The second phase</strong> of Chrysalis consists of adopting and/or implementing UTXO, atomic transactions, reusable addresses (Ed25519), a transition to a binary transaction layout, and a new set of client libraries and developer tools. These represent significant changes to the core protocol and the way transactions are structured. Once everything has been tested, validated, and audited, the Foundation will deploy a new Chrysalis network. The upgrade will consist of an extended period when the current, legacy network remains operational. This allows users, exchanges, and partners to migrate to the Chrysalis network at will. The migration is not time constrained.</p>
<p>The second phase of Chrysalis consists of:</p>
<ul>
<li>Reusable addresses and support for more standard cryptography (EdDSA), making efficient hardware support for all major architectures possible</li>
<li>A simplified transaction layout and a reduction in transaction size, further increasing performance and efficiency</li>
<li>Significant improvements to the usability and reliability of IOTA</li>
<li>A switch to a UTXO based model from the current account model</li>
</ul>
<p>The introduction of reusable addresses is an important change for token holders. This will vastly improve IOTA’s usability and make integration into new exchanges, wallets, and payment systems much simpler. A new wallet, called Firefly, will be released with Chrysalis. This wallet will allow token holders to transition from the current WOTS address scheme to the new EdDSA scheme.</p>
<p>Our goal is to make this transition as seamless as possible for everyone in the IOTA ecosystem. This includes a variety of improvements and updates to our libraries and software, as well as training and educational sessions for our partners.</p>
<h3 id="from-plan-to-action"><a class="header" href="#from-plan-to-action">From plan to action</a></h3>
<p>With Chrysalis, we had to make decisions on how to best implement all the upcoming changes, ensuring a correct and timely implementation. What follows is an overview of the various components we are working on to successfully implement this update.</p>
<h3 id="specification-and-standardization"><a class="header" href="#specification-and-standardization">Specification and standardization</a></h3>
<p>Specifications are a major part of our new development process. All our new software projects (Node software, Wallet, Identity, Access, Streams, etc.) are based on vetted specifications. Specifications make it possible for external parties to follow a project’s intended functionality, for example for audit purposes, or develop their own implementations in different languages.</p>
<p>The Chrysalis changes are specified in the form of RFCs. You can find all the RFCs in the <a href="https://github.com/iotaledger/protocol-rfcs">protocol-rfcs repository</a>. The list of Chrysalis RFCs includes:</p>
<ul>
<li><a href="https://github.com/luca-moser/protocol-rfcs/blob/rfc-urts-tip-sel/text/0008-weighted-uniform-random-tip-selection/0008-weighted-uniform-random-tip-selection.md">Improved tip selection (URTS)</a></li>
<li><a href="https://github.com/iotaledger/protocol-rfcs/blob/milestone-merkle-validation-chrysalis-pt-2/text/0012-milestone-merkle-validation/0012-milestone-merkle-validation.md">Milestone selection</a></li>
<li><a href="https://github.com/thibault-martinez/protocol-rfcs/blob/rfc-white-flag/text/0005-white-flag/0005-white-flag.md">White flag</a></li>
<li><a href="https://github.com/hmoog/protocol-rfcs/blob/master/text/0011-utxo-model/0011-utxo-model.md">UTXO</a></li>
<li><a href="https://github.com/iotaledger/protocol-rfcs/blob/ee07797acb5940b7dbb5c3411b184ccdc6afdbb1/text/0000-ed25519-signature-scheme/0000-ed25519-signature-scheme.md">Ed25519 Signature Scheme</a></li>
<li><a href="https://github.com/Wollac/protocol-rfcs/blob/ed25519/text/0009-ed25519-signature-scheme/0009-ed25519-signature-scheme.md">Reusable addresses (Ed25519)</a></li>
<li><a href="https://github.com/GalRogozinski/protocol-rfcs/blob/message/text/0017-message/0017-message.md">Message object</a></li>
<li><a href="https://github.com/luca-moser/protocol-rfcs/blob/signed-tx-payload/text/0000-transaction-payload/0000-transaction-payload.md">Binary transaction layout</a></li>
<li><a href="https://github.com/Wollac/protocol-rfcs/blob/message-pow/text/0024-message-pow/0024-message-pow.md">Message proof of work</a></li>
<li><a href="https://github.com/GalRogozinski/protocol-rfcs/blob/dust/text/0032-dust-protection/0032-dust-protection.md">Dust protection</a></li>
<li><a href="https://github.com/luca-moser/protocol-rfcs/blob/local-snapshot-file-format/text/0000-local-snapshot-file-format/0000-local-snapshot-file-format.md">New local snapshot file format</a></li>
<li><a href="https://github.com/Wollac/protocol-rfcs/blob/bech32-address-format/text/0020-bech32-address-format/0020-bech32-address-format.md">Bech32 address format</a></li>
<li><a href="https://editor.swagger.io/?url=https://raw.githubusercontent.com/rufsam/protocol-rfcs/master/text/0026-rest-api/rest-api.yaml">RESTful node API</a></li>
<li><a href="https://playground.asyncapi.io/?load=https://raw.githubusercontent.com/luca-moser/protocol-rfcs/rfc/node-event-api/text/0033-node-event-api/0033-node-event-api.yml">Eventful node API</a></li>
</ul>
<h3 id="wallet-support"><a class="header" href="#wallet-support">Wallet support</a></h3>
<p>The Trinity wallet is a popular IOTA wallet. With Chrysalis, we will release a new wallet implementation, <a href="https://blog.iota.org/firefly-iota-next-generation-wallet-26bdd4d01510/">Firefly</a>. The team has been working on a complete reevaluation of the wallet architecture, with a completely redesigned user experience. At its core will be a <a href="networks/chrysalis-docs/docs/introduction/../libraries/wallet.html">new wallet library</a> written in Rust. The wallet library is designed to allow other developers to easily implement IOTA wallets within their applications. Another new Rust library utilized by Firefly is Stronghold; Stronghold enables ultra-secure secret handling and storage.</p>
<h3 id="infrastructure"><a class="header" href="#infrastructure">Infrastructure</a></h3>
<p>Currently, the IOTA Foundation supports two public Networks: Mainnet and Devnet (Devnet is for PoCs and application tests). Both networks provide public endpoints for users and partners. You can read more about the networks and how you can participate in our <a href="https://docs.iota.org/docs/getting-started/1.1/networks/overview">documentation</a>.</p>
<p>While the current Mainnet will be replaced by a new network, it will remain operational for an extended period of time. For the purposes of non-time-constrained transition of projects deployed on Devnet, the Devnet will only be upgraded after the Chrysalis release.</p>
<p>The Chrysalis testnet has been operational since December and we encourage everyone to use it to build and test their solutions before the official launch of Chrysalis.</p>
<h3 id="chrysalis-testnet"><a class="header" href="#chrysalis-testnet">Chrysalis Testnet</a></h3>
<p>Nodes deployed to the testnet can be queried using a load balancer at:</p>
<ul>
<li>api.lb-0.testnet.chrysalis2.com</li>
</ul>
<p>We recommend using the load balancer for most scenarios.</p>
<p>Single node endpoints that expose native MQTT in case you need this are:</p>
<ul>
<li>api.hornet-0.testnet.chrysalis2.com</li>
<li>api.hornet-1.testnet.chrysalis2.com</li>
<li>api.hornet-2.testnet.chrysalis2.com</li>
<li>api.hornet-3.testnet.chrysalis2.com</li>
</ul>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>Chrysalis is the most promising series of upgrades made to IOTA yet. It is a major step for our production-readiness, with increased transaction throughput, network stability, improved usability, and enables new features and use cases. The upcoming weeks and months are some of the most exciting in IOTA’s history. We are on a clear path towards IOTA’s adoption as an enabling technology for IoT and beyond.</p>
<h1 id="node-software"><a class="header" href="#node-software">Node software</a></h1>
<p>We have been running the network exclusively on the Go powered Hornet node since the summer of 2020. For Chrysalis, you will have the choice to continue using a new version of Hornet or our new Rust-based Bee node.</p>
<h3 id="hornet-and-bee"><a class="header" href="#hornet-and-bee">Hornet and Bee</a></h3>
<p>Moving forward, both Hornet and Bee are the officially supported nodes for IOTA.</p>
<p>Hornet is an EDF-supported community node written in Go and has already proven itself to be a stable and performant implementation. It recently underwent a successful audit. </p>
<p>Bee is an IOTA Node implemented by the Foundation and written in Rust.</p>
<p>At this stage, we recommend using Hornet since it has several optional features that are not implemented in Bee so far.</p>
<h2 id="node-software-1"><a class="header" href="#node-software-1">Node software</a></h2>
<ul>
<li><a href="https://github.com/gohornet/hornet/tree/develop">hornet (branch: develop)</a></li>
<li><a href="https://github.com/iotaledger/bee/tree/chrysalis-pt-2">bee (branch: chrysalis-pt-2)</a></li>
</ul>
<h2 id="node-api-specification"><a class="header" href="#node-api-specification">Node API specification</a></h2>
<ul>
<li><a href="https://editor.swagger.io/?url=https://raw.githubusercontent.com/rufsam/protocol-rfcs/master/text/0026-rest-api/rest-api.yaml">rest-api specification</a></li>
</ul>
<h1 id="libraries"><a class="header" href="#libraries">Libraries</a></h1>
<p><strong>The IOTA client libraries allow you to easily integrate IOTA into your own applications. You can choose a library to match your use case.</strong></p>
<p>Official IOTA libraries serve as <code>one-source-code-of-truth</code> to IOTA users and provide binding to other programming languages. You can read more about core principles behind IOTA client libraries in the following blog <a href="https://blog.iota.org/the-new-iota-client-libraries-harder-better-faster-stronger/">post</a>.</p>
<ul>
<li><a href="networks/chrysalis-docs/docs/libraries/client.html">client-lib</a>: a general purpose IOTA client library for interacting with IOTA network (Tangle)</li>
<li><a href="networks/chrysalis-docs/docs/libraries/wallet.html">wallet-lib</a>: a stateful library specifically designed to be used for IOTA value-based transfers </li>
<li><a href="https://github.com/iotaledger/iota.c">iota.c</a>: a special-purpose library in C for embedded devices (with microcontrollers) covering a basic features of <code>client-lib</code> or <code>wallet-lib</code></li>
<li><a href="https://github.com/iotaledger/iota.js/tree/chrysalis">iota.js</a>: an initial IOTA client library in Typescript that can be used in a web browser</li>
<li><a href="https://github.com/iotaledger/iota.go/tree/chrysalis/phase2">iota.go</a>: an initial IOTA client library in Golang</li>
</ul>
<div class="iframe-wrapper">
<iframe src="https://www.youtube.com/embed/N2VW3zJQmso" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>
<p><img src="networks/chrysalis-docs/docs/libraries/../guides/assets/overview-libraries.svg" alt="overview-libs" /></p>
<p>All libraries are in active development. The libraries target the Chrysalis testnet and do not work with current IOTA mainnet.</p>
<p>The client libraries with official support are maintained by the IOTA Foundation, their source code can be found on the <a href="https://github.com/iotaledger">Official GitHub repository</a>.</p>
<h2 id="utilities"><a class="header" href="#utilities">Utilities</a></h2>
<h4 id="developer-tools"><a class="header" href="#developer-tools"><strong>Developer tools</strong></a></h4>
<ul>
<li><a href="https://explorer.iota.org/chrysalis">Official explorer</a></li>
<li><a href="https://faucet.testnet.chrysalis2.com/">Testnet faucet</a></li>
<li><a href="https://github.com/iotaledger/cli-wallet">Commandline wallet</a></li>
</ul>
<hr />
<h1 id="iota-client-library"><a class="header" href="#iota-client-library">IOTA Client Library</a></h1>
<p>The official client library for interacting with the IOTA Tangle allows you to:</p>
<ul>
<li>Create messages and transactions</li>
<li>Sign transactions</li>
<li>Generate addresses</li>
<li>Interact with an IOTA node</li>
</ul>
<p>If you mainly intend to process value transfers, we recommend you use our stateful <a href="networks/chrysalis-docs/docs/libraries/./wallet.html">wallet library</a> instead.</p>
<p><a href="https://client-lib.docs.iota.org">IOTA Client Library full documentation</a></p>
<h2 id="rust"><a class="header" href="#rust">Rust</a></h2>
<ul>
<li><a href="https://client-lib.docs.iota.org/libraries/rust/getting_started.html">Getting Started</a> - Getting Started with Rust and the IOTA Client Library.</li>
<li><a href="https://client-lib.docs.iota.org/libraries/rust/examples.html">Examples</a> - Find starting points or inspiration in the examples.</li>
<li><a href="https://github.com/iotaledger/iota.rs">Repository</a> - Browse through the code and learn what's happening behind the scenes. Pull requests are very welcome!</li>
<li><a href="https://client-lib.docs.iota.org/docs/iota/index.html">API Documentation</a> - The IOTA Client Library Rust API Documentation.</li>
</ul>
<h2 id="nodejs"><a class="header" href="#nodejs">Node.js</a></h2>
<ul>
<li><a href="https://client-lib.docs.iota.org/libraries/nodejs/getting_started.html">Getting Started</a> - Getting Started with Node.js and the IOTA Client Library.</li>
<li><a href="https://client-lib.docs.iota.org/libraries/nodejs/examples.html">Examples</a> - Find starting points or inspiration in the examples.</li>
<li><a href="https://github.com/iotaledger/iota.rs">Repository</a> - Browse through the code and learn what's happening behind the scenes. Pull requests are very welcome!</li>
<li><a href="https://client-lib.docs.iota.org/libraries/nodejs/api_reference.html">API Documentation</a> - The IOTA Client Library Node.js API Documentation.</li>
</ul>
<h2 id="python"><a class="header" href="#python">Python</a></h2>
<ul>
<li><a href="https://client-lib.docs.iota.org/libraries/python/getting_started.html">Getting Started</a> - Getting Started with Python and the IOTA Client Library.</li>
<li><a href="https://client-lib.docs.iota.org/libraries/python/examples.html">Examples</a> - Find starting points or inspiration in the examples.</li>
<li><a href="https://github.com/iotaledger/iota.rs/tree/dev/bindings/python">Repository</a> - Browse through the code and learn what's happening behind the scenes. Pull requests are very welcome!</li>
<li><a href="https://client-lib.docs.iota.org/libraries/python/api_reference.html">API Documentation</a> - The IOTA Client Library Python API Documentation.</li>
</ul>
<h2 id="c"><a class="header" href="#c">C</a></h2>
<ul>
<li><a href="https://iota-c-client.readthedocs.io/en/latest/index.html">Getting Started</a> - Getting Started with C and the IOTA Client Library.</li>
<li><a href="https://iota-c-client.readthedocs.io/en/latest/client_examples.html">Examples</a> - Find starting points or inspiration in the examples.</li>
<li><a href="https://github.com/iotaledger/iota.c">Repository</a> - Browse through the code and learn what's happening behind the scenes. Pull requests are very welcome!</li>
<li><a href="https://iota-c-client.readthedocs.io/en/latest/api/client.html">API Documentation</a> - The IOTA Client Library C API Documentation.</li>
</ul>
<h1 id="iota-wallet-library"><a class="header" href="#iota-wallet-library">IOTA Wallet Library</a></h1>
<p>The wallet library is a stateful library for developers; essentially it's a programmable wallet. It is recommended you use this library if you are mainly using IOTA for token transfers. This library supports the handling and monitoring multiple account/addresses at the same time. Its stateful design allows a management of multiple accounts and addresses in an effective manner.</p>
<p>In addition to this, it also supports the <a href="https://github.com/iotaledger/stronghold.rs">Stronghold.rs</a> enclave, incorporating the best security practices in one package:</p>
<p><a href="https://wallet-lib.docs.iota.org">IOTA Wallet Library full documentation</a></p>
<h2 id="rust-1"><a class="header" href="#rust-1">Rust</a></h2>
<hr />
<ul>
<li><a href="https://wallet-lib.docs.iota.org/libraries/rust/getting_started.html">Getting Started</a> - Getting Started with Rust and the IOTA Wallet Library.</li>
<li><a href="https://wallet-lib.docs.iota.org/libraries/rust/examples.html">Examples</a> - Find starting points or inspiration in the examples.</li>
<li><a href="https://github.com/iotaledger/wallet.rs">Repository</a> - Browse through the code and learn what's happening behind the scenes. Pull requests are very welcome!</li>
<li><a href="https://wallet-lib.docs.iota.org/docs/iota_wallet/index.html">API Documentation</a> - The IOTA Wallet Library Rust API Documentation.</li>
</ul>
<h2 id="nodejs-1"><a class="header" href="#nodejs-1">Node.js</a></h2>
<hr />
<ul>
<li><a href="https://wallet-lib.docs.iota.org/libraries/nodejs/getting_started.html">Getting Started</a> - Getting Started with Node.js and the IOTA Wallet Library.</li>
<li><a href="https://wallet-lib.docs.iota.org/libraries/nodejs/examples.html">Examples</a> - Find starting points or inspiration in the examples.</li>
<li><a href="https://github.com/iotaledger/wallet.rs/tree/develop/bindings/nodejs">Repository</a> - Browse through the code and learn what's happening behind the scenes. Pull requests are very welcome!</li>
<li><a href="https://wallet-lib.docs.iota.org/libraries/nodejs/api_reference.html">API Documentation</a> - The IOTA Wallet Library Node.js API Documentation.</li>
</ul>
<h2 id="python-1"><a class="header" href="#python-1">Python</a></h2>
<hr />
<ul>
<li><a href="https://wallet-lib.docs.iota.org/libraries/python/getting_started.html">Getting Started</a> - Getting Started with Python and the IOTA Wallet Library.</li>
<li><a href="https://wallet-lib.docs.iota.org/libraries/python/examples.html">Examples</a> - Find starting points or inspiration in the examples.</li>
<li><a href="https://github.com/iotaledger/wallet.rs/tree/develop/bindings/python">Repository</a> - Browse through the code and learn what's happening behind the scenes. Pull requests are very welcome!</li>
<li><a href="https://wallet-lib.docs.iota.org/libraries/python/api_reference.html">API Documentation</a> - The IOTA Wallet Library Python API Documentation.</li>
</ul>
<h1 id="iota-chrysalis-guides"><a class="header" href="#iota-chrysalis-guides">IOTA Chrysalis Guides</a></h1>
<ul>
<li><a href="networks/chrysalis-docs/docs/guides/./dev_guide.html">Developer Guide</a></li>
<li><a href="networks/chrysalis-docs/docs/guides/./exchange_guide.html">Exchange Guide</a></li>
<li><a href="networks/chrysalis-docs/docs/guides/./token_guide.html">Token Migration Guide</a></li>
<li><a href="networks/chrysalis-docs/docs/guides/./hub_guide.html">Hub Migration Guide</a></li>
</ul>
<h2 id="overall-changes-from-iota-10-to-15-chrysalis-in-a-nutshell"><a class="header" href="#overall-changes-from-iota-10-to-15-chrysalis-in-a-nutshell">Overall changes from IOTA 1.0 to 1.5 (Chrysalis) in a nutshell</a></h2>
<ul>
<li>The format of the address was changed and it is based on both <code>derivation path</code> and <code>bech32</code> standards. See <a href="networks/chrysalis-docs/docs/guides/./dev_guide.html#iota-15-address-anatomy">IOTA address anatomy</a></li>
<li>The concepts of <code>bundles</code> and <code>transactions</code> were replaced with the concepts of <code>messages</code> and <code>payloads</code>. The <code>message</code> is a data structure that is actually being broadcast in the network and represents a node (vertex) in the Tangle graph. See <a href="networks/chrysalis-docs/docs/guides/./dev_guide.html#messages-payload-and-transactions">messages, payload and transactions</a> and <a href="networks/chrysalis-docs/docs/guides/./dev_guide.html#selected-message-payloads">selected message payloads</a></li>
<li>The IOTA network is based on a DAG (Directed Acyclic Graph) to store individual <code>messages</code> (and related <code>transactions</code>). However, each <code>message</code> can newly reference up to 8 parent messages. See <a href="networks/chrysalis-docs/docs/guides/./dev_guide.html#messages-payload-and-transactions">messages, payload and transactions</a></li>
<li>The signature scheme based on <code>WOTS</code> was replaced with with <code>Ed25519</code> signature scheme. See <a href="networks/chrysalis-docs/docs/guides/./dev_guide.html#seed-and-addresses">seed and addresses</a></li>
<li>Due to the changed signature scheme, IOTA addresses are reusable without any negative security impact</li>
<li>In comparison to IOTA 1.0, which was based on ternary, IOTA 1.5 is based on binary and is thus very efficient on all kinds of current hardware devices</li>
<li>In contrast to IOTA 1.0, IOTA 1.5 addresses are perfectly reusable; even if one spends funds from the given address, it can be used again. See <a href="networks/chrysalis-docs/docs/guides/./dev_guide.html#addresskey-space">address/key space</a></li>
<li>Originally, IOTA 1.0 used an <code>account-based model</code> for tracking individual iota tokens. Chrysalis embraced <code>Unspent Transaction Output</code> (also known as <code>UTXO</code>) model to track tokens and token holders. See <a href="networks/chrysalis-docs/docs/guides/./dev_guide.html#unspent-transaction-output-utxo">Unspent Transaction Output</a></li>
<li>The approach to client libraries was completely reengineered from the ground up. There are new official client libraries that serve as <code>one-source-code-of-truth</code> to IOTA users and can be combined in a modular fashion based on particular use cases. All libraries provide a binding to other programming languages. See <a href="networks/chrysalis-docs/docs/guides/../libraries/overview.html">client libraries</a></li>
<li>Our official iota tools, such as wallet software, use the same libraries under the hood and so any developer may taste the same <a href="https://en.wikipedia.org/wiki/Eating_your_own_dog_food">dog food</a> as we do</li>
<li>The official client libraries embraced <code>Hierarchical Deterministic Wallets</code> approach which is fully <code>BIP44</code> compatible. See <a href="networks/chrysalis-docs/docs/guides/./dev_guide.html#addresskey-space">address/key space</a></li>
<li>There is a new official wallet software called Firefly. See <a href="https://blog.iota.org/firefly-beta-release/">firefly beta release</a></li>
</ul>
<h1 id="developer-guide-to-chrysalis"><a class="header" href="#developer-guide-to-chrysalis">Developer guide to Chrysalis</a></h1>
<p>This is a quick guide meant to help you navigate through some of the differences you will encounter while migrating from IOTA 1.0 to IOTA 1.5, also known as Chrysalis.</p>
<h2 id="seed-and-addresses"><a class="header" href="#seed-and-addresses">Seed and addresses</a></h2>
<p>In Chrysalis, all ternary conversions apart from PoW have been removed which results in a better, faster developer experience. Additionally, the WOTS-Signature has been replaced by a <code>Ed25519</code> signature scheme. This means that you can now use an address multiple times to send and receive coins.</p>
<p>With these changes, and the further adoption of industry standards, both seeds and addresses will look completely different in IOTA Chrysalis.</p>
<p>IOTA 1.0 address:</p>
<pre><code class="language-bash=">UDYXTZBE9GZGPM9SSQV9LTZNDLJIZMPUVVXYXFYVBLIEUHLSEWFTKZZLXYRHHWVQV9MNNX9KZC9D9UZWZRGJMIGPDW
</code></pre>
<p>IOTA 1.5 (Chrysalis) address (bech32 standard):</p>
<p>Mainnet with <code>iota</code></p>
<pre><code class="language-bash=">iota1qpw6k49dedaxrt854rau02talgfshgt0jlm5w8x9nk5ts6f5x5m759nh2ml
</code></pre>
<p>Testnet with <code>atoi</code></p>
<pre><code class="language-bash=">atoi1qpw6k49dedaxrt854rau02talgfshgt0jlm5w8x9nk5ts6f5x5m75zaxtpj
</code></pre>
<h3 id="iota-15-address-anatomy"><a class="header" href="#iota-15-address-anatomy">IOTA 1.5 address anatomy</a></h3>
<p>The IOTA address is based on the Ed25519 signature scheme and it is usually represented by the Bech32 (checksummed base32) format string of 64 characters or hex format:</p>
<table>
    <thead>
        <tr>
            <th colspan=4><center>iota1qpw6k49dedaxrt854rau02talgfshgt0jlm5w8x9nk5ts6f5x5m759nh2ml</center></th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan=4><center>three distinguished parts</center></td>
        </tr>
        <tr>
            <td><center><strong>human-readable id</strong></center></td>
            <td><center><strong>separator</strong></center></td>
            <td><center><strong>data</strong></center></td>
            <td><center><strong>checksum</strong></center></td>
        </tr>
        <tr>
            <td><center>iota | atoi</center></td>
            <td><center>1</center></td>
            <td><center>48 bytes [0..9a..z]</center></td>
            <td><center>6 characters [0..9a..z]</center></td>
        </tr>
        <tr>
            <td><center>iota</center></td>
            <td><center>1</center></td>
            <td><center>qpw6k49dedaxrt854rau02talgfshgt0jlm5w8x9nk5ts6f5x5m75</center></td>
            <td><center>9nh2ml</center></td>
        </tr>
        <tr>
            <td colspan=4>iota = mainnet; atoi = testnet</td>
        </tr>
    </tbody>
</table>
<p>More information: <a href="https://github.com/Wollac/protocol-rfcs/blob/bech32-address-format/text/0020-bech32-address-format/0020-bech32-address-format.md">Protocol-rfc#0020</a></p>
<h3 id="seed"><a class="header" href="#seed">Seed</a></h3>
<p>With the new <a href="networks/chrysalis-docs/docs/guides/../libraries/wallet.html">wallet library</a>, developers do not need to use a self-generated seed anymore. By default, the seed is created and stored in Stronghold, our in-house built security enclave. It is not possible to extract the seed from Stronghold for security purposes. Stronghold uses encrypted snapshots that can easily be backed up and securely shared between devices. These snapshots are then further secured with a password.</p>
<p>More information about IOTA Wallet Library is available on <a href="https://wallet-lib.docs.iota.org">Wallet docs page</a> or in the <a href="networks/chrysalis-docs/docs/guides/exchange_guide.html">Exchange guide</a>, which is mainly focused on value transactions.</p>
<blockquote>
<p>Please note, it is highly recommended to NOT use online seed generators at all. The seed is the only key to the given funds.</p>
</blockquote>
<p>A root of the <code>Ed25519</code> signature scheme is basically a <code>32-byte (256-bit)</code> uniformly randomly generated seed based on which all private keys and corresponding addresses are generated. A seed may be represented by a string of 64 characters using <code>[0-9a-f]</code> alphabet (32 bytes encoded in hexadecimal).</p>
<p>The seed can be, for example, generated using the SHA256 algorithm on some random input generated by cryptographically secure pseudo-random generator, such as <a href="https://client-lib.docs.iota.org/libraries/python/examples.html#generating-seed-and-addresses">os.urandom()</a>.</p>
<p>Seed examples (a single seed per line):</p>
<pre><code class="language-plaintext">4892e2265c45734d07f220294b1697244a8ab5beb38ba9a7d57aeebf36b6e84a
37c4aab22a5883595dbc77907c1626c1be39d104df39c5d5708423c0286aea89
e94346bce41402155ef120e2525fad2d0bf30b10a89e4b93fd8471df1e6a0981
...
</code></pre>
<blockquote>
<p>In modern wallet implementations, such as our <a href="https://chrysalis.docs.iota.org/libraries/wallet.html">wallet.rs library</a> and <a href="https://blog.iota.org/firefly-beta-release/">firefly wallet</a>, the seed is usually generated from a <code>seed mnemonic</code> (<code>seed phrase</code>), using <a href="https://en.bitcoin.it/wiki/BIP_0039">BIP39 standard</a>, to be better memorized/stored by humans. It is based on randomly generated list of english words and is later used to generate the seed. Either way, the seed is a root for all generated private keys and addresses</p>
</blockquote>
<p><a href="https://github.com/Wollac/protocol-rfcs/blob/mnemonic-seed/text/0010-mnemonic-ternary-seed/0010-mnemonic-ternary-seed.md">Protocol-rfc#0010</a></p>
<h3 id="addresskey-space"><a class="header" href="#addresskey-space">Address/key space</a></h3>
<p>As mentioned above, IOTA 1.5 embraced some existing industry standards, which is obvious even during an address generation process. This includes the <a href="https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki">BIP32</a> standard that describes an approach to <em>Hierarchical Deterministic Wallets</em>. The standard was improved by <a href="https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki">BIP44</a> recently.</p>
<p>These standards define a tree structure as a base for address and key space generation which is represented by a <code>derivation path</code>:</p>
<pre><code class="language-plaintext">m / purpose / coin_type / account / change / address_index
</code></pre>
<ul>
<li><code>m</code>: a master node (seed)</li>
<li><code>purpose</code>: constant which is {44}</li>
<li><code>coin_type</code>: a constant set for each crypto currency. IOTA = 4218, for instance.</li>
<li><code>account</code>: account index. Zero-based increasing <code>int</code>. This level splits the address/key space into independent branches (ex. user identities) which each has own set of addresses/keys</li>
<li><code>change</code>: change index which is <code>{0, 1}</code>, also known as <code>wallet chain</code>.<br />
There are two independent chain of addresses/keys. <code>0</code> is reserved for public addresses (for coin receival) and <code>1</code> is reserved for internal (also known as change) addresses to which a transaction change is returned. <em>In comparison to IOTA 1.0, IOTA 1.5 is fine with address reuse, and so it is, technically speaking, valid to return transaction change to the same originating address. It is up to developers whether to leverage it or not. <code>iota.rs</code> library and its sibling <code>wallet.rs</code> help with either scenario</em>.</li>
<li><code>address_index</code>: address index. Zero-based increasing <code>int</code> that indicates an address index</li>
</ul>
<p>As outlined, there is a  large address/key space that is secured by a single seed.</p>
<p>And there are few additional things to note:</p>
<ul>
<li>Each level defines a completely different subtree (subspace) of addresses/keys and those are never mixed up</li>
<li>The hierarchy is ready to &quot;absorb&quot; addresses/keys for  different coins at the same time (<code>coin_type</code>) and all those coins are secured by the same seed</li>
<li>There may be also other <code>purposes</code> in the future. However, let's consider a single purpose as of now. The constant <code>44</code> stands for BIP44.</li>
<li>The standard was agreed upon different crypto communities, although not all <code>derivation path</code> components are always in active use. For example, <code>account</code> is not always actively leveraged across crypto space (if this is a case then there is usually <code>account=0</code> used)</li>
<li>Using different <code>accounts</code> may be useful to split addresses/key into some independent spaces and it is up to developers to implement.<br /></li>
</ul>
<p><em>Please note, having many different accounts may have a negative impact on performance while <a href="https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki#account-discovery">account discovery</a> phase. So, if you are after using multiple, different accounts then you may be interested in our stateful library <a href="https://chrysalis.docs.iota.org/libraries/wallet.html">wallet.rs</a> that incorporates all business logic needed to efficiently manage independent accounts. Additionally, our <a href="https://chrysalis.docs.iota.org/guides/exchange_guide.html">exchange guide</a> provides some useful tips how different accounts may be leveraged.</em></p>
<p><img src="networks/chrysalis-docs/docs/guides/assets/address_generation.svg" alt="address_generation" /></p>
<p>So in case of IOTA 1.5 (Chrysalis), the derivation path of address/key space is <code>[seed]/44/4218/{int}/{0,1}/{int}</code>:</p>
<ul>
<li>The levels <code>purpose</code> and <code>coin_type</code> are given</li>
<li>The rest levels are up to developers to integrate, specifically <code>seed</code>, <code>account</code>, <code>wallet_chain</code> and <code>address_index</code></li>
</ul>
<p><a href="https://github.com/iotaledger/protocol-rfcs/blob/ee07797acb5940b7dbb5c3411b184ccdc6afdbb1/text/0000-ed25519-signature-scheme/0000-ed25519-signature-scheme.md">Protocol-rfc#0003</a></p>
<h2 id="messages-payloads-and-transactions"><a class="header" href="#messages-payloads-and-transactions">Messages, payloads, and transactions</a></h2>
<p>In comparison to original the IOTA 1.0, IOTA 1.5 also introduced some fundamental changes to the underlying data structures. The original concept of <code>transactions</code> and <code>bundles</code> is gone, and has been replaced by a concept of <code>messages</code> and <code>payloads</code>.</p>
<p>A <code>message</code> is a data structure that is actually being broadcast in the IOTA 1.5 network and represents a node (vertex) in the Tangle graph.</p>
<p>It can refer to up to 8 previous messages and once a message is attached to the Tangle and approved by a milestone, the Tangle structure ensures the content of the message is unaltered. Every message is referenced by a <code>message_id</code> which is based on a hash algorithm (<code>Blake2b256</code>) of binary content of the message. It also includes previous Tangle messages as its <code>parents</code> which means it is not possible to alter the given message without altering previous messages in the Tangle.</p>
<p>The <code>message</code> is an atomic unit that is confirmed by the network as a whole.</p>
<blockquote>
<p>IOTA is no longer based on ternary. IOTA 1.5 uses binary to encode and broadcast all underlying data entities</p>
</blockquote>
<p>A <code>message</code> is arbitrary in size (up to 35 kB) and it can hold variable sets of information called <code>payloads</code>. The number of payloads a single message can encapsulate is not given. Even a message without a <code>payload</code> is completely valid and can be broadcast. The <code>Message</code> itself does not include any timestamp; a message timestamp is derived from an acceptance of the given message by the Tangle network.</p>
<p>A<code>payload</code> represents a layer of concern. Some payloads may change a state of the ledger (ex. <code>SignedTransactions</code>) and some may provide extra features to some specific applications and business use cases (ex. <code>IndexationPayload</code>).</p>
<p>There are already implemented core payloads, such as <code>SignedTransaction</code>, <code>MilestonePayload</code>, and <code>IndexationPayload</code> but the message and payload definition is generic enough to incorporate any future payload(s) the community agrees upon.</p>
<p>Needless to say, the IOTA network ensures the outer structure of the message itself is valid and strictly complies with network consensus protocol. However, the inner structure is very flexible, future-proof, and offers an unmatched network extensibility.</p>
<p><img src="networks/chrysalis-docs/docs/guides/assets/messages_in_tangle.svg" alt="messages_in_tangle" /></p>
<p>The current IOTA 1.5 network incorporates the following core payloads:</p>
<ul>
<li><code>SignedTransaction</code>: a payload that describes <code>UTXO</code> transactions that are the cornerstones of value-based transfers in IOTA network. Via this payload, a <code>message</code> can be also cryptographically signed</li>
<li><code>MilestonePayload</code>: a payload that is emitted by the Coordinator</li>
<li><code>IndexationPayload</code>: a payload that enables the addition of an index to the encapsulating message, as well as some arbitrary data. The given index can be later used to search the message(s).</li>
</ul>
<p>In comparison to IOTA 1.0, a <code>message</code> itself is not directly related to the IOTA address while broadcasting to the IOTA 1.5 network. Such messages are referenced using <code>message_id</code>. Messages are indirectly related to IOTA addresses via <code>SignedTransaction</code> payload, specifically the <code>UTXO</code> section.</p>
<p><a href="https://github.com/GalRogozinski/protocol-rfcs/blob/message/text/0017-message/0017-message.md">Protocol-rfc#0017</a>; 
<a href="https://github.com/luca-moser/protocol-rfcs/blob/signed-tx-payload/text/0000-transaction-payload/0000-transaction-payload.md">Protocol-rfc#0018</a></p>
<h2 id="unspent-transaction-output-utxo"><a class="header" href="#unspent-transaction-output-utxo">Unspent Transaction Output (UTXO)</a></h2>
<p>Originally, IOTA 1.0 used an <code>account-based model</code> for tracking individual iota tokens: <em>each IOTA address held a number of tokens and the aggregated number of tokens from all iota addresses was equal to the total supply.</em></p>
<p>In contrast, IOTA 1.5 uses the <code>unspent transaction output</code> model, or <code>UTXO</code>. It is based on an idea to track unspent amounts of tokens via a data structure called <code>output</code>.</p>
<p>Below is a simplified analogy of how the UTXO works:</p>
<ul>
<li>There are 100 tokens recorded in the ledger as <code>Output A</code> and this output belongs to Alice. So, the <strong>initial state of the ledger</strong>: <code>Output A</code> = 100 tokens</li>
<li>Alice sends 20 tokens to Paul, 30 tokens to Linda, and keeps 50 tokens at her disposal</li>
<li>Her 100 tokens are recorded as <code>Output A</code> so she has to divide (spent) tokens and create three new outputs:<br /><code>Output B</code> with 20 tokens that goes to Paul, <code>Output C</code> with 30 tokens that goes to Linda, and finally <code>Output D</code> with the rest of the 50 tokens that she kept for herself</li>
<li><strong>Original <code>Output A</code></strong> was completely spent and cannot be used any more. It has been spent and so <strong>becomes irrelevant</strong> to ledger state.</li>
<li><strong>New state of ledger</strong>: <code>Output B</code> = 20 tokens, <code>Output C</code> = 30 tokens and <code>Output D</code> = 50 tokens</li>
<li>The total supply remains the same, just number of outputs differs and some outputs were replaced by other outputs in the process</li>
</ul>
<p><img src="networks/chrysalis-docs/docs/guides/assets/utxo.svg" alt="utxo" /></p>
<p>The key takeaway of the outlined process above is the fact that each unique <code>output</code> can be spent <strong>only once</strong>. Once the given <code>output</code> is spent, it cannot be used any more and is irrelevant in regards to the ledger state.</p>
<p>So even if Alice still wants to keep remaining tokens at her fingertips, those tokens have to be moved to a completely new <code>output</code> that can be, for instance, still tied to the Alice's same iota address as before.</p>
<p>Every <code>output</code> also stores information about an IOTA address to which it is coupled with. So addresses and tokens are indirectly coupled via <code>outputs</code>. Basically, the sum of outputs and their amounts under the given address is a balance of the given address, ie., the number of tokens the given address can spend. And the sum of all unspent outputs and their amounts is equal to the total supply.</p>
<p><code>Outputs</code> are being broadcasted encapsulated in a <code>message</code> as a part of <code>SignedTransaction</code> payload.</p>
<p><a href="https://github.com/luca-moser/protocol-rfcs/blob/signed-tx-payload/text/0000-transaction-payload/0000-transaction-payload.md">Protocol-rfc#0018</a></p>
<h2 id="selected-message-payloads"><a class="header" href="#selected-message-payloads">Selected message payloads</a></h2>
<p>Currently, there are two commonly used message payloads, <code>IndexationPayload</code> and <code>SignedTransaction</code> which can be combined based as needed.</p>
<p><a href="https://github.com/luca-moser/protocol-rfcs/blob/signed-tx-payload/text/0000-transaction-payload/0000-transaction-payload.md">Protocol-rfc#0000</a></p>
<h3 id="indexationpayload"><a class="header" href="#indexationpayload">IndexationPayload</a></h3>
<p><code>IndexationPayload</code> is a payload type that can be used to attach an arbitrary <code>data</code> and key <code>index</code> to a message. When this particular payload is leveraged, then a message and related data entity can be searched via key <code>index</code> in addition to a <code>message_id</code>.</p>
<h3 id="signedtransaction"><a class="header" href="#signedtransaction">SignedTransaction</a></h3>
<p><code>SignedTransaction</code> is a payload type that is used to transfer value-based messages as <code>UTXO</code>. It changes the ledger state as old <code>outputs</code> are being spent (replaced) and new <code>outputs</code> are being created.</p>
<p>Each <code>SignedTransaction</code> includes the following set of information:</p>
<ul>
<li><code>inputs</code> - a list of valid <code>outputs</code> that should be used to fund the given transaction. Outputs are uniquely referenced via previous <code>transaction_id</code> and inner <code>index</code>. At least one output has to be given with enough balance to source all <code>outputs</code> of the given message</li>
<li><code>outputs</code> - a list of IOTA address(es) and related amount(s) the input <code>outputs</code> should be split among. Based on this information, new <code>UTXO</code> outputs are being created</li>
<li><code>unlock_blocks</code> - it includes a transaction signature(s) (currently based on <code>Ed25519</code> scheme) that proves token ownership based on a valid seed</li>
</ul>
<h2 id="dust-protection"><a class="header" href="#dust-protection">Dust protection</a></h2>
<p>Since IOTA is feeless and has the ability to send microtransactions, attackers could use this to spam the network with very low value transactions, which we call dust. To avoid this, we only allow microtransaction below 1Mi (dust) of IOTA tokens to another address if you already have at least 1Mi as a dust allowance output on that address. The number of allowed dust outputs on an address is the amount of the dust allowance outputs divided by 100,000 and rounded down, i.e. 10 outputs for each 1 Mi deposited, with a maximum of 100 dust outputs in total.</p>
<blockquote>
<p>In the UTXO model, each node in the network needs to keep track of all the currently unspent outputs. When the number of outputs becomes too large, it can cause performance and memory issues. The RFC below proposes a new protocol rule regarding the processing of outputs where they transfer a very small amount of IOTA’s so-called dust outputs. Dust outputs are only allowed when they are backed up by a certain deposit on the receiving address. This limits the amount of dust outputs, thus making it expensive to proliferate dust. Since a receiver must make a deposit, the protocol makes receiving dust an opt-in feature.</p>
</blockquote>
<p><a href="https://github.com/GalRogozinski/protocol-rfcs/blob/dust/text/0032-dust-protection/0032-dust-protection.md">Protocol-rfc#0032</a></p>
<h2 id="up-to-8-parents"><a class="header" href="#up-to-8-parents">Up to 8 Parents</a></h2>
<p>With IOTA 1.0, you always had to reference 2 parent transactions. With Chrysalis, we introduce a more dynamic number of parent nodes where you can reference up to 8 parents. We recommend you reference at least 2 unique parents at all times for the best possible results.</p>
<p><a href="https://github.com/GalRogozinski/protocol-rfcs/blob/message/text/0017-message/0017-message.md">Protocol-rfc#0017</a></p>
<h1 id="exchange-guide"><a class="header" href="#exchange-guide">Exchange guide</a></h1>
<h2 id="the-iota-wallet-library"><a class="header" href="#the-iota-wallet-library">The IOTA wallet library</a></h2>
<blockquote>
<p>Easily integrate IOTA with your exchange, custody solution, or product.</p>
</blockquote>
<p>IOTA is built on an architecture that was designed to be the backbone of the Internet of Things (IoT) environment of the future. But this architecture has made it more challenging for service providers like exchanges to integrate IOTA compared to traditional blockchain-based distributed ledgers.</p>
<p>Within the Chrysalis update (also known as IOTA 1.5), some building blocks have been changed to be more approachable and more aligned with currently leveraged standards. We also ship many <a href="networks/chrysalis-docs/docs/guides/../libraries/overview.html">client libraries</a> to help developers implement IOTA into their applications:
<img src="networks/chrysalis-docs/docs/guides/assets/wallet_rs_layers.svg" alt="layers" /></p>
<h2 id="how-do-i-implement-it-to-my-exchange"><a class="header" href="#how-do-i-implement-it-to-my-exchange">How do I implement it to my exchange?</a></h2>
<p>In <a href="networks/chrysalis-docs/docs/guides/../libraries/wallet.html">wallet.rs</a>, we use an account model so you can create an account for each of your users. Another approach would be to use one account and generate multiple addresses, which you can then link to the users in your database. The wallet library is designed to be as flexible as possible to back up any of your use cases.</p>
<p>Since IOTA addresses in the Chrysalis network are perfectly reusable, they can be mapped to your users in a clear and concise way:</p>
<ul>
<li>Create an account for every user -&gt; <code>Multi Account</code> approach</li>
<li>Create one account with many addresses -&gt; <code>Single account</code> approach</li>
</ul>
<p>The library supports derivation for multiple accounts from a single seed. An account is simply a deterministic identifier from which multiple addresses can be further derived. </p>
<p>The library also allows consumers to assign a meaningful alias to each account. In addition to this, generated individual accounts can be also searched via generated addresses. This means it does not matter whether aliases or addresses are known as the search for the related account is very straightforward using the <code>wallet.rs</code> library.</p>
<p>It also leaves the choice to users if they want to segregate their funds across multiple accounts or multiple addresses. The following illustration outlines the relationships between seed, accounts, and addresses: </p>
<p><img src="networks/chrysalis-docs/docs/guides/assets/accounts.svg" alt="accounts" /></p>
<h3 id="multi-account-approach"><a class="header" href="#multi-account-approach">Multi account approach</a></h3>
<p>The multi account approach is used to create an account for each individual user. The created accounts can then be linked to the internal user IDs as an account alias, which are distinctly separated.</p>
<h3 id="single-account-approach"><a class="header" href="#single-account-approach">Single account approach</a></h3>
<p>The single account approach allows for just one account and creates addresses for each individual user. The associated addresses are then linked to the internal user IDs and store who owns which address in the database. Most exchanges are more familiar with the single account approach and find it easier to use, implement, and backup.</p>
<h2 id="implementation-guide"><a class="header" href="#implementation-guide">Implementation guide</a></h2>
<p>This guide explains how to use the IOTA Wallet Library to successfully implement IOTA into an exchange. If you already implemented the IOTA Hub, please visit the <a href="networks/chrysalis-docs/docs/guides/./hub_guide.html">Hub Migration Guide</a>.</p>
<p>Features of the Wallet Library:</p>
<ul>
<li>Secure seed management</li>
<li>Account management (with multiple accounts and multiple addresses)</li>
<li>Confirmation monitoring</li>
<li>Deposit address monitoring</li>
<li>Backup and restore functionality</li>
</ul>
<h2 id="how-does-it-work"><a class="header" href="#how-does-it-work">How does it work?</a></h2>
<p>The Wallet Library is a stateful package with a standardized interface for developers to build applications involving IOTA value transactions. It offers abstractions to handle IOTA payments and can optionally interact with the IOTA Stronghold for seed handling, seed storage, and state backup. Alternatively, you can use a SQLite database; however, using the Stronghold component is highly recommended due to the most advanced level of security being applied.</p>
<p>For reference, you can see the <a href="https://wallet-lib.docs.iota.org">full documentation here</a>.</p>
<p>The following examples cover the <em>multi account approach</em> using <code>NodeJS</code> binding:</p>
<ol>
<li>Setup the Wallet Library</li>
<li>Create an account for each user</li>
<li>Generate a user address for deposits</li>
<li>Listen to events</li>
<li>Check the user balance</li>
<li>Enable withdrawals</li>
</ol>
<p><em>Note: If you are looking for other languages, please read the <a href="networks/chrysalis-docs/docs/guides//libraries/wallet.html">wallet library overview</a>.</em></p>
<p>Since all <code>wallet.rs</code> bindings are based on core principles provided by the <code>wallet.rs</code> library, the outlined approach is very similar regardless of the programming language of your choice.</p>
<h3 id="1-setup-the-wallet-library"><a class="header" href="#1-setup-the-wallet-library">1. Setup the Wallet library</a></h3>
<p>First, let's install the components that are needed to use <code>wallet.rs</code> and the binding of your choice; it may vary a bit from language to language. In the case of the <code>NodeJs</code> binding, it is quite straightforward since it is distributed via the <code>npm</code> package manager. We also recommend you use <code>dotenv</code> for password management.</p>
<p>For reference, read more about <a href="networks/chrysalis-docs/docs/guides/backup_security.html">backup and security here</a>.</p>
<pre><code class="language-bash">npm install @iota/wallet dotenv
touch .env
</code></pre>
<p>Then, input your password to the <code>.env</code> file like this:</p>
<pre><code class="language-bash">SH_PASSWORD=&quot;here is your super secure password&quot;
</code></pre>
<p>Once you have everything needed to use the <code>wallet.rs</code> library, it is necessary to initialize the <code>AccountManager</code> instance which creates (opens) a secure storage for individual accounts (backed up by <code>Stronghold</code> by default).</p>
<p>The storage is encrypted at rest, so you need a strong password and location where to put your storage. </p>
<p><em>Note: manage your password with the utmost care</em>.</p>
<p>Technically speaking, &quot;storage&quot; means a single file called <code>wallet.stronghold</code>. It is also needed to generate a seed (mnemonic) that serves as a cryptographic key from which all accounts and related addresses are generated.</p>
<p>One of the key principles behind the <code>stronghold</code>-based storage is that no one can get a seed from the storage. You deal with all the accounts purely via the <code>Account_Manager</code> instance where all complexities are hidden under the hood and are dealt with in a secure way. In case you would also like to store a seed somewhere else, there is another method, <code>AccountManager.generateMnemonic()</code>, that generates random seeds. This method can be leveraged before the actual account initialization.</p>
<p>Note that it is highly recommended to store the <code>stronghold</code> password and the <code>stronghold</code> database on separate devices. Please refer to the <a href="networks/chrysalis-docs/docs/guides/backup_security.html">backup and security guide</a> for more information.</p>
<p>Import the Wallet Library and create an account manager:</p>
<pre><code class="language-javascript">    const { AccountManager, SignerType } = require('@iota/wallet')

    // Setup IOTA Wallet Library
    const manager = new AccountManager({
        storagePath: './storage'
    })
    manager.setStrongholdPassword(process.env.SH_PASSWORD)
    manager.storeMnemonic(SignerType.Stronghold, manager.generateMnemonic()) // seed generation
</code></pre>
<p>Once the stronghold storage is created, it is not needed to generate the seed any longer (<code>manager.storeMnemonic(SignerType.Stronghold, manager.generateMnemonic())</code>). It has been already saved in the storage together with all account information.</p>
<h3 id="2-create-an-account-for-an-user"><a class="header" href="#2-create-an-account-for-an-user">2. Create an account for an user</a></h3>
<p>Once the backend storage is created, individual accounts for individual users can be created:</p>
<pre><code class="language-javascript">    let account = await manager.createAccount({
        alias: user_id,  // an unique id from your existing user
        clientOptions: { node: 'http://api.lb-0.testnet.chrysalis2.com', localPow: false }
    })
</code></pre>
<p>Each account is related to a specific IOTA network (mainnet/devnet) which is referenced by a node property, such as node url (in this example, the Chrysalis testnet balancer).</p>
<p>For more information about <code>clientOptions</code>, please refer to <a href="https://wallet-lib.docs.iota.org/libraries/nodejs/api_reference.html">Wallet NodeJs API Reference</a>.</p>
<p>The <code>Alias</code> can be whatever fits to the given use case and should be unique. The <code>alias</code> is usually used to identify the given account later on. Each account is also represented by an <code>index</code> which is incremented (by 1) every time a new account is created. Any account can be then referred to via <code>index</code>, <code>alias</code>, or one of its generated <code>addresses</code>.</p>
<p>Once an account has been created, you get an instance of it using the following methods: <code>AccountManager.getAccount(accountId)</code>, <code>AccountManager.getAccountByAlias(alias)</code> or <code>AccountManager.getAccounts()</code>.</p>
<p>The most common methods of <code>account</code> instance include:</p>
<ul>
<li><code>account.alias()</code> - returns an alias of the given account</li>
<li><code>account.listAddresses()</code> - returns list of addresses related to the account</li>
<li><code>account.getUnusedAddress()</code> - returns a first unused address</li>
<li><code>account.generateAddress()</code> - generate a new address for the address index incremented by 1</li>
<li><code>account.balance()</code> - returns the balance for the given account</li>
<li><code>account.sync()</code> - sync the account information with the tangle</li>
</ul>
<h3 id="3-generate-a-user-address-to-deposit-funds"><a class="header" href="#3-generate-a-user-address-to-deposit-funds">3. Generate a user address to deposit funds</a></h3>
<p><code>Wallet.rs</code> is a stateful library which means it caches all relevant information in storage to provide performance benefits while dealing with, potentially, many accounts/addresses.</p>
<p><em>Note: sync the account info with the network during the wallet manipulation to be sure the storage reflects an actual state of the ledger (network)</em>. </p>
<p>Every account can own multiple addresses. Addresses are represented by an <code>index</code> which is incremented (by 1) every time a new address is created. The latest address is accessible via <code>account.latestAddress()</code>: </p>
<pre><code class="language-javascript">    // Always sync before account interactions
    console.log('syncing...')
    const synced = await account.sync()
    console.log('synced!')

    // By design, the last address of each account is an unused address which can be used as deposit address
    const latestAddress = account.latestAddress()

    console.log('Need a refill? Send it to this address:', latestAddress)
</code></pre>
<p>Feel free to fill the address with Testnet Tokens with the <a href="https://faucet.testnet.chrysalis2.com/">IOTA Faucet</a> to test it.</p>
<p>Addresses are of two types, <code>internal</code> and <code>public</code> (external):</p>
<ul>
<li>Each set of addresses are independent from each other and has an independent <code>index</code> id</li>
<li>Addresses that are created by <code>account.generateAddress()</code> are indicated as <code>internal=false</code> (public)</li>
<li>Internal addresses (<code>internal=true</code>) are called <code>change</code> addresses and are used to send the excess funds to them</li>
<li>The approach is also known as a <em>BIP32 Hierarchical Deterministic wallet (HD Wallet)</em></li>
</ul>
<p><em>Note: You may remember IOTA 1.0 network in which addresses were not reusable. It is no longer true and addresses can be reused multiple times in IOTA 1.5 (Chrysalis) network.</em></p>
<h3 id="4-listen-to-events"><a class="header" href="#4-listen-to-events">4. Listen to events</a></h3>
<p>The <code>Wallet.rs</code> library supports several events for listening. As soon as the given event occurs, a provided callback is triggered.</p>
<p>Below is an example of fetching existing accounts and listening to transaction events coming into the account:</p>
<pre><code class="language-javascript">    const { addEventListener } = require('@iota/wallet')

    const callback = function(err, data) {
        if(err) console.log(&quot;err:&quot;, err)
        console.log(&quot;data:&quot;, data)
    }

    //Adds a new event listener with a callback in the form of (err, data) =&gt; {}. Supported event names:
    addEventListener(&quot;BalanceChange&quot;, callback)

    // Possible Event Types:
    //
    // ErrorThrown
    // BalanceChange
    // NewTransaction
    // ConfirmationStateChange
    // Reattachment
    // Broadcast

</code></pre>
<p>Example output:</p>
<pre><code class="language-bash">data: {
  accountId: 'wallet-account://1666fc60fc95534090728a345cc5a861301428f68a237bea2b5ba0c844988566',
  address: {
    address: 'atoi1q9c6r2ek5w2yz54en78m8dxwl4qmwd7gmh9u0krm45p8txxyhtfry6apvwj',
    balance: 20000000,
    keyIndex: 0,
    internal: false,
    outputs: [ [Object], [Object] ]
  },
  balance: 20000000
}
</code></pre>
<p><code>accountId</code> can then be used to identify the given account via <code>AccountManager.getAccount(accountId)</code>.</p>
<p>For reference, you can read more about events in the <a href="https://wallet-lib.docs.iota.org/libraries/nodejs/api_reference.html#addeventlistenerevent-cb">API reference</a>.</p>
<h3 id="5-check-the-account-balance"><a class="header" href="#5-check-the-account-balance">5. Check the account balance</a></h3>
<p>Get the available account balance across all addresses of the given account:</p>
<pre><code class="language-javascript">    // Always sync before account interactions
    console.log('syncing...')
    const synced = await account.sync()
    console.log('synced!')
    let balance = account.balance().available
    console.log('available balance', balance)
</code></pre>
<h3 id="6-enable-withdrawals"><a class="header" href="#6-enable-withdrawals">6. Enable withdrawals</a></h3>
<p>Sending tokens is performed via the <code>SyncedAccount</code> instance that is a result of the <code>account.sync()</code> function:</p>
<pre><code class="language-javascript">    console.log('syncing...')
    const synced = await account.sync()
    console.log('available balance', account.balance().available)

    const address = 'atoi1qykf7rrdjzhgynfkw6z7360avhaaywf5a4vtyvvk6a06gcv5y7sksu7n5cs'

    // TODO: Check if address is valid.

    const amount = 1000000 // Amount in IOTA: 1000000 == 1 MIOTA

    const node_response = await synced.send(
        address,
        amount
    )

    console.log(&quot;Check your message on https://explorer.iota.org/chrysalis/message/&quot;, node_response.id)
</code></pre>
<p>The full function signature is <code>SyncedAccount.send(address, amount[, options])</code>.</p>
<p>Default options are perfectly fine and get the job done; however, additional options can be provided, such as <code>remainderValueStrategy</code>:</p>
<ul>
<li><code>changeAddress</code>: Send the remainder value to an internal address</li>
<li><code>reuseAddress</code>: Send the remainder value back to its original address</li>
</ul>
<p>The <code>SyncedAccount.send()</code> function returns a <code>wallet message</code> that fully describes the given transaction. The <code>messageId</code> can be used later for checking a confirmation status. Individual messages related to the given account can be obtained via <code>account.listMessages()</code> function.</p>
<p>Please note that when sending tokens, a <a href="networks/chrysalis-docs/docs/guides/dev_guide.html#dust-protection">dust protection</a> mechanism should be considered. </p>
<h1 id="iota-hub-migration-guide"><a class="header" href="#iota-hub-migration-guide">IOTA Hub migration guide</a></h1>
<blockquote>
<p>This guide will explain how you can switch from IOTA Hub to using wallet.rs or its bindings instead.</p>
</blockquote>
<p>Because of the unique features of IOTA 1.0, it was difficult to manage IOTA transactions with just a library. With the new Chrysalis update, the whole protocol was updated to be more accommodating to industry wide standards and developer friendliness. </p>
<p>IOTA Hub will be deprecated with the Chrysalis upgrade and will not work with the new protocol changes. If you still use Hub, we ask you to utilize our new wallet library (iota.rs or bindings) where you can easily manage IOTA addresses, deposits, and withdrawals for user accounts.</p>
<p>To upgrade from Hub to a Chrysalis implementation you need to:</p>
<ul>
<li>Integrate the Chrysalis network using wallet.rs as mentioned in the Exchange section</li>
<li>Pause withdrawals/deposits</li>
<li>Make sure all balances have been swept and all deposits have been processed</li>
<li>Transfer all IOTA to a generated migration address (instructions to be provided)</li>
<li>Once migrated, transfer the IOTA coins to your hot wallet account on your wallet.rs implementation</li>
</ul>
<h1 id="backup-and-security"><a class="header" href="#backup-and-security">Backup and security</a></h1>
<p>Security Checklist</p>
<ul>
<li>How to backup your account</li>
<li>How to restore from a backup</li>
<li>How to export a user's Stronghold</li>
<li>How to rekey a Stronghold/password rotation</li>
<li>Do's and don'ts</li>
</ul>
<h2 id="security-checklist"><a class="header" href="#security-checklist">Security checklist</a></h2>
<ul>
<li><input disabled="" type="checkbox"/>
I use Stronghold</li>
<li><input disabled="" type="checkbox"/>
I use a strong password (32 character length, Shannon Entropy ~ 4.0) for encrypting the stronghold</li>
<li><input disabled="" type="checkbox"/>
I rotate the stronghold password on a regular basis</li>
<li><input disabled="" type="checkbox"/>
I create a daily backup of the stronghold.snapshot file</li>
<li><input disabled="" type="checkbox"/>
I keep a secure history of passwords used (for recovery)</li>
<li><input disabled="" type="checkbox"/>
I use a secure password management service that integrates with the server</li>
<li><input disabled="" type="checkbox"/>
I use a linux based server (best memory security)</li>
<li><input disabled="" type="checkbox"/>
My server is isolated behind a DMZ</li>
</ul>
<h2 id="how-to-backup-your-account"><a class="header" href="#how-to-backup-your-account">How to backup your account</a></h2>
<p>A simple copy of the stronghold.snapshot file works as a backup (e.g. a daily cronjob rsync/scp with a datetime suffix for example).</p>
<h2 id="how-to-restore-from-a-backup"><a class="header" href="#how-to-restore-from-a-backup">How to restore from a backup</a></h2>
<p>Simply place a snapshot file in your directory that wallet.rs expects.</p>
<h2 id="how-to-export-a-users-stronghold"><a class="header" href="#how-to-export-a-users-stronghold">How to export a user's stronghold</a></h2>
<p>You can create a new Stronghold snapshot on the fly to allow a user to leave your service and retain their key.</p>
<h2 id="how-to-rekey-a-strongholdpassword-rotation"><a class="header" href="#how-to-rekey-a-strongholdpassword-rotation">How to rekey a Stronghold/password rotation</a></h2>
<p>The procedure for changing a Stronghold password is &quot;simple&quot; in that you read a snapshot into a vault and then write it out with a new encryption password. <a href="https://github.com/iotaledger/wallet.rs/blob/d1b8893d73aae35dfcf7c5c8006e2177988d25d0/src/stronghold.rs#L436-L451">See this code for the source.</a></p>
<p>Please note: for obvious reasons, old snapshot backups will not be &quot;rekeyed&quot;, so you have to track your old passwords. </p>
<h2 id="dos-and-donts"><a class="header" href="#dos-and-donts">Do's and don'ts</a></h2>
<ul>
<li>Don't use SQLite</li>
<li>Don't store passwords and backups on the same device</li>
</ul>
<h1 id="testnet"><a class="header" href="#testnet">Testnet</a></h1>
<p>IOTA 1.5 (also known as Chrysalis) is IOTA's intermediate stage before Coordicide is complete. You can read more about the strategy for releasing Chrysalis <a href="https://blog.iota.org/release-strategy-for-chrysalis-iota-1-5-4ea8741ea3a1/">here</a>.</p>
<h2 id="infrastructure-1"><a class="header" href="#infrastructure-1">Infrastructure</a></h2>
<p>Nodes deployed to the testnet can be queried using a load balancer at:</p>
<ul>
<li>api.lb-0.testnet.chrysalis2.com</li>
</ul>
<p>We recommend using the load balancer for most scenarios.</p>
<p>Single node endpoints that expose native MQTT, in case you need them, are:</p>
<ul>
<li>api.hornet-0.testnet.chrysalis2.com</li>
<li>api.hornet-1.testnet.chrysalis2.com</li>
<li>api.hornet-2.testnet.chrysalis2.com</li>
<li>api.hornet-3.testnet.chrysalis2.com</li>
</ul>
<p>The Node API is integrated according to the <a href="https://editor.swagger.io/?url=https://raw.githubusercontent.com/rufsam/protocol-rfcs/master/text/0026-rest-api/rest-api.yaml">following specification</a>.</p>
<h2 id="developer-tools-1"><a class="header" href="#developer-tools-1">Developer tools</a></h2>
<ul>
<li><a href="https://explorer.iota.org/chrysalis">Explorer</a></li>
<li><a href="https://faucet.testnet.chrysalis2.com/">Online Faucet</a></li>
<li><a href="https://github.com/iotaledger/cli-wallet">cli-wallet</a></li>
<li><a href="https://github.com/iotaledger/chrysalis-faucet">chrysalis-faucet Code (nodejs + svelte)</a></li>
</ul>
<h1 id="iota-protocol-rfcs"><a class="header" href="#iota-protocol-rfcs">IOTA Protocol RFCs</a></h1>
<p>Changes to the IOTA protocol have to go through a proposal process first, where a proposal is posted as a &quot;Request for comment&quot; (RFC). The Chrysalis protocol changes are described in full detail in these RFC's which can be found below:</p>
<ul>
<li><a href="https://github.com/iotaledger/protocol-rfcs/pulls">Git Repo</a></li>
</ul>
<h1 id="resources"><a class="header" href="#resources">Resources</a></h1>
<h3 id="official-support"><a class="header" href="#official-support"><strong>Official support</strong></a></h3>
<hr />
<h4 id="iota-explorer"><a class="header" href="#iota-explorer"><strong>IOTA Explorer</strong></a></h4>
<p><a href="https://explorer.iota.org/chrysalis">Link</a></p>
<p>Official Tangle explorer with a lot of tools to browse through the Tangle.</p>
<hr />
<h4 id="discord"><a class="header" href="#discord"><strong>Discord</strong></a></h4>
<p><a href="https://discord.iota.org">Link</a></p>
<p>The official Discord server where community members and the IOTA Foundation discuss projects and related subjects.</p>
<hr />
<h4 id="iota-stackexchange"><a class="header" href="#iota-stackexchange"><strong>IOTA StackExchange</strong></a></h4>
<p><a href="https://iota.stackexchange.com">Link</a></p>
<p>The official forum where you can ask or answer technical questions about IOTA.</p>
<hr />
<h3 id="community-support"><a class="header" href="#community-support"><strong>Community support</strong></a></h3>
<hr />
<h4 id="thetangleorg---iota-explorer"><a class="header" href="#thetangleorg---iota-explorer">TheTangle.org - IOTA Explorer</a></h4>
<p><a href="https://thetangle.org">Link</a></p>
<p>A community tool for searching transactions in the Tangle.</p>
<hr />
<h4 id="tangleexplorer---iota-explorer"><a class="header" href="#tangleexplorer---iota-explorer">TangleExplorer - IOTA Explorer</a></h4>
<p><a href="https://tanglexplorer.com/mainnet">Link</a></p>
<p>An community tool for searching transactions in the Tangle.</p>
<hr />
<h1 id="faq"><a class="header" href="#faq">FAQ</a></h1>
<h2 id="which-libraries-are-available-for-chrysalis"><a class="header" href="#which-libraries-are-available-for-chrysalis">Which libraries are available for Chrysalis?</a></h2>
<p>At this time, there are a handful of libraries available for Chrysalis which are outlined below:</p>
<p>A low level library called iota.rs which is a client library meant to connect to a IOTA node for core interactions with the Tangle. It is written in Rust and there are currently two bindings for Node.js and Python allowing you to use this library from those languages as well. </p>
<p>For value transactions, there is the wallet.rs library which provides a stateful way to manage IOTA coins for one or multiple accounts. It is also written in Rust and there are currently two bindings for Node.js and Python. </p>
<p>Additionally, there is also a native C (<a href="https://github.com/iotaledger/iota.c">iota.c</a>) and an alternative, native javascript (<a href="https://github.com/iotaledger/iota.js/tree/chrysalis">iota.js</a>) client library. </p>
<h2 id="what-is-dust-protection-and-how-does-it-work"><a class="header" href="#what-is-dust-protection-and-how-does-it-work">What is Dust protection and how does it work?</a></h2>
<p>Since IOTA is feeless and has the ability to send microtransactions, attackers could use this to spam the network with very low value transactions, which we call dust. To avoid this we only allow microtransaction below 1Mi of IOTA tokens to another address if you already have at least 1Mi on that address.</p>
<p>You can read more about Dust Protection <a href="https://github.com/iotaledger/protocol-rfcs/pull/32">in the RFC here</a>.</p>
<h2 id="whats-happening-with-coordicide"><a class="header" href="#whats-happening-with-coordicide">What's happening with Coordicide?</a></h2>
<p>This release called Chrysalis still depends on the Coordinator/Compass to run and issue milestones. The next big release after Chrysalis will be Coordicide where we get rid of that dependency. This release is currently in a research/testing phase and will be the main priority after the Chrysalis release.</p>
<h2 id="when-is-a-transaction-on-the-network-considered-finalirreversible"><a class="header" href="#when-is-a-transaction-on-the-network-considered-finalirreversible">When is a transaction on the network considered final/irreversible?</a></h2>
<p>Confirmation times on the new network are on average around 10 seconds. Once a transaction is set to confirm it’s final transaction, you don’t have block confirmations like with blockchain.</p>
<h2 id="hornet-or-bee-which-node-software-should-i-use"><a class="header" href="#hornet-or-bee-which-node-software-should-i-use">Hornet or Bee? Which node software should I use?</a></h2>
<p>You can pick either Bee (Rust based) or Hornet (Go based). We currently recommend Hornet since it’s the more complete version of the node software, Bee is still missing some optional features you might wish to use.</p>
<h1 id="libraries-1"><a class="header" href="#libraries-1">Libraries</a></h1>
<ul>
<li><a href="libraries/./client-lib/docs/welcome.html">client-lib</a></li>
</ul>
<h1 id="welcome-1"><a class="header" href="#welcome-1">Welcome</a></h1>
<p>This is the documentation for the official IOTA Client Library. It can be used to easily interact with IOTA network (Tangle) via <a href="https://chrysalis.docs.iota.org/node-software/node-software.html">IOTA node software</a>. Official IOTA libraries serve as <code>one-source-code-of-truth</code> to IOTA users and providing binding to other programming languages. You can read more about core principles behind IOTA client libraries in the following blog <a href="https://blog.iota.org/the-new-iota-client-libraries-harder-better-faster-stronger/">post</a>.</p>
<p>Example of tasks that <code>iota.rs</code> is able to help with:</p>
<ul>
<li>Create messages and transactions</li>
<li>Sign transactions</li>
<li>Generate addresses</li>
<li>Interact with an IOTA node</li>
</ul>
<blockquote>
<p>Please note: there is also available <code>wallet.rs</code> library that contains all the logic to safely build wallets or integrations that require value-based IOTA transfers. We strongly recommend to leverage <a href="https://wallet-lib.docs.iota.org/">wallet.rs library</a> in case one is more focused on IOTA value-based transfers since it integrates the best security practices including our <a href="https://blog.iota.org/iota-stronghold-6ce55d311d7c/">stronghold enclave</a>`.</p>
</blockquote>
<h2 id="iota-15-chrysalis-in-a-nutshell"><a class="header" href="#iota-15-chrysalis-in-a-nutshell">IOTA 1.5 (Chrysalis) in a nutshell</a></h2>
<ul>
<li>IOTA network uses a DAG (Directed Acyclic Graph) to store its transactions. Each transaction can reference up to 8 parent transactions</li>
<li>There is a breaking change moving from IOTA 1.0 to IOTA 1.5 (Chrysalis). IOTA address was originally based on WOTS signature scheme (81 trytes) and it has been replaced by a Ed25519 signature scheme</li>
<li>In contrast to IOTA 1.0, IOTA 1.5 addresses are perfectly reusable: so even if one spent funds from the given address it can be used again</li>
<li>There are new client libraries developed in rust, specifically <code>iota.rs</code>, <code>wallet.rs</code> and <code>stronghold.rs</code> that serve as <code>one-source-code-of-truth</code> to IOTA users and providing binding to other programming languages </li>
</ul>
<h3 id="iota-15-address-anatomy-1"><a class="header" href="#iota-15-address-anatomy-1">IOTA 1.5 address anatomy</a></h3>
<p>IOTA address is based on Ed25519 signature scheme and it is usually represented by Bech32 (checksummed base32) format string of 64 characters:</p>
<table>
    <thead>
        <tr>
            <th colspan=4><center>iota11qykf7rrdjzhgynfkw6z7360avhaaywf5a4vtyvvk6a06gcv5y7sksu7n5cs</center></th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan=4><center>three distinguished parts</center></td>
        </tr>
        <tr>
            <td><center><strong>human-readable id</strong></center></td>
            <td><center><strong>separator</strong></center></td>
            <td><center><strong>data</strong></center></td>
            <td><center><strong>checksum</strong></center></td>
        </tr>
        <tr>
            <td><center>iota | atoi</center></td>
            <td><center>1</center></td>
            <td><center>48 bytes [0..9a..z]</center></td>
            <td><center>6 characters [0..9a..z]</center></td>
        </tr>
        <tr>
            <td><center>iota</center></td>
            <td><center>1</center></td>
            <td><center>1qykf7rrdjzhgynfkw6z7360avhaaywf5a4vtyvvk6a06gcv5y7sks</center></td>
            <td><center>u7n5cs</center></td>
        </tr>
        <tr>
            <td colspan=4>iota = mainnet; atoi = testnet</td>
        </tr>
    </tbody>
</table>
<p>More details: <a href="https://github.com/iotaledger/protocol-rfcs/pull/20">RFC: Bech32 Address Format</a></p>
<h2 id="warning"><a class="header" href="#warning">Warning</a></h2>
<p>This library is in active development. The library targets the Chrysalis testnet and does not work with current IOTA mainnet.</p>
<h2 id="testnet-1"><a class="header" href="#testnet-1">Testnet</a></h2>
<p>To join the Chrysalis public testnet checkout <a href="https://blog.iota.org/chrysalis-phase-2-testnet-out-now/">this link</a>. More information about Chrysalis components is available at <a href="https://chrysalis.docs.iota.org/">documentation portal</a>.</p>
<h2 id="joining-the-discussion"><a class="header" href="#joining-the-discussion">Joining the discussion</a></h2>
<p>If you want to get involved in discussions about this library, or you're looking for support, go to the #clients-discussion channel on <a href="https://discord.iota.org">Discord</a>.</p>
<h2 id="what-you-will-find-here"><a class="header" href="#what-you-will-find-here">What you will find here</a></h2>
<p>This documentation has five paths. </p>
<ol>
<li>The Overview, an detailed overview of the client library. </li>
<li>Libraries bindings, all avaiable programming languages and their resources.</li>
<li>The Specification, detailed explaination requirements and functionality.</li>
<li>Contribute, how you can work on the client software.</li>
<li>Get in touch, join the community and become part of the X-Team!</li>
</ol>
<h1 id="overview"><a class="header" href="#overview">Overview</a></h1>
<p>The IOTA client library is a stateless library that provides a high level abstractions on top of IOTA node software to help interact with IOTA network in user friendly way and allows you to do the following, for instance:</p>
<ul>
<li>Create messages and transactions</li>
<li>Sign transactions</li>
<li>Generate addresses</li>
<li>Interact with an IOTA node</li>
</ul>
<h2 id="iota-client-library-in-a-nutshell"><a class="header" href="#iota-client-library-in-a-nutshell">IOTA client library in a nutshell</a></h2>
<p>The library provides two types of API calls under a common interface:</p>
<ul>
<li><code>Full node API calls</code>: those calls are basically translated to native node rest api calls. For more information, please see <a href="https://editor.swagger.io/?url=https://raw.githubusercontent.com/rufsam/protocol-rfcs/master/text/0026-rest-api/rest-api.yaml">node rest API reference</a></li>
<li><code>General high level API calls</code>: those are convenience functions with some typical default parameters in order to use them in a straightforward manner. They typically implement several recommended steps for the given task. Implementation details are part of the full specification</li>
</ul>
<p>See the full specification <a href="libraries/client-lib/docs/overview/../specs/">here</a>.</p>
<h2 id="high-level-layered-overview"><a class="header" href="#high-level-layered-overview">High level layered overview:</a></h2>
<p><img src="libraries/client-lib/docs/overview/layered_overview.svg" alt="iota layers overview" /></p>
<h1 id="iota-client-libraries"><a class="header" href="#iota-client-libraries">IOTA Client libraries</a></h1>
<p>There are currently available the following official bindings to <code>iota.rs</code>:</p>
<ul>
<li><a href="libraries/client-lib/docs/libraries/./rust/">Rust</a> </li>
<li><a href="libraries/client-lib/docs/libraries/./nodejs/">Node.js</a> </li>
<li><a href="libraries/client-lib/docs/libraries/./python/">Python</a> </li>
</ul>
<h2 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h2>
<p>It is a recommended approach to start your interactions with IOTA on a <code>testnet</code> network. API load balancer: https://api.lb-0.testnet.chrysalis2.com:443</p>
<p>Network explorer is available at <a href="https://explorer.iota.org/chrysalis">IOTA Tangle Explorer</a>.</p>
<p>In order to properly test value-based transactions on testnet network, you are going to need some tokens! You can get some testnet tokens using the <a href="https://faucet.testnet.chrysalis2.com/">faucet</a>. However, we strongly recommend to leverage official <a href="https://wallet-lib.docs.iota.org/">wallet.rs</a> library in case of value-based IOTA transfers.</p>
<h1 id="iota-client-rust-library"><a class="header" href="#iota-client-rust-library">IOTA Client Rust Library</a></h1>
<p><a href="https://github.com/iotaledger/iota.rs"><img src="https://img.shields.io/badge/Status-Alpha-yellow.svg" alt="status" /></a></p>
<h2 id="warning-1"><a class="header" href="#warning-1">Warning</a></h2>
<p>This library is in active development. The library targets the Chrysalis testnet and does not work with current IOTA mainnet.</p>
<h2 id="joining-the-discussion-1"><a class="header" href="#joining-the-discussion-1">Joining the discussion</a></h2>
<p>If you want to get involved in discussions about this library, or you're looking for support, go to the #clients-discussion channel on <a href="https://discord.iota.org">Discord</a>.</p>
<h2 id="overview-1"><a class="header" href="#overview-1">Overview</a></h2>
<ul>
<li><a href="libraries/client-lib/docs/libraries/rust/">Getting Started with iota.rs</a></li>
<li><a href="libraries/client-lib/docs/libraries/rust/">Examples</a></li>
<li><a href="libraries/client-lib/docs/libraries/rust/">API Reference</a></li>
<li><a href="libraries/client-lib/docs/libraries/rust/">Troubleshooting</a></li>
</ul>
<h1 id="getting-started-with-rust"><a class="header" href="#getting-started-with-rust">Getting Started with Rust</a></h1>
<h2 id="requirements"><a class="header" href="#requirements">Requirements</a></h2>
<p>To use the library, we recommend you update Rust to latest stable version <a href="https://github.com/rust-lang/rustup.rs#keeping-rust-up-to-date"><code>$ rustup update stable</code></a>. Nightly should be fine but some changes might not be compatible.</p>
<p><code>no_std</code> is not currently supported, but we are working on it in <a href="https://github.com/iotaledger/bee">bee</a>, and will provide it as feature once the new implementation is ready.</p>
<h2 id="using-the-library"><a class="header" href="#using-the-library">Using the library</a></h2>
<p>Using the library is easy, just add it as dependency in your <code>Cargo.toml</code>:</p>
<pre><code class="language-bash">[dependencies]
iota-core = { git = &quot;https://github.com/iotaledger/iota.rs&quot;, branch = &quot;dev&quot; }
</code></pre>
<p>And then you can use the library in your code with <code>use iota;</code>.</p>
<h3 id="initialisation"><a class="header" href="#initialisation">Initialisation</a></h3>
<p>This example fetches node information</p>
<pre><pre class="playground"><code class="language-rust">use iota::Client;

#[tokio::main]
async fn main() {
    let iota = Client::builder() // Crate a client instance builder
        .with_node(&quot;https://api.lb-0.testnet.chrysalis2.com&quot;)
        .unwrap()
        .finish()
        .await
        .unwrap();

    let info = iota.get_info().await.unwrap();
    println!(&quot;Nodeinfo: {:?}&quot;, info);
}
</code></pre></pre>
<h1 id="examples"><a class="header" href="#examples">Examples</a></h1>
<p>You can see the examples in the <a href="https://github.com/iotaledger/iota.rs/tree/dev/examples">examples</a> directory and try them with:</p>
<pre><code class="language-bash">cargo run --example # lists the available examples
cargo run --example address # execute the `address` example
</code></pre>
<h1 id="api-reference"><a class="header" href="#api-reference">API Reference</a></h1>
<p>API reference</p>
<p>You can read the <a href="https://client-lib.docs.iota.org/docs/iota_client/">API reference</a> here, or generate it yourself.</p>
<p>If you'd like to explore the implementation in more depth, the following command generates docs for the whole crate, including private modules:</p>
<pre><code class="language-bash">cargo doc --document-private-items --no-deps --open
</code></pre>
<h1 id="troubleshooting"><a class="header" href="#troubleshooting">Troubleshooting</a></h1>
<h2 id="stackexchange"><a class="header" href="#stackexchange">StackExchange</a></h2>
<blockquote>
<p><a href="https://iota.stackexchange.com/">https://iota.stackexchange.com</a></p>
</blockquote>
<p>The IOTA StackExchange a a nice tool for developers to find answers for a problem. Just search your problem and find your answer! If there is no one, submit your question and share it in the discussion channel below.</p>
<h2 id="joining-the-discussion-2"><a class="header" href="#joining-the-discussion-2">Joining the discussion</a></h2>
<p>If you want to get involved in discussions about this library, or you're looking for support, go to the #clients-discussion channel on <a href="https://discord.iota.org">Discord</a>.</p>
<h1 id="iota-client-nodejs-library"><a class="header" href="#iota-client-nodejs-library">IOTA Client Node.js Library</a></h1>
<p><a href="https://github.com/iotaledger/iota.rs"><img src="https://img.shields.io/badge/Status-Alpha-yellow.svg" alt="status" /></a></p>
<h2 id="warning-2"><a class="header" href="#warning-2">Warning</a></h2>
<p>This library is in active development. The library targets the Chrysalis testnet and does not work with current IOTA mainnet.</p>
<h2 id="joining-the-discussion-3"><a class="header" href="#joining-the-discussion-3">Joining the discussion</a></h2>
<p>If you want to get involved in discussions about this library, or you're looking for support, go to the #clients-discussion channel on <a href="https://discord.iota.org">Discord</a>.</p>
<h2 id="overview-2"><a class="header" href="#overview-2">Overview</a></h2>
<ul>
<li><a href="libraries/client-lib/docs/libraries/nodejs/">Getting Started</a></li>
<li><a href="libraries/client-lib/docs/libraries/nodejs/">Examples</a></li>
<li><a href="libraries/client-lib/docs/libraries/nodejs/">API Reference</a></li>
<li><a href="libraries/client-lib/docs/libraries/nodejs/">Troubleshooting</a></li>
</ul>
<h1 id="getting-started-with-nodejs"><a class="header" href="#getting-started-with-nodejs">Getting Started with Node.js</a></h1>
<h2 id="installation"><a class="header" href="#installation">Installation</a></h2>
<ul>
<li>Using NPM:</li>
</ul>
<pre><code>$ npm i @iota/client
</code></pre>
<ul>
<li>Using yarn:</li>
</ul>
<pre><code>$ yarn add @iota/client
</code></pre>
<h2 id="example"><a class="header" href="#example">Example</a></h2>
<pre><code class="language-javascript">const { ClientBuilder } = require('@iota/client')
const client = new ClientBuilder()
    .node('https://api.lb-0.testnet.chrysalis2.com')
    .build()
client.getInfo().then(console.log).catch(console.error)
</code></pre>
<h1 id="examples-1"><a class="header" href="#examples-1">Examples</a></h1>
<p>You can look into <a href="https://github.com/iotaledger/iota.rs/blob/dev/bindings/nodejs/tests/client.js">the tests</a> until the full documentation is available.</p>
<h1 id="api-reference-1"><a class="header" href="#api-reference-1">API Reference</a></h1>
<p>Connecting to a MQTT broker using raw ip doesn't work. This is a limitation of rustls.</p>
<h2 id="api-reference-2"><a class="header" href="#api-reference-2">API Reference</a></h2>
<h3 id="clientbuilder"><a class="header" href="#clientbuilder">ClientBuilder</a></h3>
<h4 id="nodeurl-clientbuilder"><a class="header" href="#nodeurl-clientbuilder">node(url): ClientBuilder</a></h4>
<p>Adds an IOTA node to the client pool.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>url</td><td><code>string</code></td><td>A node URL</td></tr>
</tbody></table>
<p><strong>Returns</strong> the client builder instance for chained calls.</p>
<h4 id="nodeauthurl-name-password-clientbuilder"><a class="header" href="#nodeauthurl-name-password-clientbuilder">nodeAuth(url, name, password): ClientBuilder</a></h4>
<p>Adds an IOTA node with basic authentication to the client pool.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>url</td><td><code>string</code></td><td>A node URL</td></tr>
<tr><td>name</td><td><code>string</code></td><td>A name</td></tr>
<tr><td>password</td><td><code>string</code></td><td>A password</td></tr>
</tbody></table>
<p><strong>Returns</strong> the client builder instance for chained calls.</p>
<h4 id="nodesurls-clientbuilder"><a class="header" href="#nodesurls-clientbuilder">nodes(urls): ClientBuilder</a></h4>
<p>Adds a list of IOTA nodes to the client pool.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>url</td><td><code>string[]</code></td><td>An array of node URLs</td></tr>
</tbody></table>
<p><strong>Returns</strong> the client builder instance for chained calls.</p>
<h4 id="nodepoolurlsurls-clientbuilder"><a class="header" href="#nodepoolurlsurls-clientbuilder">nodePoolUrls(urls): ClientBuilder</a></h4>
<p>Adds a list of IOTA nodes from node pool URLs to the client pool.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>url</td><td><code>string[]</code></td><td>An array of node pool URLs</td></tr>
</tbody></table>
<p><strong>Returns</strong> the client builder instance for chained calls.</p>
<h4 id="networknetworkname-clientbuilder"><a class="header" href="#networknetworkname-clientbuilder">network(networkName): ClientBuilder</a></h4>
<p>Set a network to get default nodes for it. Can be &quot;testnet&quot; or &quot;mainnet&quot;.
Nodes that don't belong to this network are ignored.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>networkName</td><td><code>string</code></td><td>The network</td></tr>
</tbody></table>
<p><strong>Returns</strong> the client builder instance for chained calls.</p>
<h4 id="quorumsizesize-clientbuilder"><a class="header" href="#quorumsizesize-clientbuilder">quorumSize(size): ClientBuilder</a></h4>
<p>Defines how many of nodes will be queried at the same time to check for quorum.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>size</td><td><code>number</code></td><td>The number of nodes that will be queried</td></tr>
</tbody></table>
<p><strong>Returns</strong> the client builder instance for chained calls.</p>
<h4 id="quorumthresholdthreshold-clientbuilder"><a class="header" href="#quorumthresholdthreshold-clientbuilder">quorumThreshold(threshold): ClientBuilder</a></h4>
<p>Defines the minimum amount of nodes from the quorum pool that need to agree if we want to consider the result true.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>threshold</td><td><code>number</code></td><td>Minimum amount of nodes</td></tr>
</tbody></table>
<p><strong>Returns</strong> the client builder instance for chained calls.</p>
<h4 id="brokeroptionsoptions-clientbuilder"><a class="header" href="#brokeroptionsoptions-clientbuilder">brokerOptions(options): ClientBuilder</a></h4>
<p>Sets the options for the MQTT connection with the node.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>options</td><td><code><a href="libraries/client-lib/docs/libraries/nodejs/api_reference.html#brokeroptions">BrokerOptions</a></code></td><td>The MQTT broker options</td></tr>
</tbody></table>
<p><strong>Returns</strong> the client builder instance for chained calls.</p>
<h4 id="nodesyncintervalinterval-clientbuilder"><a class="header" href="#nodesyncintervalinterval-clientbuilder">nodeSyncInterval(interval): ClientBuilder</a></h4>
<p>Sets the node syncing interval.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>interval</td><td><code>number</code></td><td>The interval for the node syncing process</td></tr>
</tbody></table>
<p><strong>Returns</strong> the client builder instance for chained calls.</p>
<h4 id="disablenodesync-clientbuilder"><a class="header" href="#disablenodesync-clientbuilder">disableNodeSync(): ClientBuilder</a></h4>
<p>Disables the node syncing process. Every node will be considered healthy and ready to use.</p>
<p><strong>Returns</strong> the client builder instance for chained calls.</p>
<h4 id="defaulttimeouttimeoutms-clientbuilder"><a class="header" href="#defaulttimeouttimeoutms-clientbuilder">defaultTimeout(timeoutMs): ClientBuilder</a></h4>
<p>Sets the default HTTP request timeout.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>timeout</td><td><code>number</code></td><td>The timeout in milliseconds</td></tr>
</tbody></table>
<p><strong>Returns</strong> the client builder instance for chained calls.</p>
<h4 id="apitimeoutapi-timeoutms-clientbuilder"><a class="header" href="#apitimeoutapi-timeoutms-clientbuilder">apiTimeout(api, timeoutMs): ClientBuilder</a></h4>
<p>Sets the HTTP request timeout for the specified API.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>api</td><td><code>'GetHealth' | 'GetInfo' | 'GetTips' | 'PostMessage' | 'GetOutput' | 'GetMilestone'</code></td><td>The API to set the request timeout</td></tr>
<tr><td>timeout</td><td><code>number</code></td><td>The timeout in milliseconds</td></tr>
</tbody></table>
<p><strong>Returns</strong> the client builder instance for chained calls.</p>
<h4 id="localpowlocal-clientbuilder"><a class="header" href="#localpowlocal-clientbuilder">localPow(local): ClientBuilder</a></h4>
<p>Sets the PoW type.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>local</td><td><code>boolean</code></td><td>Flag determining if PoW should be done locally or remotely</td></tr>
</tbody></table>
<p><strong>Returns</strong> the client builder instance for chained calls.</p>
<h4 id="build-client"><a class="header" href="#build-client">build(): Client</a></h4>
<p>Builds the client instance.</p>
<p><strong>Returns</strong> a <a href="libraries/client-lib/docs/libraries/nodejs/api_reference.html#client">Client</a> instance.</p>
<h3 id="client"><a class="header" href="#client">Client</a></h3>
<h4 id="networkinfo-networkinfo"><a class="header" href="#networkinfo-networkinfo">networkInfo(): NetworkInfo</a></h4>
<p>Gets the cached network info.</p>
<p><strong>Returns</strong> a <a href="libraries/client-lib/docs/libraries/nodejs/api_reference.html#networkinfo">NetworkInfo</a> instance.</p>
<h4 id="subscriber-topicsubscriber"><a class="header" href="#subscriber-topicsubscriber">subscriber(): TopicSubscriber</a></h4>
<p>Gets a handle to the MQTT topic subscriber.</p>
<p><strong>Returns</strong> a <a href="libraries/client-lib/docs/libraries/nodejs/api_reference.html#topicsubscriber">TopicSubscriber</a> instance.</p>
<h4 id="message-messagesender"><a class="header" href="#message-messagesender">message(): MessageSender</a></h4>
<p>Initiates the builder to send messages.</p>
<p><strong>Returns</strong> a <a href="libraries/client-lib/docs/libraries/nodejs/api_reference.html#messagesender">MessageSender</a> instance.</p>
<h4 id="getunspentaddressseed-unspentaddressgetter"><a class="header" href="#getunspentaddressseed-unspentaddressgetter">getUnspentAddress(seed): UnspentAddressGetter</a></h4>
<p>Get a valid unspent address.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>seed</td><td><code>string</code></td><td>The hex-encoded seed to search</td></tr>
</tbody></table>
<p><strong>Returns</strong> a <a href="libraries/client-lib/docs/libraries/nodejs/api_reference.html#unspentaddressgetter">UnspentAddressGetter</a> instance.</p>
<h4 id="getaddressesseed-addressgetter"><a class="header" href="#getaddressesseed-addressgetter">getAddresses(seed): AddressGetter</a></h4>
<p>Find addresses from the seed regardless of their validity.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>seed</td><td><code>string</code></td><td>The hex-encoded seed to search</td></tr>
</tbody></table>
<p><strong>Returns</strong> a <a href="libraries/client-lib/docs/libraries/nodejs/api_reference.html#addressgetter">AddressGetter</a> instance.</p>
<h4 id="findmessagesindexationkeys-messageids-promisemessage"><a class="header" href="#findmessagesindexationkeys-messageids-promisemessage">findMessages(indexationKeys, messageIds): Promise&lt;Message[]&gt;</a></h4>
<p>Finds all messages associated with the given indexation keys and message ids.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>indexationKeys</td><td><code>string[]</code></td><td>The list of indexations keys too search</td></tr>
<tr><td>messageIds</td><td><code>string[]</code></td><td>The list of message ids to search</td></tr>
</tbody></table>
<p><strong>Returns</strong> a promise resolving to the list of the found messages.</p>
<h4 id="getbalanceseed-string-balancegetter"><a class="header" href="#getbalanceseed-string-balancegetter">getBalance(seed: string): BalanceGetter</a></h4>
<p>Get balance on a given seed and its wallet account index.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>seed</td><td><code>string</code></td><td>The hex-encoded seed to search</td></tr>
</tbody></table>
<p><strong>Returns</strong> a <a href="libraries/client-lib/docs/libraries/nodejs/api_reference.html#balancegetter">BalanceGetter</a> instance.</p>
<h4 id="getaddressbalancesaddresses-promiseaddressbalance"><a class="header" href="#getaddressbalancesaddresses-promiseaddressbalance">getAddressBalances(addresses): Promise&lt;AddressBalance[]&gt;</a></h4>
<p>Get the balance in iotas for the given addresses.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>addresses</td><td><code>string[]</code></td><td>The list of addresses to search</td></tr>
</tbody></table>
<p><strong>Returns</strong> A promise resolving to the list of <code>{ address, balance }</code> pairs.</p>
<h4 id="bech32tohexbech32"><a class="header" href="#bech32tohexbech32">bech32ToHex(bech32)</a></h4>
<p>Returns a parsed hex String from bech32.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>bech32</td><td><code>string</code></td><td>The address Bech32 string</td></tr>
</tbody></table>
<p><strong>Returns</strong> A String</p>
<h4 id="hextobech32hex-bech32_hrp-optional"><a class="header" href="#hextobech32hex-bech32_hrp-optional">hexToBech32(hex, bech32_hrp (optional))</a></h4>
<p>Returns a parsed bech32 String from hex.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>bech32</td><td><code>string</code></td><td>The address Bech32 string</td></tr>
<tr><td>bech32_hrp</td><td><code>string</code></td><td>The Bech32 hrp string</td></tr>
</tbody></table>
<p><strong>Returns</strong> A String</p>
<h4 id="isaddressvalidaddress-string-boolean"><a class="header" href="#isaddressvalidaddress-string-boolean">isAddressValid(address: string): boolean</a></h4>
<p>Checks if a given address is valid.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>address</td><td><code>string</code></td><td>The address Bech32 string</td></tr>
</tbody></table>
<p><strong>Returns</strong> A boolean.</p>
<h4 id="retrymessageid-string-promisemessage"><a class="header" href="#retrymessageid-string-promisemessage">retry(messageId: string): Promise<Message></a></h4>
<p>Retries (promotes or reattaches) the message associated with the given id.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>messageId</td><td><code>string</code></td><td>The id of the message to retry</td></tr>
</tbody></table>
<p><strong>Returns</strong> A promise resolving to the new <a href="libraries/client-lib/docs/libraries/nodejs/api_reference.html#message">Message</a> instance.</p>
<h4 id="retryuntilincludedmessageid-string-interval-int-max_attempts-int-promisemessage"><a class="header" href="#retryuntilincludedmessageid-string-interval-int-max_attempts-int-promisemessage">retryUntilIncluded(messageId: string[, interval: int, max_attempts: int]): Promise<Message></a></h4>
<p>Retries (promotes or reattaches) the message associated with the given id until it's included in the Tangle.
Default interval is 5 seconds and max_attempts is 10.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>messageId</td><td><code>string</code></td><td>The id of the message to retry</td></tr>
<tr><td>[options.interval]</td><td><code>int</code></td><td>The interval in seconds in which we retry the message.</td></tr>
<tr><td>[options.max_attempts]</td><td><code>int</code></td><td>The maximum of attempts we retry the message.</td></tr>
</tbody></table>
<p><strong>Returns</strong> the message ids and <a href="libraries/client-lib/docs/libraries/nodejs/api_reference.html#message">Message</a> of reattached messages.</p>
<h4 id="getinfo-promisenodeinfo"><a class="header" href="#getinfo-promisenodeinfo">getInfo(): Promise<NodeInfo></a></h4>
<p>Gets information about the node.</p>
<p><strong>Returns</strong> a promise resolving to the <a href="libraries/client-lib/docs/libraries/nodejs/api_reference.html#nodeinfo">NodeInfo</a> object.</p>
<h4 id="gettips-promisestring-string"><a class="header" href="#gettips-promisestring-string">getTips(): Promise&lt;[string, string]&gt;</a></h4>
<p>Gets two non-lazy tips.</p>
<p><strong>Returns</strong> a promise resolving to an array of length 2 containing the message ids of the tips.</p>
<h4 id="postmessagemessage-promisestring"><a class="header" href="#postmessagemessage-promisestring">postMessage(message): Promise<string></a></h4>
<p>Submits a message.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>message</td><td><code><a href="libraries/client-lib/docs/libraries/nodejs/api_reference.html#messagedto">MessageDto</a></code></td><td>The message to submit</td></tr>
</tbody></table>
<p><strong>Returns</strong> the message identifier.</p>
<h4 id="getmessage-messagefinder"><a class="header" href="#getmessage-messagefinder">getMessage(): MessageFinder</a></h4>
<p>Gets a message from its identifier.</p>
<p><strong>Returns</strong> an instance of the <a href="libraries/client-lib/docs/libraries/nodejs/api_reference.html#messagefinder">MessageFinder</a> for choices of response.</p>
<h4 id="getoutputoutputid-promiseoutputmetadata"><a class="header" href="#getoutputoutputid-promiseoutputmetadata">getOutput(outputId): Promise<OutputMetadata></a></h4>
<p>Gets the UTXO outputs associated with the given output id.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>outputId</td><td><code>string</code></td><td>The id of the output to search</td></tr>
</tbody></table>
<p><strong>Returns</strong> a promise resolving to the associated <a href="libraries/client-lib/docs/libraries/nodejs/api_reference.html#outputmetadata">OutputMetadata</a>.</p>
<h4 id="findoutputsoutputids-addresses-promiseoutputmetadata"><a class="header" href="#findoutputsoutputids-addresses-promiseoutputmetadata">findOutputs(outputIds, addresses): Promise&lt;OutputMetadata[]&gt;</a></h4>
<p>Gets the UTXO outputs associated with the given output ids and addresses.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>addresses</td><td><code>string[]</code></td><td>The list of addresses to search</td></tr>
<tr><td>outputIds</td><td><code>string[]</code></td><td>The list of output ids to search</td></tr>
</tbody></table>
<p><strong>Returns</strong> a promise resolving to a list of <a href="libraries/client-lib/docs/libraries/nodejs/api_reference.html#outputmetadata">OutputMetadata</a>.</p>
<h4 id="getaddressoutputsaddress-options-promisestring"><a class="header" href="#getaddressoutputsaddress-options-promisestring">getAddressOutputs(address[, options]): Promise&lt;string[]&gt;</a></h4>
<p>Gets the UTXO outputs associated with the given address.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>address</td><td><code>string</code></td><td>The address Bech32 string</td></tr>
<tr><td>[options.includeSpent]</td><td><code>boolean</code></td><td>Whether the query should include spent outputs or not</td></tr>
<tr><td>[options.outputType]</td><td><code>'SignatureLockedSingle' | 'SignatureLockedDustAllowance'</code></td><td>The output type filter</td></tr>
</tbody></table>
<p><strong>Returns</strong> a promise resolving to a list of output ids.</p>
<h4 id="getaddressbalanceaddress-promisenumber"><a class="header" href="#getaddressbalanceaddress-promisenumber">getAddressBalance(address): Promise<number></a></h4>
<p>Gets the balance of the given address.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>address</td><td><code>string</code></td><td>The address Bech32 string</td></tr>
</tbody></table>
<h4 id="getmilestoneindex-promisemilestonemetadata"><a class="header" href="#getmilestoneindex-promisemilestonemetadata">getMilestone(index): Promise<MilestoneMetadata></a></h4>
<p>Gets the milestone by the given index.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>index</td><td><code>number</code></td><td>The index of the milestone</td></tr>
</tbody></table>
<p><strong>Returns</strong> a promise resolving to the <a href="libraries/client-lib/docs/libraries/nodejs/api_reference.html#milestonemetadata">MilestoneMetadata</a>.</p>
<h4 id="getmilestoneutxochangesindex-promisemilestoneutxochanges"><a class="header" href="#getmilestoneutxochangesindex-promisemilestoneutxochanges">getMilestoneUtxoChanges(index): Promise<MilestoneUTXOChanges></a></h4>
<p>Gets the utxo changes by the given milestone index.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>index</td><td><code>number</code></td><td>The index of the milestone</td></tr>
</tbody></table>
<p><strong>Returns</strong> a promise resolving to the <a href="libraries/client-lib/docs/libraries/nodejs/api_reference.html#MilestoneUTXOChanges">MilestoneUTXOChanges</a>.</p>
<h4 id="getreceipts-promisereceipts"><a class="header" href="#getreceipts-promisereceipts">getReceipts(): Promise&lt;Receipts[]&gt;</a></h4>
<p>Get all receipts.</p>
<p><strong>Returns</strong> a promise resolving to the <a href="libraries/client-lib/docs/libraries/nodejs/api_reference.html#Receipts">Receipts</a>.</p>
<h4 id="getreceiptsmigratedatindex-promisereceipts"><a class="header" href="#getreceiptsmigratedatindex-promisereceipts">getReceiptsMigratedAt(index): Promise&lt;Receipts[]&gt;</a></h4>
<p>Get all receipts for a given milestone index</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>index</td><td><code>number</code></td><td>The index of the milestone</td></tr>
</tbody></table>
<p><strong>Returns</strong> a promise resolving to the <a href="libraries/client-lib/docs/libraries/nodejs/api_reference.html#Receipts">Receipts</a>.</p>
<h4 id="gettreasury-promisetreasury"><a class="header" href="#gettreasury-promisetreasury">getTreasury(): Promise<Treasury></a></h4>
<p>Get the treasury amount.</p>
<p><strong>Returns</strong> a promise resolving to the <a href="libraries/client-lib/docs/libraries/nodejs/api_reference.html#Treasury">Treasury</a>.</p>
<h4 id="getincludedmessage-promisemessage"><a class="header" href="#getincludedmessage-promisemessage">getIncludedMessage(): Promise<Message></a></h4>
<p>Get the included message of a transaction.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>index</td><td><code>string</code></td><td>The id of the transaction</td></tr>
</tbody></table>
<p><strong>Returns</strong> A promise resolving to the new <a href="libraries/client-lib/docs/libraries/nodejs/api_reference.html#message">Message</a> instance.</p>
<h4 id="reattachmessageid-promisemessage"><a class="header" href="#reattachmessageid-promisemessage">reattach(messageId): Promise<Message></a></h4>
<p>Reattaches the message associated with the given id.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>messageId</td><td><code>string</code></td><td>The id of the message to reattach</td></tr>
</tbody></table>
<p><strong>Returns</strong> A promise resolving to the new <a href="libraries/client-lib/docs/libraries/nodejs/api_reference.html#message">Message</a> instance.</p>
<h4 id="promotemessageid-promisemessage"><a class="header" href="#promotemessageid-promisemessage">promote(messageId): Promise<Message></a></h4>
<p>Promotes the message associated with the given id.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>messageId</td><td><code>string</code></td><td>The id of the message to promote</td></tr>
</tbody></table>
<p><strong>Returns</strong> A promise resolving to the new <a href="libraries/client-lib/docs/libraries/nodejs/api_reference.html#message">Message</a> instance.</p>
<h3 id="networkinfo"><a class="header" href="#networkinfo">NetworkInfo</a></h3>
<table><thead><tr><th>Field</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>network</td><td><code>string</code></td><td>The network</td></tr>
<tr><td>networkId</td><td><code>number</code></td><td>The network hashed</td></tr>
<tr><td>bech32HRP</td><td><code>string</code></td><td>Bech32 HRP for this network</td></tr>
<tr><td>minPowScore</td><td><code>number</code></td><td>The network's minimum score for PoW</td></tr>
<tr><td>localPow</td><td><code>boolean</code></td><td>Whether we are using local PoW or not</td></tr>
</tbody></table>
<h3 id="topicsubscriber"><a class="header" href="#topicsubscriber">TopicSubscriber</a></h3>
<h4 id="topictopic-topicsubscriber"><a class="header" href="#topictopic-topicsubscriber">topic(topic): TopicSubscriber</a></h4>
<p>Adds a topic to this manager instance.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>topic</td><td><code>string</code></td><td>A MQTT topic</td></tr>
</tbody></table>
<p><strong>Returns</strong> the topic subscriber instance for chained calls.</p>
<h4 id="topicstopic-topicsubscriber"><a class="header" href="#topicstopic-topicsubscriber">topics(topic): TopicSubscriber</a></h4>
<p>Adds a list of topics to this manager instance.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>topics</td><td><code>string[]</code></td><td>An array of MQTT topics</td></tr>
</tbody></table>
<p><strong>Returns</strong> the topic subscriber instance for chained calls.</p>
<h4 id="subscribecb-topicsubscriber"><a class="header" href="#subscribecb-topicsubscriber">subscribe(cb): TopicSubscriber</a></h4>
<p>Subscribe to the provided topics.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>cb</td><td><code>function</code></td><td>The topic handler callback in the form of <code>(err, message) =&gt; {}</code></td></tr>
</tbody></table>
<p><strong>Returns</strong> the topic subscriber instance for chained calls.</p>
<h4 id="unsubscribecb-callback-topicsubscriber"><a class="header" href="#unsubscribecb-callback-topicsubscriber">unsubscribe(cb: Callback): TopicSubscriber</a></h4>
<p>Unsubscribes from the provided topics.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>cb</td><td><code>function</code></td><td>A callback executed when the unsubscribe is finished in the form of <code>(err, message) =&gt; {}</code></td></tr>
</tbody></table>
<p><strong>Returns</strong> the topic subscriber instance for chained calls.</p>
<h3 id="messagesender"><a class="header" href="#messagesender">MessageSender</a></h3>
<p>Builder to create and submit messages to the Tangle.</p>
<h4 id="indexindex-messagesender"><a class="header" href="#indexindex-messagesender">index(index): MessageSender</a></h4>
<p>Sets the message indexation. This field is required for indexation payloads.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>index</td><td><code>string</code></td><td>The indexation</td></tr>
</tbody></table>
<p><strong>Returns</strong> the message submit instance for chained calls.</p>
<h4 id="seedseed-messagesender"><a class="header" href="#seedseed-messagesender">seed(seed): MessageSender</a></h4>
<p>Sets the transaction account seed. This field is required for transaction payloads.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>seed</td><td><code>string</code></td><td>The hex-encoded seed of the account to spend</td></tr>
</tbody></table>
<p><strong>Returns</strong> the message submit instance for chained calls.</p>
<h4 id="datadata-messagesender"><a class="header" href="#datadata-messagesender">data(data): MessageSender</a></h4>
<p>Sets the indexation data.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>data</td><td><code>Uint8Array</code></td><td>The message's data</td></tr>
</tbody></table>
<p><strong>Returns</strong> the message submit instance for chained calls.</p>
<h4 id="parentsmessageid-messagesender"><a class="header" href="#parentsmessageid-messagesender">parents(messageId): MessageSender</a></h4>
<p>Sets 1-8 custom parent message ids.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>messageId</td><td><code>string[]</code></td><td>The parents message ids</td></tr>
</tbody></table>
<p><strong>Returns</strong> the message submit instance for chained calls.</p>
<h4 id="accountindexindex-messagesender"><a class="header" href="#accountindexindex-messagesender">accountIndex(index): MessageSender</a></h4>
<p>Sets the account index. This field is required for transactions.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>index</td><td><code>number</code></td><td>The account index</td></tr>
</tbody></table>
<p><strong>Returns</strong> the message submit instance for chained calls.</p>
<h4 id="inputtransactionid-index-messagesender"><a class="header" href="#inputtransactionid-index-messagesender">input(transactionId, index): MessageSender</a></h4>
<p>Adds an output to the transaction.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>transactionId</td><td><code>string</code></td><td>The transaction id</td></tr>
<tr><td>index</td><td><code>number</code></td><td>The input index</td></tr>
</tbody></table>
<p><strong>Returns</strong> the message submit instance for chained calls.</p>
<h4 id="inputrangestart-end-messagesender"><a class="header" href="#inputrangestart-end-messagesender">inputRange(start, end): MessageSender</a></h4>
<p>Defines the range in which to search for addresses fro custom inputs.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>start</td><td><code>number</code></td><td>The start index</td></tr>
<tr><td>end</td><td><code>number</code></td><td>The end index</td></tr>
</tbody></table>
<p><strong>Returns</strong> the message submit instance for chained calls.</p>
<h4 id="outputaddress-amount-messagesender"><a class="header" href="#outputaddress-amount-messagesender">output(address, amount): MessageSender</a></h4>
<p>Adds an output to the transaction.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>address</td><td><code>string</code></td><td>The output address</td></tr>
<tr><td>amount</td><td><code>number</code></td><td>The output amount</td></tr>
</tbody></table>
<p><strong>Returns</strong> the message submit instance for chained calls.</p>
<h4 id="dustallowanceoutputaddress-amount-messagesender"><a class="header" href="#dustallowanceoutputaddress-amount-messagesender">dustAllowanceOutput(address, amount): MessageSender</a></h4>
<p>Adds a dust allowance output to the transaction.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>address</td><td><code>string</code></td><td>The output address</td></tr>
<tr><td>amount</td><td><code>number</code></td><td>The output amount</td></tr>
</tbody></table>
<p><strong>Returns</strong> the message submit instance for chained calls.</p>
<h4 id="initialaddressindexindex-messagesender"><a class="header" href="#initialaddressindexindex-messagesender">initialAddressIndex(index): MessageSender</a></h4>
<p>Sets the initial address index to search for balance. Defaults to 0 if the function isn't called.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>index</td><td><code>number</code></td><td>The initial address index</td></tr>
</tbody></table>
<p><strong>Returns</strong> the message submit instance for chained calls.</p>
<h4 id="submit-promisestring"><a class="header" href="#submit-promisestring">submit(): Promise<string></a></h4>
<p>Submits the message.</p>
<p><strong>Returns</strong> a promise resolving to the message identifier.</p>
<h3 id="unspentaddressgetter"><a class="header" href="#unspentaddressgetter">UnspentAddressGetter</a></h3>
<p>Gets a valid unspent address associated with the seed.</p>
<h4 id="accountindexindex-unspentaddressgetter"><a class="header" href="#accountindexindex-unspentaddressgetter">accountIndex(index): UnspentAddressGetter</a></h4>
<p>Sets the account index. This field is required.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>index</td><td><code>number</code></td><td>The account index</td></tr>
</tbody></table>
<p><strong>Returns</strong> the address getter instance for chained calls.</p>
<h4 id="initialaddressindexindex-unspentaddressgetter"><a class="header" href="#initialaddressindexindex-unspentaddressgetter">initialAddressIndex(index): UnspentAddressGetter</a></h4>
<p>Sets the initial address index. Defaults to 0 if the function isn't called.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>index</td><td><code>number</code></td><td>The initial address index</td></tr>
</tbody></table>
<p><strong>Returns</strong> the address getter instance for chained calls.</p>
<h4 id="get-promiseaddress-number"><a class="header" href="#get-promiseaddress-number">get(): Promise&lt;[Address, number]&gt;</a></h4>
<p>Performs the operation.</p>
<p><strong>Returns</strong> a promise resolving to the <a href="libraries/client-lib/docs/libraries/nodejs/api_reference.html#address">Address</a> instance and its index.</p>
<h3 id="addressgetter"><a class="header" href="#addressgetter">AddressGetter</a></h3>
<p>Generates addresses with a given seed.</p>
<h4 id="accountindexindex-addressgetter"><a class="header" href="#accountindexindex-addressgetter">accountIndex(index): AddressGetter</a></h4>
<p>Sets the account index. This field is required.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>index</td><td><code>number</code></td><td>The account index</td></tr>
</tbody></table>
<p><strong>Returns</strong> the address finder instance for chained calls.</p>
<h4 id="rangestart-end-addressgetter"><a class="header" href="#rangestart-end-addressgetter">range(start, end): AddressGetter</a></h4>
<p>Defines the range of addresses to get. Defaults to <code>0..20</code> if the function isn't called.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>start</td><td><code>number</code></td><td>The first address index</td></tr>
<tr><td>end</td><td><code>number</code></td><td>The last address index</td></tr>
</tbody></table>
<p><strong>Returns</strong> the address finder instance for chained calls.</p>
<h4 id="get-address"><a class="header" href="#get-address">get(): Address[]</a></h4>
<p>Performs the operation.</p>
<p><strong>Returns</strong> an array of <a href="libraries/client-lib/docs/libraries/nodejs/api_reference.html#address">Address</a> instances.</p>
<h3 id="balancegetter"><a class="header" href="#balancegetter">BalanceGetter</a></h3>
<p>Gets balance on a given seed.</p>
<h4 id="accountindexindex-balancegetter"><a class="header" href="#accountindexindex-balancegetter">accountIndex(index): BalanceGetter</a></h4>
<p>Sets the account index. This field is required.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>index</td><td><code>number</code></td><td>The account index</td></tr>
</tbody></table>
<p><strong>Returns</strong> the balance getter instance for chained calls.</p>
<h4 id="initialaddressindexindex-balancegetter"><a class="header" href="#initialaddressindexindex-balancegetter">initialAddressIndex(index): BalanceGetter</a></h4>
<p>Sets the initial address index. Defaults to 0 if the function isn't called.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>index</td><td><code>number</code></td><td>The initial address index</td></tr>
</tbody></table>
<p><strong>Returns</strong> the balance getter instance for chained calls.</p>
<h4 id="gaplimitamount-balancegetter"><a class="header" href="#gaplimitamount-balancegetter">gapLimit(amount): BalanceGetter</a></h4>
<p>Sets the gapLimit to specify how many addresses will be checked each round.
If gap_limit amount of addresses in a row have no balance the BalanceGetter will return. Defaults to 20 if the function isn't called.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>gap_limit</td><td><code>number</code></td><td>The initial address index</td></tr>
</tbody></table>
<p><strong>Returns</strong> the balance getter instance for chained calls.</p>
<h4 id="get-promisenumber"><a class="header" href="#get-promisenumber">get(): Promise<number></a></h4>
<p>Performs the operation.</p>
<p><strong>Returns</strong> a promise resolving to the account balance.</p>
<h3 id="messagefinder"><a class="header" href="#messagefinder">MessageFinder</a></h3>
<p>Gets a message by indexation key or identifier.</p>
<h4 id="initialaddressindexindex-promisestring"><a class="header" href="#initialaddressindexindex-promisestring">initialAddressIndex(index): Promise&lt;string[]&gt;</a></h4>
<table><thead><tr><th>Param</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>index</td><td><code>string</code></td><td>The indexation key</td></tr>
</tbody></table>
<p>Gets a list of message identifiers associated with the given indexation key.</p>
<p><strong>Returns</strong> a promise resolving to the list of associated ids.</p>
<h4 id="dataid-promisemessage"><a class="header" href="#dataid-promisemessage">data(id): Promise<Message></a></h4>
<p>Gets the message object associated with the given identifier.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>id</td><td><code>string</code></td><td>The message identifier</td></tr>
</tbody></table>
<p><strong>Returns</strong> a <a href="libraries/client-lib/docs/libraries/nodejs/api_reference.html#message">Message</a> object.</p>
<h4 id="rawid-promisestring"><a class="header" href="#rawid-promisestring">raw(id): Promise<string></a></h4>
<p>Gets the message raw data.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>id</td><td><code>string</code></td><td>The message identifier</td></tr>
</tbody></table>
<p><strong>Returns</strong> the message raw data as string.</p>
<h4 id="childrenid-promisestring"><a class="header" href="#childrenid-promisestring">children(id): Promise&lt;string[]&gt;</a></h4>
<p>Gets the children of the given message.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>id</td><td><code>string</code></td><td>The message identifier</td></tr>
</tbody></table>
<p><strong>Returns</strong> the list of message ids of the message children.</p>
<h4 id="metadataid-promisemessagemetadata"><a class="header" href="#metadataid-promisemessagemetadata">metadata(id): Promise<MessageMetadata></a></h4>
<p>Gets the metadata of the given message.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>id</td><td><code>string</code></td><td>The message identifier</td></tr>
</tbody></table>
<p><strong>Returns</strong> a <a href="libraries/client-lib/docs/libraries/nodejs/api_reference.html#messagemetadata">MessageMetadata</a> object.</p>
<h3 id="brokeroptions"><a class="header" href="#brokeroptions">BrokerOptions</a></h3>
<table><thead><tr><th>Field</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>automaticDisconnect</td><td><code>number</code></td><td>Whether the MQTT broker should be automatically disconnected when all topics are unsubscribed or not.</td></tr>
<tr><td>timeout</td><td><code>number</code></td><td>MQTT connection timeout in secods</td></tr>
</tbody></table>
<h3 id="address"><a class="header" href="#address">Address</a></h3>
<table><thead><tr><th>Field</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>type</td><td><code>'Ed25519'</code></td><td>Address type</td></tr>
<tr><td>data</td><td><code>string</code></td><td>Address as a Bech32 string</td></tr>
</tbody></table>
<h3 id="message"><a class="header" href="#message">Message</a></h3>
<table><thead><tr><th>Field</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>networkId</td><td><code>number</code></td><td>Network identifier</td></tr>
<tr><td>parents</td><td><code>string[]</code></td><td>Message ids of the message references</td></tr>
<tr><td>payload</td><td><code><a href="libraries/client-lib/docs/libraries/nodejs/api_reference.html#payload">Payload</a></code></td><td>Message payload</td></tr>
<tr><td>nonce</td><td><code>number</code></td><td>Message nonce</td></tr>
</tbody></table>
<h4 id="payload"><a class="header" href="#payload">Payload</a></h4>
<table><thead><tr><th>Field</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>data</td><td><code>{ type: 'Transaction', data: TransactionPayload } | { type: 'Indexation', data: IndexationPayload } | { type: 'Milestone', data: MilestonePayload}</code></td><td>Payload data</td></tr>
</tbody></table>
<h5 id="transactionpayload"><a class="header" href="#transactionpayload">TransactionPayload</a></h5>
<table><thead><tr><th>Field</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>essence</td><td><code>TransactionPayloadEssence</code></td><td>Transaction essence</td></tr>
<tr><td>unlock_blocks</td><td><code>UnlockBlock[]</code></td><td>Unlock blocks</td></tr>
</tbody></table>
<ul>
<li>TransactionPayloadEssence</li>
</ul>
<table><thead><tr><th>Field</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>inputs</td><td><code>Input[]</code></td><td>Inputs</td></tr>
<tr><td>outputs</td><td><code>Output[]</code></td><td>Outputs</td></tr>
<tr><td>payload</td><td><code>Payload | undefined</code></td><td>Payload for chaining</td></tr>
</tbody></table>
<ul>
<li>Input</li>
</ul>
<table><thead><tr><th>Field</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>type</td><td><code>'UTXO'</code></td><td>Input type identifier</td></tr>
<tr><td>data</td><td><code>string</code></td><td>The associated output id</td></tr>
</tbody></table>
<ul>
<li>Output</li>
</ul>
<table><thead><tr><th>Field</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>type</td><td><code>'SignatureLockedSingle'</code></td><td>Output type identifier</td></tr>
<tr><td>data</td><td><code>{ address: string, amount: number }</code></td><td>The output definition</td></tr>
</tbody></table>
<ul>
<li>UnlockBlock</li>
</ul>
<table><thead><tr><th>Field</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>type</td><td><code>'Signature' | 'Reference'</code></td><td>Unlock block type identifier</td></tr>
<tr><td>data</td><td><code>Ed25519SignatureUnlockBlock | number</code></td><td>Unlock block data (signature type or reference index)</td></tr>
</tbody></table>
<ul>
<li>Ed25519SignatureUnlockBlock</li>
</ul>
<table><thead><tr><th>Field</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>public_key</td><td><code>number[]</code></td><td>Ed25519 public key</td></tr>
<tr><td>signature</td><td><code>number[]</code></td><td>Ed25519 signature</td></tr>
</tbody></table>
<h5 id="indexationpayload-1"><a class="header" href="#indexationpayload-1">IndexationPayload</a></h5>
<table><thead><tr><th>Field</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>index</td><td><code>string</code></td><td>Indexation key</td></tr>
<tr><td>data</td><td><code>number[]</code></td><td>Indexation data as byte array</td></tr>
</tbody></table>
<h5 id="milestonepayload"><a class="header" href="#milestonepayload">MilestonePayload</a></h5>
<table><thead><tr><th>Field</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>essence</td><td><code>MilestoneEssence</code></td><td>Milestone essence</td></tr>
<tr><td>signatures</td><td><code>number[][]</code></td><td>Milestone signatures</td></tr>
</tbody></table>
<ul>
<li>MilestoneEssence</li>
</ul>
<table><thead><tr><th>Field</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>index</td><td><code>number</code></td><td>Milestone index</td></tr>
<tr><td>timestamp</td><td><code>number</code></td><td>Timestamp</td></tr>
<tr><td>parents</td><td><code>string[]</code></td><td>Message ids of the messages the milestone references</td></tr>
<tr><td>merkle_proof</td><td><code>number[]</code></td><td>Merkle proof</td></tr>
<tr><td>next_pow_score</td><td><code>number</code></td><td>Next PoW score</td></tr>
<tr><td>next_pow_score_milestone_index</td><td><code>number</code></td><td>Milestone index at which the next_pow_score will be used</td></tr>
<tr><td>public_keys</td><td><code>number[][]</code></td><td>public keys</td></tr>
</tbody></table>
<h3 id="messagedto"><a class="header" href="#messagedto">MessageDto</a></h3>
<table><thead><tr><th>Field</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>parents</td><td><code>string[] | undefined</code></td><td>Message ids of the messages it references. <code>getTips</code> is used by default</td></tr>
<tr><td>payload</td><td><code><a href="libraries/client-lib/docs/libraries/nodejs/api_reference.html#payloaddto">PayloadDto</a></code></td><td>Message payload</td></tr>
</tbody></table>
<h4 id="payloaddto"><a class="header" href="#payloaddto">PayloadDto</a></h4>
<table><thead><tr><th>Field</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>data</td><td><code>TransactionPayloadDto | IndexationPayloadDto</code></td><td>Payload data</td></tr>
</tbody></table>
<h5 id="transactionpayloaddto"><a class="header" href="#transactionpayloaddto">TransactionPayloadDto</a></h5>
<table><thead><tr><th>Field</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>essence</td><td><code>TransactionPayloadEssenceDto</code></td><td>Transaction essence</td></tr>
<tr><td>unlockBlocks</td><td><code>UnlockBlockDto[]</code></td><td>Unlock blocks</td></tr>
</tbody></table>
<ul>
<li>TransactionPayloadEssenceDto</li>
</ul>
<table><thead><tr><th>Field</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>inputs</td><td><code>string[]</code></td><td>Inputs</td></tr>
<tr><td>outputs</td><td><code>Output[]</code></td><td>Outputs</td></tr>
<tr><td>payload</td><td><code>PayloadDto | undefined</code></td><td>Payload for chaining</td></tr>
</tbody></table>
<ul>
<li>OutputDto</li>
</ul>
<table><thead><tr><th>Field</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>address</td><td><code>string</code></td><td>Output address</td></tr>
<tr><td>amount</td><td><code>amount</code></td><td>Output amount</td></tr>
</tbody></table>
<ul>
<li>UnlockBlockDto</li>
</ul>
<table><thead><tr><th>Field</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>data</td><td><code>Ed25519SignatureUnlockBlockDto | number</code></td><td>Unlock block data (signature type or reference index)</td></tr>
</tbody></table>
<ul>
<li>Ed25519SignatureUnlockBlockDto</li>
</ul>
<table><thead><tr><th>Field</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>publicKey</td><td><code>number[]</code></td><td>Ed25519 public key</td></tr>
<tr><td>signature</td><td><code>number[]</code></td><td>Ed25519 signature</td></tr>
</tbody></table>
<h5 id="indexationpayloaddto"><a class="header" href="#indexationpayloaddto">IndexationPayloadDto</a></h5>
<table><thead><tr><th>Field</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>index</td><td><code>string</code></td><td>Indexation key</td></tr>
<tr><td>data</td><td><code>Uint8Array</code></td><td>Indexation data</td></tr>
</tbody></table>
<h3 id="messagemetadata"><a class="header" href="#messagemetadata">MessageMetadata</a></h3>
<table><thead><tr><th>Field</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>messageId</td><td><code>string</code></td><td>Message identifier</td></tr>
<tr><td>parents</td><td><code>string[]</code></td><td>Message id of the messages it references</td></tr>
<tr><td>isSolid</td><td><code>boolean</code></td><td>Message solid state</td></tr>
<tr><td>shouldPromote</td><td><code>boolean | undefined</code></td><td>Indicates whether the message should be promoted or not</td></tr>
<tr><td>shouldReattach</td><td><code>boolean | undefined</code></td><td>Indicates whether the message should be reattached or not</td></tr>
<tr><td>referencedByMilestoneIndex</td><td><code>number | undefined</code></td><td>Index of the milestone that references this message</td></tr>
<tr><td>ledgerInclusionState</td><td><code>string | undefined</code></td><td>Ledger inclusion state</td></tr>
</tbody></table>
<h3 id="nodeinfo"><a class="header" href="#nodeinfo">NodeInfo</a></h3>
<table><thead><tr><th>Field</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>name</td><td><code>string</code></td><td>Node name</td></tr>
<tr><td>version</td><td><code>string</code></td><td>Node version</td></tr>
<tr><td>isHealthy</td><td><code>boolean</code></td><td>Node health status</td></tr>
<tr><td>networkId</td><td><code>string</code></td><td>Node network identifier</td></tr>
<tr><td>bech32HRP</td><td><code>string</code></td><td>Bech32 HRP for this network</td></tr>
<tr><td>min_pow_score</td><td><code>number</code></td><td>Min PoW score</td></tr>
<tr><td>messages_per_second</td><td><code>number</code></td><td>Network stats: Messages per second in the network</td></tr>
<tr><td>referenced_messages_per_second</td><td><code>number</code></td><td>Network stats: Referenced messages per second</td></tr>
<tr><td>referenced_rate</td><td><code>number</code></td><td>Network stats: referenced rate</td></tr>
<tr><td>latest_milestone_timestamp</td><td><code>number</code></td><td>Timestamp of the latest milestone</td></tr>
<tr><td>latestMilestoneIndex</td><td><code>number</code></td><td>Index of the latest milestone</td></tr>
<tr><td>confirmedMilestoneIndex</td><td><code>number</code></td><td>Index of the confirmed milestone</td></tr>
<tr><td>pruningIndex</td><td><code>number</code></td><td>Pruning index</td></tr>
<tr><td>features</td><td><code>string[]</code></td><td>List of node features</td></tr>
</tbody></table>
<h3 id="outputmetadata"><a class="header" href="#outputmetadata">OutputMetadata</a></h3>
<table><thead><tr><th>Field</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>messageId</td><td><code>string</code></td><td>Id of the message associated with the output</td></tr>
<tr><td>transactionId</td><td><code>string</code></td><td>Id of the transaction associated with the output</td></tr>
<tr><td>outputIndex</td><td><code>number</code></td><td>Output index</td></tr>
<tr><td>isSpent</td><td><code>boolean</code></td><td>Output spent state</td></tr>
<tr><td>address</td><td><code>string</code></td><td>Output address</td></tr>
<tr><td>amount</td><td><code>number</code></td><td>Output amount</td></tr>
</tbody></table>
<h3 id="milestonemetadata"><a class="header" href="#milestonemetadata">MilestoneMetadata</a></h3>
<table><thead><tr><th>Field</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>milestoneIndex</td><td><code>number</code></td><td>Milestone index</td></tr>
<tr><td>messageId</td><td><code>string</code></td><td>Id of the message associated with the milestone</td></tr>
<tr><td>timestamp</td><td><code>number</code></td><td>Milestone timestamp</td></tr>
</tbody></table>
<h3 id="milestoneutxochanges"><a class="header" href="#milestoneutxochanges">MilestoneUTXOChanges</a></h3>
<table><thead><tr><th>Field</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>index</td><td><code>number</code></td><td>Milestone index</td></tr>
<tr><td>createdOutputs</td><td><code>string[]</code></td><td>OutputIds from new created outputs</td></tr>
<tr><td>consumedOutputs</td><td><code>string[]</code></td><td>OutputIds from consumed outputs</td></tr>
</tbody></table>
<h3 id="receipts"><a class="header" href="#receipts">Receipts</a></h3>
<table><thead><tr><th>Field</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>receipt</td><td><code>receipt</code></td><td>Receipt</td></tr>
<tr><td>milestone_index</td><td><code>number</code></td><td>Milestone index</td></tr>
</tbody></table>
<h3 id="treasury"><a class="header" href="#treasury">Treasury</a></h3>
<table><thead><tr><th>Field</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>milestone_id</td><td><code>string</code></td><td>Milestone id</td></tr>
<tr><td>amount</td><td><code>number</code></td><td>Amount</td></tr>
</tbody></table>
<h1 id="troubleshooting-1"><a class="header" href="#troubleshooting-1">Troubleshooting</a></h1>
<h2 id="stackexchange-1"><a class="header" href="#stackexchange-1">StackExchange</a></h2>
<blockquote>
<p><a href="https://iota.stackexchange.com/">https://iota.stackexchange.com</a></p>
</blockquote>
<p>The IOTA StackExchange a a nice tool for developers to find answers for a problem. Just search your problem and find your answer! If there is no one, submit your question and share it in the discussion channel below.</p>
<h2 id="joining-the-discussion-4"><a class="header" href="#joining-the-discussion-4">Joining the discussion</a></h2>
<p>If you want to get involved in discussions about this library, or you're looking for support, go to the #clients-discussion channel on <a href="https://discord.iota.org">Discord</a>.</p>
<h1 id="iota-client-python-library"><a class="header" href="#iota-client-python-library">IOTA Client Python Library</a></h1>
<p><a href="https://github.com/iotaledger/iota.rs"><img src="https://img.shields.io/badge/Status-Alpha-yellow.svg" alt="status" /></a></p>
<h2 id="warning-3"><a class="header" href="#warning-3">Warning</a></h2>
<p>This library is in active development. The library targets the Chrysalis testnet and does not work with current IOTA mainnet.</p>
<h2 id="joining-the-discussion-5"><a class="header" href="#joining-the-discussion-5">Joining the discussion</a></h2>
<p>If you want to get involved in discussions about this library, or you're looking for support, go to the #clients-discussion channel on <a href="https://discord.iota.org">Discord</a>.</p>
<h2 id="overview-3"><a class="header" href="#overview-3">Overview</a></h2>
<ul>
<li><a href="libraries/client-lib/docs/libraries/python/">Getting Started</a></li>
<li><a href="libraries/client-lib/docs/libraries/python/">Examples</a></li>
<li><a href="libraries/client-lib/docs/libraries/python/">API Reference</a></li>
<li><a href="libraries/client-lib/docs/libraries/python/">Troubleshooting</a></li>
</ul>
<h1 id="getting-started-with-iota-client-python-binding"><a class="header" href="#getting-started-with-iota-client-python-binding">Getting Started with IOTA Client Python binding</a></h1>
<h2 id="installation-1"><a class="header" href="#installation-1">Installation</a></h2>
<p>Easiest way how to get python binding up and running is to leverage pre-built python libraries for linux/macos/windows that can be installed to your python environment (3.6+) via <code>pip</code>. The binding is automagically generated using github <a href="https://github.com/iotaledger/iota.rs/actions/workflows/python_binding_publish.yml">actions</a>.</p>
<p>The latest artifacts for major python versions can be also grabbed using <a href="https://nightly.link/iotaledger/iota.rs/workflows/python_binding_publish/dev">nighly.link service</a>. Download zip file for the given os and pyversion, unpack wheel file (<code>.whl</code>) and install it via <code>pip</code>:</p>
<pre><code class="language-bash">pip install &lt;wheel_file&gt;
</code></pre>
<p>Once it has been properly installed you can double check it using <code>pip</code>:</p>
<pre><code class="language-bash">pip list
</code></pre>
<p>You should see the similar output:</p>
<pre><code class="language-plaintext">Package                    Version
-------------------------- -------
iota-core-python           0.2.0a3
</code></pre>
<p>Once installed in the given python environment you are all set and can start hacking using python binding!</p>
<h2 id="usage"><a class="header" href="#usage">Usage</a></h2>
<pre><code class="language-python">import iota_client
print(iota_client.__doc__)
print(dir(iota_client))
</code></pre>
<h1 id="examples-2"><a class="header" href="#examples-2">Examples</a></h1>
<blockquote>
<p>Please note: It is not recommended to store passwords/seeds on host's environment variables or in the source code in a production setup! Please make sure you follow our <a href="https://chrysalis.docs.iota.org/guides/backup_security.html">backup and security</a> recommendations for production use!</p>
</blockquote>
<h2 id="connecting-to-nodes"><a class="header" href="#connecting-to-nodes">Connecting to node(s)</a></h2>
<p>All features of <code>iota.rs</code> library are accessible via an instance of <code>Client</code> class that provides high-level abstraction to all interactions over IOTA network (Tangle). This class has to be instantiated before starting any interactions with the library, or more precisely with <a href="https://chrysalis.docs.iota.org/node-software/node-software.html">IOTA nodes</a> that power IOTA network.</p>
<p>You may be familiar with a fact that in case of IOTA 1.0 network one had to know an address of IOTA node to start participating to the network. It is no longer needed in IOTA 1.5 (Chrysalis) world. The library is designed to automatically choose a starting IOTA node based on the network type one would like to participate in: <code>testnet</code> or <code>mainnet</code>.</p>
<p>So very simplistic example how to connect to <a href="https://chrysalis.docs.iota.org/testnet.html">IOTA testnet</a> is the following one:</p>
<pre><code class="language-python">import iota_client

# client will connect to testnet by default
client = iota_client.Client()
print(client.get_info())
</code></pre>
<p>Output example of <code>get_info()</code> function of the <code>Client</code> instance:</p>
<pre><code class="language-json">{
    'name': 'HORNET',
    'version': '0.6.0-alpha',
    'is_healthy': True,
    'network_id': 'testnet6',
    'bech32_hrp': 'atoi',
    'latest_milestone_index': 192448,
    'confirmed_milestone_index': 192448,
    'pruning_index': 174931,
    'features': ['PoW'],
    'min_pow_score': 4000.0
}
</code></pre>
<p>The most important properties:</p>
<ul>
<li><code>is_healthy</code>: indicates whether the given node is in sync with the network and so it is safe to use it. Even if a node is up and running it may not be fully prepared to process your API calls properly. The node should be &quot;synced&quot;, meaning should be aware of all TXs in the Tangle. It is better to avoid not fully synced nodes. A node healthiness can be alternatively obtained also with a method <code>Client.get_health()</code></li>
<li><code>bech32_hrp</code>: it indicates whether the given node is a part of testnet (<code>atoi</code>) or mainnet (<code>iota</code>). See more info regarding <a href="libraries/client-lib/docs/libraries/python/../../welcome.html#iota-15-address-anatomy">IOTA address format</a></li>
</ul>
<p><em>Please note, when using node load balancers then mentioned health check may be quite useless since follow-up API calls may be served by different node behind the load balancer that may have not been actually checked. One should be aware of this fact and trust the given load balancer participates only with nodes that are in healthy state. <code>iota.rs</code> library additionally supports a management of internal node pool and so load-balancer-like behavior can be mimicked using this feature locally.</em></p>
<p>Needless to say, the <code>Client</code> class constructor provides several parameters via which the process can be closely managed.</p>
<p>The most common ones:</p>
<ul>
<li><code>network</code>: can be <code>Testnet</code> or <code>Mainnet</code>. It instructs the library whether to automatically select testnet nodes or mainnet nodes</li>
<li><code>node</code>: specify address of actual running IOTA node that should be used to communicate with (in format <code>https://node:port</code>), for ex: https://api.lb-0.testnet.chrysalis2.com:443</li>
<li><code>node_pool_urls</code>: library also supports a management of pool of nodes. You can provide a list of nodes and library manages access to them automatically (selecting them based on their sync status)</li>
<li><code>local_pow</code>: <code>local_pow==True</code> (by default) means a <code>Proof-of-work</code> is done locally and not remotely</li>
<li><code>node_sync_disabled</code>: <code>node_sync_disabled==False</code> (by default) means that library checks for sync status of node(s) periodically before its use. <code>node_sync_disabled==True</code> means library also uses nodes that <em>are not</em> in sync with network. This parameter is usually useful if one would like to interact with local test node that is not fully synced. This parameter should not be used in production</li>
</ul>
<p>If <code>node_pool_urls</code> is provided then the library periodically checks in some interval (argument <code>node_sync_interval</code>) whether node is in sync or not.</p>
<h2 id="generating-seed-and-addresses"><a class="header" href="#generating-seed-and-addresses">Generating seed and addresses</a></h2>
<p>Since the IOTA network is permission-less type of network, anybody is able to use it and interact with it. No central authority is required at any stage. So anybody is able to generate own <code>seed</code> and then deterministically generate respective private keys/addresses.</p>
<blockquote>
<p>Please note, it is highly recommended to NOT use online seed generators at all. The seed is the only key to the given addresses. Anyone who owns the seed owns also all funds related to respective IOTA addresses (all of them).</p>
</blockquote>
<blockquote>
<p>We strongly recommend to use official <code>wallet.rs</code> library together with <code>stronghold.rs</code> enclave for value-based transfers. This combination incorporates the best security practices while dealing with seeds, related addresses and <code>UTXO</code>. See more information on <a href="https://chrysalis.docs.iota.org/libraries/wallet.html">Chrysalis docs</a>.</p>
</blockquote>
<p>IOTA 1.5 (Chrysalis) uses <code>Ed25519</code> signature scheme and address is usually represented by Bech32 (checksummed base32) format string of 64 characters.</p>
<p>A root of <code>Ed25519</code> signature scheme is basically a <code>32-byte (256-bit)</code> uniformly randomly generated seed based on which all private keys and corresponding addresses are generated. In the examples below, the seed is represented by a string of 64 characters using <code>[0-9a-f]</code> alphabet (32 bytes encoded in hexadecimal).</p>
<p>Seed can be for example generated using SHA256 algorithm on some random input generated by cryptographically secure pseudo-random generator, such as <code>os.urandom()</code>:</p>
<pre><code class="language-python">import os
import hashlib

rnd_seed = hashlib.sha256(os.urandom(256)).hexdigest()
print(rnd_seed)
</code></pre>
<p>Seed examples (a single seed per line):</p>
<pre><code class="language-plaintext">4892e2265c45734d07f220294b1697244a8ab5beb38ba9a7d57aeebf36b6e84a
37c4aab22a5883595dbc77907c1626c1be39d104df39c5d5708423c0286aea89
e94346bce41402155ef120e2525fad2d0bf30b10a89e4b93fd8471df1e6a0981
...
</code></pre>
<blockquote>
<p>In modern wallet implementations, such as our <a href="https://chrysalis.docs.iota.org/libraries/wallet.html">wallet.rs library</a> and <a href="https://blog.iota.org/firefly-beta-release/">firefly wallet</a>, the seed is usually generated from a <code>seed mnemonic</code> (<code>seed phrase</code>), using <a href="https://en.bitcoin.it/wiki/BIP_0039">BIP39 standard</a>, to be better memorized/stored by humans. It is based on randomly generated list of english words and later used to generate the seed. Either way, the seed is a root for all generated private keys and addresses</p>
</blockquote>
<h3 id="addresskey-space-1"><a class="header" href="#addresskey-space-1">Address/key space</a></h3>
<p>Before an actual address generation process, let's quickly focus on <a href="https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki">BIP32</a> standard that describes an approach to <em>Hierarchical Deterministic Wallets</em>. The standard was improved by <a href="https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki">BIP44</a> lately.</p>
<p>These standards define a tree structure as a base for address and key space generation which is represented by a <code>derivation path</code>:</p>
<pre><code class="language-plaintext">m / purpose / coin_type / account / change / address_index
</code></pre>
<ul>
<li><code>m</code>: a master node (seed)</li>
<li><code>purpose</code>: constant which is {44}</li>
<li><code>coin_type</code>: a constant set for each crypto currency. IOTA = 4218, for instance.</li>
<li><code>account</code>: account index. Zero-based increasing <code>int</code>. This level splits the address/key space into independent branches (ex. user identities) which each has own set of addresses/keys</li>
<li><code>change</code>: change index which is <code>{0, 1}</code>, also known as <code>wallet chain</code>.<br />
There are two independent chain of addresses/keys. <code>0</code> is reserved for public addresses (for coin receival) and <code>1</code> is reserved for internal (also known as change) addresses to which transaction change is returned. <em>In comparison to IOTA 1.0, IOTA 1.5 is totally fine with address reuse, and so it is, technically speaking, totally valid to return transaction change to the same originating address. So it is up to developers whether to leverage it or not. <code>iota.rs</code> library and its sibling <code>wallet.rs</code> help with either scenario</em></li>
<li><code>address_index</code>: address index. Zero-based increasing <code>int</code> that indicates an address index</li>
</ul>
<p>As outlined, there is a quite large address/key space that is secured by a single unique seed.</p>
<p>And there are few additional interesting notes:</p>
<ul>
<li>Each level defines a completely different subtree (subspace) of addresses/keys and those are never mixed up</li>
<li>The hierarchy is ready to &quot;absorb&quot; addresses/keys for many different coins at the same time (<code>coin_type</code>), and all those coins are secured by the same seed.<br />(So basically any BIP32/44-compliant wallet is potentially able to manage any BIP32/44-compliant coin(s))</li>
<li>There may be also other <code>purposes</code> in the future however let's consider a single purpose as of now. The constant <code>44</code> stands for BIP44</li>
<li>The standard was agreed upon different crypto communities, although not all <code>derivation path</code> components are always in active use. For example, <code>account</code> is not always actively leveraged across crypto space (if this is a case then there is usually <code>account=0</code> used)</li>
<li>Using different <code>accounts</code> may be useful to split addresses/key into some independent spaces and it is up to developers to implement.<br />
<em>Please note, it may have a negative impact on a performance while <a href="https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki#account-discovery">account discovery</a> phase. So if you are after using many multiple accounts then you may be interested in our stateful library <a href="https://chrysalis.docs.iota.org/libraries/wallet.html">wallet.rs</a> that incorporates all business logic needed to efficiently manage independent accounts. Also our <a href="https://chrysalis.docs.iota.org/guides/exchange_guide.html">exchange guide</a> provides some useful tips how different accounts may be leveraged</em></li>
</ul>
<p><img src="libraries/client-lib/docs/libraries/python/address_generation.svg" alt="address_generation" /></p>
<p>So in case of IOTA 1.5 (Chrysalis), the derivation path of address/key space is <code>[seed]/44/4218/{int}/{0,1}/{int}</code>. The levels <code>purpose</code> and <code>coin_type</code> are given, the rest levels are up to developers to integrate.</p>
<h3 id="generating-addresses"><a class="header" href="#generating-addresses">Generating address(es)</a></h3>
<p>IOTA addresses are generated via <code>Client.get_addresses()</code> function that returns a list of tuples with generated addresses. Considering the previous chapter about individual address/key spaces, it becomes quite clear what all used input function arguments are for.</p>
<p><em>Please note: for the examples outlined below, an example seed <code>b3d7092195c36d47133ff786d4b0a1ef2ee6a0052f6e87b6dc337935c70c531e</code> was used via environment variable called <code>IOTA_SEED_SECRET</code>. This seed serves for training purposes only.</em></p>
<p>The whole process is deterministic which means the output is the same as long as the seed is the same:</p>
<pre><code class="language-python">import os
import iota_client

# Get the seed from environment variable
IOTA_SEED_SECRET = os.getenv('IOTA_SEED_SECRET')
if not IOTA_SEED_SECRET:
    raise Exception(&quot;Please define environment variable called `IOTA_SEED_SECRET`&quot;)

client = iota_client.Client()

address_changed_list = client.get_addresses(
    seed=IOTA_SEED_SECRET,
    account_index=0,
    input_range_begin=0,
    input_range_end=10,
    get_all=True
)
print(address_changed_list)
</code></pre>
<p>Output example:</p>
<pre><code class="language-json">[('atoi1qp9427varyc05py79ajku89xarfgkj74tpel5egr9y7xu3wpfc4lkpx0l86', False),
 ('atoi1qzfvkkp398v7hhvu89fu88hxctf7snwc9sf3a3nd7msfv77jk7qk2ah07s3', True),
 ('atoi1qq4t98j5y8wxkaujue99mjwqcp6jvvmsd5lv0755sz7dtjdz3p2lydv76sy', False),
 ('atoi1qrhzhjxc4z8vpwjt3hafs5xpdng5katqe890p0h95mc0l273j8yzxn7r4hc', True),
 ('atoi1qputu0yvfvxd7g39wf4rc67e0f0dyhl6enxu9jxnsrjqmemh067tw7qelyc', False),
 ('atoi1qptg5w2x47qwjf3gpqt3h7d2ey5x7xf8v7qtt29gkxt4mjfjfc28sutvd8a', True),
 ('atoi1qprvelq9paakh72fgm6j2kf8kexadw3t5xljer9dpsep5c7wx5mjwdxch6z', False),
 ('atoi1qrwk37tz47ddng9kpxfflkpz5tplcq7ll56v4acam04307xk70l7uf6wg8j', True),
 ('atoi1qper3zr5xe9x0wqs35ytwh622870g44frkyygdhs0ds8yejle3xujhq7dx3', False),
 ('atoi1qq6lkr9hucfylqjaqphu0stvk8pcmsx98r7ukuq40asszwmqytlnc058thk', True),
 ('atoi1qzpn7se3ryhscmqg404pycxzvfpt8v4xn8aul0tqdh00xsncgnxu7na7zjj', False),
 ('atoi1qz4qqakty9qytw8fk9shelt9lwlvv83s5ggt3wjag9fkgcc74z78w4l86y5', True),
 ('atoi1qp20uddchglqry0l5qnjg5aln8d5rk2v5l45hwrxv9z0daxs7u6xcsh4077', False),
 ('atoi1qrlqm2u5txxxnjx22fxq0jfjzk6l4nwnue6ht5pepk65m2f4xmxqynmxu2m', True),
 ('atoi1qqydc70mpjdvl8l2wyseaseqwzhmedzzxrn4l9g2c8wdcsmhldz0ulwjxpz', False),
 ('atoi1qrkjennxyl2xcqem6x69ya65sasma33z0ux872k846lqft0s3qf7k6lqpft', True),
 ('atoi1qr4yuekp30ff7mnnnjwy9tdhynxmlmkpuxf70qurtwudp2zpf3jeyw4uh37', False),
 ('atoi1qp6m5sz5ayjtccfxapdk5lp4qkheyfg0emzntmulyxzftps730vcul8dmqr', True),
 ('atoi1qzrwhkzhu67fqltfffwljejawdcghedukpgu9x6tzevwlnq89gmfjtayhgz', False),
 ('atoi1qpehxcp24z947dgupjqc9ktkn5ylmdxqqnx83m7xlajnf8005756u4n7z77', True)]
</code></pre>
<ul>
<li>Each tuple contains <code>address</code> and <code>bool</code> value indicating the given address is a <code>change</code> address or not.<br />
<code>True</code> means the given address is a change address (internal). So basically we've got two independent sets of addresses (10 items per each)</li>
<li>This behavior is controlled via <code>get_all</code> argument. <code>get_all=False</code> (default) means to generate only public addresses</li>
</ul>
<p>IOTA address is represented by a checksumed base 32 string (Bech32) and you can see a detailed explanation on <a href="https://chrysalis.docs.iota.org/guides/index.html#iota-15-address-anatomy">Chrysalis docs</a>.
Just a recap:</p>
<ul>
<li>If an address starts with <code>atoi</code> then it means it is related to <code>testnet</code>. <code>iota</code> stands for mainnet</li>
<li>Number <code>1</code> at 5<sup>th</sup> position is just a separator</li>
<li>The last 6 characters are reserved for a checksum</li>
</ul>
<p>To quickly validate any IOTA address, there is a convenience function <code>Client.is_address_valid()</code> that returns <code>bool</code> value. Needless to say, performing a sanity check of an address before its use is an advisable practice.</p>
<h2 id="checking-a-balance"><a class="header" href="#checking-a-balance">Checking a balance</a></h2>
<p><em>In Chrysalis testnet, there is a faucet service that provides test tokens to any testnet address: https://faucet.testnet.chrysalis2.com/</em></p>
<p>There are three common api calls that can be leveraged:</p>
<ul>
<li><code>Client.get_address_balance(address: str)</code>: it expects a single address in Bech32 format and returns <code>dict</code> with a balance for the address</li>
<li><code>Client.get_address_balances(list[str])</code>: a convenience function that expects <code>list</code> of addresses in Bech32 format and returns list of <code>dict</code> with balances for all given addresses</li>
<li><code>Client.get_balance(seed, account_index (optional), initial_address_index(optional), gap_limit(optional))</code>: a convenience function that combines <code>Client.get_addresses()</code> and <code>Client.get_address_balances()</code> api calls. It returns a combined balance for the provided seed and its wallet account index</li>
</ul>
<p><em>Please note: <code>Client.get_address_balance()</code> and <code>Client.get_address_balances()</code> return address(es) in hex-encoded Ed25519 address format, which is the format returned by underlying node software:</em></p>
<pre><code class="language-python">import os
import iota_client

# Get the seed from environment variable
IOTA_SEED_SECRET = os.getenv('IOTA_SEED_SECRET')
if not IOTA_SEED_SECRET:
    raise Exception(&quot;Please define environment variable called `IOTA_SEED_SECRET`&quot;)

client = iota_client.Client()

print(&quot;Return a balance for a single address:&quot;)
print(
    client.get_address_balance(&quot;atoi1qp9427varyc05py79ajku89xarfgkj74tpel5egr9y7xu3wpfc4lkpx0l86&quot;)
)

print(&quot;Return a balance for the given seed and account_index:&quot;)
print(
    client.get_balance(
        seed=IOTA_SEED_SECRET,
        account_index=0,
        initial_address_index=0
    )
)
</code></pre>
<p>Example of output:</p>
<pre><code class="language-json">Return balance for a single address:
{
    'address_type': 0,
    'address': '4b55799d1930fa049e2f656e1ca6e8d28b4bd55873fa6503293c6e45c14e2bfb',
    'balance': 10000000
}

Return balance for the given seed and account_index:
10000000
</code></pre>
<ul>
<li><code>address_type</code> indicates type of address. Value 0 denotes a Ed25519 address (currently the default for IOTA 1.5 network)</li>
</ul>
<p><code>Client.get_balance()</code> performs a several tasks under the hood.
It starts generating addresses for the provided <code>seed</code> and <code>account_index</code> from <code>initial_address_index</code>, and checks for a balance of each of the generated addresses. Since it does not know how many addresses are used in fact, there is a condition set by <code>gap_limit</code> argument when to stop searching. If <code>gap_limit</code> amount of addresses in a row have no balance the function returns result and searching does not continue.</p>
<h2 id="messages-payload-and-transactions"><a class="header" href="#messages-payload-and-transactions">Messages, payload and transactions</a></h2>
<p>Before we continue, let's introduce some additional terms that describe an unit that is actually broadcasted in IOTA 1.5 network.</p>
<p>In comparison to original IOTA 1.0, IOTA 1.5 introduced some fundamental changes to the underlying data structure. The original concept of <code>transactions</code> and <code>bundles</code> is gone, and has been replaced by a concept of <code>messages</code> and <code>payloads</code>.</p>
<p><code>Message</code> is a data structure that is actually being broadcasted in IOTA network and represent a node (vertex) in the Tangle graph. It can refer to up to 8 previous messages and once a message was attached to the Tangle and approved by a milestone, the Tangle structure ensures the content of the message is unaltered. Every message is referenced by <code>message_id</code> which is based on a hash algorithm of binary content of the message. <code>Message</code> is an atomic unit that is confirmed by network as a whole.</p>
<blockquote>
<p>IOTA is no longer based on ternary. IOTA 1.5 (Chrysalis) uses binary to encode and broadcast all underlying data entities</p>
</blockquote>
<p><code>Message</code> is broadcasted using a binary format, is arbitrary size (up to 35 kB) and it can hold a variable sets of information so called <code>payloads</code>. Number of payloads a single message can encapsulate is not given (even a message without any <code>payload</code> at all is completely valid).</p>
<p><code>Payload</code> represents a layer of concern. Some payloads may change a state of the ledger (ex. <code>transactions</code>) and some may provide extra features to some specific applications and business use cases (ex. <code>indexed data</code>).</p>
<p>There are already implemented core payloads, such as <code>SignedTransaction</code>, <code>MilestonePayload</code> and <code>IndexationPayload</code> but the message and payload definition is generic enough to incorporate any future payload(s) the community agrees upon.</p>
<p>Needless to say, IOTA network ensures the outer structure of message itself is valid and definitely aligned with a network consensus protocol, however the inner structure is very flexible, future-proof, and offer an unmatched network extensibility.</p>
<p><img src="libraries/client-lib/docs/libraries/python/messages_in_tangle.svg" alt="messages_in_tangle" /></p>
<p>The current IOTA 1.5 network incorporates the following core payloads:</p>
<ul>
<li><code>SignedTransaction</code>: payload that describes <code>UTXO</code> transactions that are cornerstone of value-based transfers in IOTA network. Via this payload, <code>message</code> can be also cryptographically signed</li>
<li><code>MilestonePayload</code>: payload that is emitted by Coordinator</li>
<li><code>IndexationPayload</code>: payload that enables addition of an index to the encapsulating message, as well as some arbitrary data. The given index can be later used to search the message(s)</li>
</ul>
<h3 id="unspent-transaction-output-utxo-1"><a class="header" href="#unspent-transaction-output-utxo-1">Unspent Transaction Output (UTXO)</a></h3>
<p>Originally, the IOTA used an <code>account-based model</code> for tracking individual iota tokens: <em>each IOTA address holds a number of tokens and aggregated number of tokens from all iota addresses is equal to total supply.</em></p>
<p>In contrary, IOTA 1.5 uses <code>unspent transaction output</code> model, so called <code>UTXO</code>. It is based on an idea to track unspent amount of tokens via data structure called <code>output</code>.</p>
<p>Simplified analogy:</p>
<ul>
<li>There is 100 tokens recorded in the ledger as <code>Output A</code> and this output belongs to Alice. So <strong>initial state of ledger</strong>: <code>Output A</code> = 100 tokens</li>
<li>Alice sends 20 tokens to Paul, 30 tokens to Linda and keeps 50 tokens at her disposal</li>
<li>Her 100 tokens are recorded as <code>Output A</code> and so she has to divide (spent) tokens and create three new outputs:<br /><code>Output B</code> with 20 tokens that goes to Paul, <code>Output C</code> with 30 tokens that goes to Linda and finally <code>Output D</code> with the rest 50 tokens that she keep for herself</li>
<li><strong>Original <code>Output A</code></strong> was completely spent and can't be used any more. It has been spent and so <strong>becomes irrelevant</strong> to ledger state</li>
<li><strong>New state of ledger</strong>: <code>Output B</code> = 20 tokens, <code>Output C</code> = 30 tokens and <code>Output D</code> = 50 tokens</li>
<li>Total supply remains the same. Just number of outputs differs and some outputs were replaced by other outputs in the process</li>
</ul>
<p><img src="libraries/client-lib/docs/libraries/python/utxo.svg" alt="utxo" /></p>
<p>The key takeaway of the outlined process is the fact that each unique <code>output</code> can be spent <strong>only once</strong>. Once the given <code>output</code> is spent, can't be used any more and is irrelevant in regards to the ledger state.</p>
<p>So even if Alice still wants to keep remaining tokens at her fingertips, those tokens have to be moved to completely new <code>output</code> that can be for instance still tight to the same Alice's iota address as before.</p>
<p>Every <code>output</code> stores also information about an IOTA address to which it is coupled with. So addresses and tokens are indirectly coupled via <code>outputs</code>.
So basically sum of outputs and their amounts under the given address is a balance of the given address, ie. the number of tokens the given address can spend. And sum of all unspent outputs and theirs amounts is equal to the total supply.</p>
<p>Before the chapter is wrapped up, one thing was left unexplained: <em>&quot;how outputs are being sent and broadcasted to network?&quot;</em> <code>Outputs</code> are being sent encapsulated in a <code>message</code> as a part of <code>SignedTransaction</code> payload.</p>
<h2 id="outputs"><a class="header" href="#outputs">Outputs</a></h2>
<p>There are three functions to get <code>UTXO</code> outputs (related to the given address):</p>
<ul>
<li><code>Client.get_address_outputs(str)</code>: it expects address in Bech32 format and returns <code>list[dict]</code> of <code>transaction_ids</code> and respective <code>indexes</code></li>
<li><code>Client.get_output(str)</code>: it expects <code>output_id</code> and returns the UTXO output associated with it</li>
<li><code>Client.find_outputs(output_ids (optional), addresses (optional))</code>: it is a bit more general and it searches for <code>UTXO</code> outputs associated with the given <code>output_ids</code> and/or <code>addresses</code></li>
</ul>
<p><code>Client.get_address_outputs(str)</code> returns <code>transaction_ids</code> and <code>indexes</code> in a raw form (in bytes) defined on protocol level and so usually some quick conversion is needed:</p>
<pre><code class="language-python">import iota_client
client = iota_client.Client()

outputs = client.get_address_outputs(&quot;atoi1qp9427varyc05py79ajku89xarfgkj74tpel5egr9y7xu3wpfc4lkpx0l86&quot;)
for output in outputs:
    print(f&quot;Output index: {output['index']}; raw transaction id: {output['transaction_id']}&quot;)
    encoded_hex = &quot;&quot;.join(f&quot;{i:0&gt;2x}&quot; for i in output[&quot;transaction_id&quot;]) + f&quot;{output['index']:0&gt;4x}&quot;
    print(f&quot;`output_id` encoded in hex: {encoded_hex}&quot;)
</code></pre>
<p>Output example:</p>
<pre><code class="language-plaintext">Output index: 0; raw transaction id: [162, 44, 186, 6, 103, 201, 34, 203, 177, 248, 189, 202, 249, 112, 178, 168, 129, 204, 214, 232, 142, 47, 204, 229, 3, 116, 222, 42, 172, 124, 55, 114]
`output_id` encoded in hex: a22cba0667c922cbb1f8bdcaf970b2a881ccd6e88e2fcce50374de2aac7c37720000
</code></pre>
<ul>
<li>as a result, <code>UTXO</code> output is represented by output <code>index</code> and <code>transaction_id</code>. <code>transaction_id</code> is basically a list of 32 <code>bytes</code>. <code>index</code> is 2-bytes (16bits) <code>uint</code></li>
<li><code>index</code> and <code>transaction_id</code> is usually combined into single hex string of 68 characters = 32 * 2 chars (<code>transaction_id</code>; 32 bytes in hex) + 4 chars (<code>index</code>; 2 bytes in hex).<br />
The resulting <code>output_id</code> is the unique id of the given <code>output</code></li>
</ul>
<p>Then the function <code>Client.get_output(str)</code> can be used to get details about the given <code>output_id</code>:</p>
<pre><code class="language-python">import iota_client
client = iota_client.Client()

print(
    client.get_output(&quot;a22cba0667c922cbb1f8bdcaf970b2a881ccd6e88e2fcce50374de2aac7c37720000&quot;)
)
</code></pre>
<p>Output example:</p>
<pre><code class="language-json">{'message_id': 'f51fb2839e0a24d5b4a97f1f5721fdac0f1eeafd77645968927f7c2f4b46565b',
 'transaction_id': 'a22cba0667c922cbb1f8bdcaf970b2a881ccd6e88e2fcce50374de2aac7c3772',
 'output_index': 0,
 'is_spent': False,
 'output': {'treasury': None,
  'signature_locked_single': {'kind': 0,
   'address': {'ed25519': {'kind': 0,
     'address': '4b55799d1930fa049e2f656e1ca6e8d28b4bd55873fa6503293c6e45c14e2bfb'}},
   'amount': 10000000},
  'signature_locked_dust_allowance': None}
}
</code></pre>
<p>A function <code>Client.find_outputs()</code> is a convenient shortcut combining both mentioned methods in a single call:</p>
<pre><code class="language-python">import iota_client
client = iota_client.Client()

client.find_outputs(addresses=[&quot;atoi1qp9427varyc05py79ajku89xarfgkj74tpel5egr9y7xu3wpfc4lkpx0l86&quot;])
</code></pre>
<ul>
<li>it supports two arguments, a list of <code>output_ids</code> or a list of <code>addresses</code></li>
</ul>
<p>Output example:</p>
<pre><code class="language-json">{'message_id': 'f51fb2839e0a24d5b4a97f1f5721fdac0f1eeafd77645968927f7c2f4b46565b',
 'transaction_id': 'a22cba0667c922cbb1f8bdcaf970b2a881ccd6e88e2fcce50374de2aac7c3772',
 'output_index': 0,
 'is_spent': False,
 'output': {'treasury': None,
  'signature_locked_single': {'kind': 0,
   'address': {'ed25519': {'kind': 0,
     'address': '4b55799d1930fa049e2f656e1ca6e8d28b4bd55873fa6503293c6e45c14e2bfb'}},
   'amount': 10000000},
  'signature_locked_dust_allowance': None}
}
</code></pre>
<ul>
<li><code>message_id</code>: refer to the encapsulating message in which the transaction was sent</li>
<li><code>transaction_id</code>, <code>output_index</code>: refer to the given output within the <code>SignedTransaction</code> payload. There may be several different <code>outputs</code> involved in a single transaction and so just <code>transaction_id</code> is not enough</li>
<li><code>output</code>: this section provides details about the iota address to which the given <code>unspent transaction output</code> is coupled with</li>
<li><code>amount</code>: state an amount of tokens related to the <code>output</code></li>
<li><code>is_spent</code>: of course, very important one indicating whether the given <code>output</code> is a part of the actual ledger state or not. As mentioned above, if an output was already spent, it is not part of ledger state any more and was replaced by some other <code>output(s)</code> in the process</li>
</ul>
<p>So this is quite interesting part, notice the <code>output_id</code> that was used in a function call to get output details is the same as a combination of <code>transaction_id</code> and <code>output index</code>.</p>
<p>This way a transaction is tightly coupled with <code>outputs</code> since <code>SignedTransaction</code> payload is a main vehicle how <code>outputs</code> are being created and spent, and altogether everything is encapsulated in a <code>message</code>.</p>
<h2 id="messages"><a class="header" href="#messages">Messages</a></h2>
<p>As mentioned above, the <code>message</code> is encapsulating data structure that is being actually broadcasted across network. It is an atomic unit that is accepted/rejected as a whole.</p>
<p>There is a convenient function <code>Client.message()</code> that prepares a message instance and sends it over a network. It accepts wide range of input parameters and can help with any kind of message type to be broadcasted.</p>
<p>The simplest message that can be broadcasted is a message without any particular payload:</p>
<pre><code class="language-python">import iota_client
client = iota_client.Client()

message = client.message()
print(message)
</code></pre>
<p>Output example:</p>
<pre><code class="language-json">{'message_id': 'e2daa4c6b012b615becd6c12189b2c9e701ba0d53b31a15425b21af5105fc086',
 'network_id': 7712883261355838377,
 'parents': ['0e2705ce50fec88f896663d4b7d562e74cbcfdd951ac482b1f03cfa5f27396d7',
  '0f5a0b2041766127c3f3bff2dd653b450b72e364765fcc805a40423c59ed01f9',
  '20635b30aee437575d7e6abdf6629eec80543bee30848b0abdda2200fc11a977',
  'da97cd6cfcbb854b8fd3f064c8459c5c9eae80dbd5ef594a3e1a26dcb8fc078c'],
 'payload': None,
 'nonce': 2305843009213869242}
</code></pre>
<ul>
<li><code>message_id</code> is an unique id that refers to the given message in network</li>
<li>as mentioned above, every message in the Tangle should refer to up to 8 other messages, those are indicated in the section <code>parents</code></li>
<li>no actual <code>payload</code> was given in this example message (<code>payload=None</code>)</li>
<li><code>nonce</code> refer to a result of proof-of-work</li>
</ul>
<p>Once a message is broadcasted, there are two main functions that can be used to read all information about the given message from the Tangle (<code>Client.get_message_data()</code> and <code>Client.get_message_metadata()</code>):</p>
<pre><code class="language-python">import iota_client
client = iota_client.Client()

message = client.get_message_data(&quot;e2daa4c6b012b615becd6c12189b2c9e701ba0d53b31a15425b21af5105fc086&quot;)
message_meta = client.get_message_metadata(&quot;e2daa4c6b012b615becd6c12189b2c9e701ba0d53b31a15425b21af5105fc086&quot;)

print(&quot;Message meta data:&quot;)
print(message_meta)
print(&quot;Message data:&quot;)
print(message)
</code></pre>
<p>Output example:</p>
<pre><code class="language-json">Message meta data:
{'message_id': 'e2daa4c6b012b615becd6c12189b2c9e701ba0d53b31a15425b21af5105fc086',
 'parent_message_ids': ['0e2705ce50fec88f896663d4b7d562e74cbcfdd951ac482b1f03cfa5f27396d7',
  '0f5a0b2041766127c3f3bff2dd653b450b72e364765fcc805a40423c59ed01f9',
  '20635b30aee437575d7e6abdf6629eec80543bee30848b0abdda2200fc11a977',
  'da97cd6cfcbb854b8fd3f064c8459c5c9eae80dbd5ef594a3e1a26dcb8fc078c'],
 'is_solid': True,
 'referenced_by_milestone_index': 284866,
 'milestone_index': None,
 'ledger_inclusion_state': {'state': 'NoTransaction'},
 'conflict_reason': None,
 'should_promote': None,
 'should_reattach': None}

Message data:
 {'message_id': 'e2daa4c6b012b615becd6c12189b2c9e701ba0d53b31a15425b21af5105fc086',
 'network_id': 7712883261355838377,
 'parents': ['0e2705ce50fec88f896663d4b7d562e74cbcfdd951ac482b1f03cfa5f27396d7',
  '0f5a0b2041766127c3f3bff2dd653b450b72e364765fcc805a40423c59ed01f9',
  '20635b30aee437575d7e6abdf6629eec80543bee30848b0abdda2200fc11a977',
  'da97cd6cfcbb854b8fd3f064c8459c5c9eae80dbd5ef594a3e1a26dcb8fc078c'],
 'payload': None,
 'nonce': 2305843009213869242}
</code></pre>
<ul>
<li><code>Client.get_message_metadata</code> provides information how the given message fits to network structures such as <code>ledger_inclusion_state</code>, etc.</li>
<li><code>Client.get_message_data</code> provides all data that relates to the given message and its payload(s)</li>
</ul>
<h3 id="indexationpayload-2"><a class="header" href="#indexationpayload-2">IndexationPayload</a></h3>
<p><code>IndexationPayload</code> is a payload type that can be used to attach an arbitrary <code>data</code> and key <code>index</code> to a message. At least <code>index</code> should be provided in order to send the given payload. Data part (as <code>list[bytes]</code>) is optional one:</p>
<pre><code class="language-python">import iota_client
client = iota_client.Client()

# encoding utf string into list of bytes
some_utf_data = &quot;some utf based data&quot;.encode(&quot;utf8&quot;)

message = client.message(
    index=&quot;some_data_index&quot;, data=some_utf_data
)
print(message)
</code></pre>
<p>Output example:</p>
<pre><code class="language-json">{'message_id': '8d4fa37be3c00691131c2c3e03e7b8b956c9118a2ce4be3a8597d51d82ed2de9',
 'network_id': 7712883261355838377,
 'parents': ['3719d308ae14b7ef1ed5a3a1604228e97587b9da487db10bc6e4a4f800083da0',
  '4431e2f776db888488728e0aa34c94975e65d6fa74893aa675172af6b9f37257',
  '8f9fa84954c58bcfc9acc33ca827b4ea35c2caae88db736399a031120e85eebf',
  'f63d416de97e6a9fd1314fbbbbb263f30dff260f3075f9a65e7dfe1f2cc56ce3'],
 'payload': {'transaction': None,
  'milestone': None,
  'indexation': [{'index': '736f6d655f646174615f696e646578',
    'data': [115,
     111,
     109,
     101,
     32,
     117,
     116,
     102,
     32,
     98,
     97,
     115,
     101,
     100,
     32,
     100,
     97,
     116,
     97]}],
  'receipt': None,
  'treasury_transaction': None},
 'nonce': 6917529027641573188}
</code></pre>
<ul>
<li>Feel free to check the given message using its <code>message_id</code> via <a href="https://explorer.iota.org/chrysalis/message/8d4fa37be3c00691131c2c3e03e7b8b956c9118a2ce4be3a8597d51d82ed2de9">Tangle explorer</a></li>
<li>In comparison to an empty message sent in the previous chapter, the <code>payload</code> section looks more interesting</li>
<li>There are three payloads prepared (<code>transaction</code>, <code>milestone</code> and <code>indexation</code>) however only <code>indexation</code> payload is leveraged this time</li>
<li><code>index</code> was simply encoded to <code>list[bytes]</code> in hex (no hash algorithm) and the resulting string can be leveraged as an additional way how to search for a set of indexed messages with the same key index via <a href="https://explorer.iota.org/chrysalis/indexed/736f6d655f646174615f696e646578">Tangle explorer</a> or <code>Client.find_messages()</code> API call</li>
<li><code>data</code> contains an arbitrary data encoded in bytes</li>
<li>In comparison to IOTA 1.0, please note there is no IOTA address involved while sending data messages via network in case of IOTA 1.5. Such messages are referenced using <code>message_id</code> or key <code>index</code></li>
<li>IOTA addresses are part of <code>UTXO</code> data structure that is sent using <code>SignedTransaction</code> payload explained below</li>
</ul>
<h3 id="signedtransaction-1"><a class="header" href="#signedtransaction-1">SignedTransaction</a></h3>
<p><code>SignedTransaction</code> is a payload type that is used to transfer value-based messages as <code>UTXO</code> (Unspent Transaction Output).</p>
<p>As mentioned above, this core payload changes the ledger state as old <code>outputs</code> are being spent (replaced) and new <code>outputs</code> are being created:</p>
<pre><code class="language-python">import iota_client
client = iota_client.Client()

client.get_message_data(&quot;f51fb2839e0a24d5b4a97f1f5721fdac0f1eeafd77645968927f7c2f4b46565b&quot;)
</code></pre>
<p>Example of a message with <code>SignedTransaction</code> payload:</p>
<pre><code class="language-json">{
    'message_id': 'f51fb2839e0a24d5b4a97f1f5721fdac0f1eeafd77645968927f7c2f4b46565b',
    'network_id': 7712883261355838377,
    'parents': [
        '4a84bf1d345a441cfdefd0e71d6efe820c1077e5dda9122a09cbf026132d208c',
        '6e9153884fd1983be4c27c3ccdc69760b4775484eea498ec0707c2ff8901995e',
        '7ac1407c88007a54d603400b558d5110f2bbf93a68100fb34f0b40cece9d0868',
        '9ac0fd457998a1b3ddab9c0014f41344475358ad36c64a4b763de3b51f47c09a'
    ],
    'payload': {
        'transaction': [
            {
                'essence': {
                    'inputs': [
                        {'transaction_id': '4a34274992474d91cf45366425ad1d4df6042cba64f3b6c07d297a2e6b7154a9', 'index': 0}
                    ],
                    'outputs': [
                        {'address': 'atoi1qp9427varyc05py79ajku89xarfgkj74tpel5egr9y7xu3wpfc4lkpx0l86', 'amount': 10000000},
                        {'address': 'atoi1qzdnav0zdgd4grn25cnwcuudtahvlhgh0r349ur749y9l03vadrfurhkxwj', 'amount': 100016136757200}
                    ],
                    'payload': {
                        'transaction': None,
                        'milestone': None,
                        'indexation': [
                            {'index': '54414e474c454b495420464155434554', 'data': []}
                        ],
                        'receipt': None,
                        'treasury_transaction': None
                    }
                },
                'unlock_blocks': [
                    {
                        'signature': {
                            'public_key': [...],
                            'signature': [...]
                        },
                        'reference': None
                    }
                ]
            }
        ],
        'milestone': None,
        'indexation': None,
        'receipt': None,
        'treasury_transaction': None
    },
    'nonce': 1146102
}
</code></pre>
<p>Each <code>transaction</code> includes the following set of information:</p>
<ul>
<li><code>inputs</code>: list of valid <code>outputs</code> that should be used to fund the given message. Those <code>outputs</code> will be spent and once the message is confirmed, those outputs are not valid anymore. Outputs are uniquely referenced via <code>transaction_id</code> and inner <code>index</code>. At least one output has to be given with enough balance to source all <code>outputs</code> of the given message</li>
<li><code>outputs</code>: list of IOTA address(es) and related amount(s) the input <code>outputs</code> should be split among. Based on this information, new <code>UTXO</code> entities (outputs) are being created</li>
<li><code>unlock_blocks</code>: it includes a transaction signature(s) (currently based on <code>Ed25519</code> scheme) that proofs token ownership based on a valid seed. Needless to say, only valid seed owner is able to correctly sign the given transaction and proofs the ownership of tokens under the given output(s). Each input <code>output</code> has to have a corresponding <code>unblock_block</code> entry in case more <code>outputs</code> are used to fund the operation either using the given signature or as a reference to existing signature</li>
<li><code>payload</code>: each <code>SignedTransaction</code> can include additional payload(s) such as <code>IndexationPayload</code>, etc. Meaning, any value-based messages can also contain arbitrary data and its key index. It is also an example how individual payloads can be encapsulated on different levels of concern</li>
</ul>
<p>Sending value-based messages is also very straightforward process.</p>
<p>As a minimum, it needs a valid seed, output addresses and amount. The method finds valid output(s) that can be used to fund the given amount(s) and the unspent amount is sent to the same address:</p>
<pre><code class="language-python">import os
import iota_client

# Get the seed from environment variable
IOTA_SEED_SECRET = os.getenv('IOTA_SEED_SECRET')
if not IOTA_SEED_SECRET:
    raise Exception(&quot;Please define environment variable called `IOTA_SEED_SECRET`&quot;)

client = iota_client.Client()

message = client.message(
    seed=IOTA_SEED_SECRET,
    outputs=[
        {
            'address': 'atoi1qqydc70mpjdvl8l2wyseaseqwzhmedzzxrn4l9g2c8wdcsmhldz0ulwjxpz',
            'amount': 1_000_000
        }
    ]
)
print(message)
</code></pre>
<p>Output example:</p>
<pre><code class="language-json">{
    'message_id': '7c47db1c4555348c260d91e90cc10fd66c2e73a84ec24bf9533e440f6d945d42',
    'network_id': 7712883261355838377,
    'parents': [
        '0ec0cd3c0303845980981bf7cc72371a8cd6e38c15924a2950fb15c5ecf4a53b',
        '4011f7724f96b6e39cdf9987ee650c0552d4fc63c09dd72b9be30a3cc7b53806',
        '5730d5bd607c6125130df30204c995db5edcbd16c4ab150946dffac37ace26f9',
        '8c1982682dbfa0abdd8772e38d044dbfcbea5ebb99bbe7174c07d81adda62419'
    ],
    'payload': {
        'transaction': [
            {
                'essence': {
                    'inputs': [
                        {'transaction_id': 'a22cba0667c922cbb1f8bdcaf970b2a881ccd6e88e2fcce50374de2aac7c3772', 'index': 0}
                    ],
                    'outputs': [
                        {'address': 'atoi1qqydc70mpjdvl8l2wyseaseqwzhmedzzxrn4l9g2c8wdcsmhldz0ulwjxpz', 'amount': 1000000},
                        {'address': 'atoi1qp9427varyc05py79ajku89xarfgkj74tpel5egr9y7xu3wpfc4lkpx0l86', 'amount': 9000000}
                    ],
                    'payload': None
                },
                'unlock_blocks': [
                    {'signature': {
                        'public_key': [
                        243,...&lt;trimmed&gt;
                        ],
                        'signature': [
                                64,...&lt;trimmed&gt;
                            ]
                        },
                        'reference': None
                    }
                ]
            }
        ],
        'milestone': None,
        'indexation': None,
        'receipt': None,
        'treasury_transaction': None
    },
    'nonce': 9223372036854802939
}
</code></pre>
<blockquote>
<p>We recommend to use official <code>wallet.rs</code> library together with <code>stronghold.rs</code> enclave for value-based transfers. This combination incorporates the best security practices while dealing with seeds, related addresses and <code>UTXO</code>. See more information on <a href="https://chrysalis.docs.iota.org/libraries/wallet.html">Chrysalis docs</a>.</p>
</blockquote>
<h4 id="dust-protection-1"><a class="header" href="#dust-protection-1">Dust protection</a></h4>
<p>Please note, there is also implemented a <a href="https://chrysalis.docs.iota.org/guides/dev_guide.html#dust-protection">dust protection</a> mechanism in the network protocol to avoid malicious actors to spam network in order to decrease node performance while keeping track of unspent amount (<code>UTXO</code>):</p>
<blockquote>
<p>&quot;... microtransaction below 1Mi of IOTA tokens [can be sent] to another address if there is already at least 1Mi on that address&quot;
That's why we did send 1Mi in the given example to comply with the protection.&quot;</p>
</blockquote>
<h1 id="api-reference-3"><a class="header" href="#api-reference-3">API Reference</a></h1>
<p>Note that in the following APIs, the corresponding exception will be returned if an error occurs.
Also for all the optional values, the default values are the same as the ones in the Rust version.</p>
<h3 id="client-1"><a class="header" href="#client-1">Client</a></h3>
<h4 id="constructornetwork-optional-storage-optional-password-optional-polling_interval-optional-a-hreflibrariesclient-libdocslibrariespythonapi_referencehtmlaccountmanageraccountmanagera"><a class="header" href="#constructornetwork-optional-storage-optional-password-optional-polling_interval-optional-a-hreflibrariesclient-libdocslibrariespythonapi_referencehtmlaccountmanageraccountmanagera">constructor(network (optional), storage (optional), password (optional), polling_interval (optional)): <a href="libraries/client-lib/docs/libraries/python/api_reference.html#accountmanager">AccountManager</a></a></h4>
<p>Creates a new instance of the Client.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td>[network]</td><td><code>str</code></td><td><code>undefined</code></td><td>The network</td></tr>
<tr><td>[node]</td><td><code>str</code></td><td><code>undefined</code></td><td>A node URL</td></tr>
<tr><td>[name]</td><td><code>str</code></td><td><code>undefined</code></td><td>The name for basic authentication</td></tr>
<tr><td>[password]</td><td><code>str</code></td><td><code>undefined</code></td><td>The password for basic authentication</td></tr>
<tr><td>[nodes]</td><td><code>list[str]</code></td><td><code>undefined</code></td><td>An array of node URLs</td></tr>
<tr><td>[node_sync_interval]</td><td><code>int</code></td><td><code>undefined</code></td><td>The interval for the node syncing process</td></tr>
<tr><td>[node_sync_disabled]</td><td><code>bool</code></td><td><code>undefined</code></td><td>Disables the node syncing process. Every node will be considered healthy and ready to use</td></tr>
<tr><td>[node_pool_urls]</td><td><code>str</code></td><td><code>undefined</code></td><td>An array of node pool URLs</td></tr>
<tr><td>[request_timeout]</td><td><code>int</code></td><td><code>undefined</code></td><td>Sets the default HTTP request timeout</td></tr>
<tr><td>[api_timeout]</td><td><code>dict</code></td><td><code>undefined</code></td><td>The API to set the request timeout. Key: 'GetHealth', 'GetInfo', 'GetPeers', 'GetTips', 'PostMessage', 'GetOutput', 'GetMilestone' Value: timeout in milliseconds</td></tr>
<tr><td>[local_pow]</td><td><code>bool</code></td><td><code>undefined</code></td><td>Flag determining if PoW should be done locally or remotely</td></tr>
<tr><td>[tips_interval]</td><td><code>int</code></td><td><code>undefined</code></td><td>Time between requests for new tips during PoW</td></tr>
<tr><td>[mqtt_broker_options]</td><td><code><a href="libraries/client-lib/docs/libraries/python/api_reference.html#brokeroptions">BrokerOptions</a></code></td><td><code>undefined</code></td><td>Sets the options for the MQTT connection with the node</td></tr>
</tbody></table>
<p><strong>Returns</strong> The constructed <a href="libraries/client-lib/docs/libraries/python/api_reference.html#client">Client</a>.</p>
<h3 id="full-node-apis"><a class="header" href="#full-node-apis">Full Node APIs</a></h3>
<h4 id="get_health-bool"><a class="header" href="#get_health-bool">get_health(): bool</a></h4>
<p>Gets the node health status.</p>
<p><strong>Returns</strong> whether the node is healthy.</p>
<h4 id="get_info-inforesponse"><a class="header" href="#get_info-inforesponse">get_info(): InfoResponse</a></h4>
<p>Gets information about the node.</p>
<p><strong>Returns</strong> the <a href="libraries/client-lib/docs/libraries/python/api_reference.html#inforesponse">InfoResponse</a>.</p>
<h4 id="get_peers-listpeerdto"><a class="header" href="#get_peers-listpeerdto">get_peers(): list[PeerDto]</a></h4>
<p>Gets peers of the node.</p>
<p><strong>Returns</strong> the list of <a href="libraries/client-lib/docs/libraries/python/api_reference.html#peerdto">PeerDto</a>.</p>
<h4 id="get_tips-liststr"><a class="header" href="#get_tips-liststr">get_tips(): list[str]</a></h4>
<p>Gets non-lazy tips.</p>
<p><strong>Returns</strong> two non-lazy tips' message ids in list.</p>
<h4 id="post_messagemsg-str"><a class="header" href="#post_messagemsg-str">post_message(msg): str</a></h4>
<p>Submits a message.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td>[msg]</td><td><code><a href="libraries/client-lib/docs/libraries/python/api_reference.html#message">Message</a></code></td><td><code>undefined</code></td><td>The message to submit</td></tr>
</tbody></table>
<p><strong>Returns</strong> the message id of the submitted message.</p>
<h4 id="get_outputoutput_id-outputresponse"><a class="header" href="#get_outputoutput_id-outputresponse">get_output(output_id): OutputResponse</a></h4>
<p>Gets the UTXO outputs associated with the given output id.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td>[output_id]</td><td><code>str</code></td><td><code>undefined</code></td><td>The id of the output to search</td></tr>
</tbody></table>
<p><strong>Returns</strong> the OutputResponse[#outputresponse].</p>
<h4 id="get_address_balanceaddress-balanceaddressresponse"><a class="header" href="#get_address_balanceaddress-balanceaddressresponse">get_address_balance(address): BalanceAddressResponse</a></h4>
<p>Gets the balance in the address.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td>[address]</td><td><code>list[str]</code></td><td><code>undefined</code></td><td>The address Bech32 string</td></tr>
</tbody></table>
<p><strong>Returns</strong> the <a href="libraries/client-lib/docs/libraries/python/api_reference.html#balanceaddressresponse">BalanceAddressResponse</a>.</p>
<h4 id="get_address_outputsaddress-options-optional-listutxoinput"><a class="header" href="#get_address_outputsaddress-options-optional-listutxoinput">get_address_outputs(address, options (optional)): list[UtxoInput]</a></h4>
<p>Gets the UTXO outputs associated with the given address.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td>[address]</td><td><code>str</code></td><td><code>undefined</code></td><td>The address Bech32 string</td></tr>
<tr><td>[options]</td><td><code>[<a href="libraries/client-lib/docs/libraries/python/api_reference.html#addressoutputsoptions">AddressOutputsOptions</a>]</code></td><td><code>undefined</code></td><td>The query filters</td></tr>
</tbody></table>
<p><strong>Returns</strong> the list of <a href="libraries/client-lib/docs/libraries/python/api_reference.html#utxoinput">UtxoInput</a>.</p>
<h4 id="find_outputsoutput_ids-optional-addresses-optional-listoutputresponse"><a class="header" href="#find_outputsoutput_ids-optional-addresses-optional-listoutputresponse">find_outputs(output_ids (optional), addresses (optional)): list[OutputResponse]</a></h4>
<p>Gets the UTXO outputs associated with the given output ids and addresses.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td>[output_ids]</td><td><code>list[str]</code></td><td><code>undefined</code></td><td>The list of addresses to search</td></tr>
<tr><td>[addresses]</td><td><code>list[str]</code></td><td><code>undefined</code></td><td>The list of output ids to search</td></tr>
</tbody></table>
<p><strong>Returns</strong> the list of <a href="libraries/client-lib/docs/libraries/python/api_reference.html#outputresponse">OutputResponse</a>.</p>
<h4 id="get_milestoneindex-milestonedto"><a class="header" href="#get_milestoneindex-milestonedto">get_milestone(index): MilestoneDto</a></h4>
<p>Gets the milestone by the given index.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td>[index]</td><td><code>int</code></td><td><code>undefined</code></td><td>The index of the milestone</td></tr>
</tbody></table>
<p><strong>Returns</strong> the <a href="libraries/client-lib/docs/libraries/python/api_reference.html#milestonedto">MilestoneDto</a>.</p>
<h4 id="get_milestone_utxo_changesindex-milestoneutxochanges"><a class="header" href="#get_milestone_utxo_changesindex-milestoneutxochanges">get_milestone_utxo_changes(index): MilestoneUTXOChanges</a></h4>
<p>Gets the utxo changes by the given milestone index.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td>[index]</td><td><code>int</code></td><td><code>undefined</code></td><td>The index of the milestone</td></tr>
</tbody></table>
<p><strong>Returns</strong> the <a href="libraries/client-lib/docs/libraries/python/api_reference.html#milestoneutxochanges">MilestoneUTXOChanges</a>.</p>
<h4 id="get_receipts-vecreceiptdto"><a class="header" href="#get_receipts-vecreceiptdto">get_receipts(): Vec<ReceiptDto></a></h4>
<p>Get all receipts.</p>
<p><strong>Returns</strong> the <a href="libraries/client-lib/docs/libraries/python/api_reference.html#ReceiptDto">ReceiptDto</a>.</p>
<h4 id="get_receipts_migrated_atindex-vecreceiptdto"><a class="header" href="#get_receipts_migrated_atindex-vecreceiptdto">get_receipts_migrated_at(index): Vec<ReceiptDto></a></h4>
<p>Get all receipts for a given milestone index.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td>[index]</td><td><code>int</code></td><td><code>undefined</code></td><td>The index of the milestone</td></tr>
</tbody></table>
<p><strong>Returns</strong> the <a href="libraries/client-lib/docs/libraries/python/api_reference.html#ReceiptDto">ReceiptDto</a>.</p>
<h4 id="get_treasury-treasuryresponse"><a class="header" href="#get_treasury-treasuryresponse">get_treasury(): TreasuryResponse</a></h4>
<p>Get the treasury amount.</p>
<p><strong>Returns</strong> the <a href="libraries/client-lib/docs/libraries/python/api_reference.html#TreasuryResponse">TreasuryResponse</a>.</p>
<h4 id="get_included_message-message"><a class="header" href="#get_included_message-message">get_included_message(): Message</a></h4>
<p>Get the included message of a transaction.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>[index]</td><td><code>string</code></td><td>The id of the transaction</td></tr>
</tbody></table>
<p><strong>Returns</strong> the new <a href="libraries/client-lib/docs/libraries/python/api_reference.html#message">Message</a>.</p>
<h3 id="high-level-apis"><a class="header" href="#high-level-apis">High-Level APIs</a></h3>
<h4 id="messageseed-optional-account_index-optional-initial_address_index-optional-inputs-optional-input_range_begin-optional-input_range_end-optional-outputs-optional-dust_allowance_outputs-optional-index-optional-index_raw-optional-data-optional-data_str-optional-parents-optional-message"><a class="header" href="#messageseed-optional-account_index-optional-initial_address_index-optional-inputs-optional-input_range_begin-optional-input_range_end-optional-outputs-optional-dust_allowance_outputs-optional-index-optional-index_raw-optional-data-optional-data_str-optional-parents-optional-message">message(seed (optional), account_index (optional), initial_address_index (optional), inputs (optional), input_range_begin (optional), input_range_end (optional), outputs (optional), dust_allowance_outputs (optional), index (optional), index_raw (optional), data (optional), data_str (optional), parents (optional)): Message</a></h4>
<p>Build a message.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td>[seed]</td><td><code>str</code></td><td><code>undefined</code></td><td>The hex-encoded seed of the account to spend</td></tr>
<tr><td>[account_index]</td><td><code>int</code></td><td><code>undefined</code></td><td>The account index</td></tr>
<tr><td>[initial_address_index]</td><td><code>int</code></td><td><code>undefined</code></td><td>The initial address index</td></tr>
<tr><td>[inputs]</td><td><code>list[<a href="libraries/client-lib/docs/libraries/python/api_reference.html#input">Input</a>]</code></td><td><code>undefined</code></td><td>Inputs</td></tr>
<tr><td>[input_range_begin]</td><td><code>int</code></td><td><code>undefined</code></td><td>The begin index of the input</td></tr>
<tr><td>[input_range_end]</td><td><code>int</code></td><td><code>undefined</code></td><td>The end index of the input</td></tr>
<tr><td>[outputs]</td><td><code>list[<a href="libraries/client-lib/docs/libraries/python/api_reference.html#output">Output</a>]</code></td><td><code>undefined</code></td><td>Outputs</td></tr>
<tr><td>[dust_allowance_outputs]</td><td><code>list[<a href="libraries/client-lib/docs/libraries/python/api_reference.html#output">Output</a>]</code></td><td><code>undefined</code></td><td>Dust allowance output to the transaction</td></tr>
<tr><td>[index]</td><td><code>str</code></td><td><code>undefined</code></td><td>The indexation string</td></tr>
<tr><td>[index_raw]</td><td><code>list[int]</code></td><td><code>undefined</code></td><td>The indexation byte array</td></tr>
<tr><td>[data]</td><td><code>list[int]</code></td><td><code>undefined</code></td><td>The data in bytes</td></tr>
<tr><td>[data_str]</td><td><code>str</code></td><td><code>undefined</code></td><td>The data string</td></tr>
<tr><td>[parents]</td><td><code>list[str]</code></td><td><code>undefined</code></td><td>The message ids of the parents</td></tr>
</tbody></table>
<p><strong>Returns</strong> the built <a href="libraries/client-lib/docs/libraries/python/api_reference.html#message">Message</a>.</p>
<h4 id="get_message_metadatamessage_id-messagemetadataresponse"><a class="header" href="#get_message_metadatamessage_id-messagemetadataresponse">get_message_metadata(message_id): MessageMetadataResponse</a></h4>
<table><thead><tr><th>Param</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td>[message_id]</td><td><code>str</code></td><td><code>undefined</code></td><td>The message id</td></tr>
</tbody></table>
<p><strong>Returns</strong> the <a href="libraries/client-lib/docs/libraries/python/api_reference.html#messagemetadataresponse">MessageMetadataResponse</a>.</p>
<h4 id="get_message_datamessage_id-message"><a class="header" href="#get_message_datamessage_id-message">get_message_data(message_id): Message</a></h4>
<p>Gets the message data from the message id.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td>[message_id]</td><td><code>str</code></td><td><code>undefined</code></td><td>The message id</td></tr>
</tbody></table>
<p><strong>Returns</strong> the <a href="libraries/client-lib/docs/libraries/python/api_reference.html#message">Message</a>.</p>
<h4 id="get_message_rawmessage_id-str"><a class="header" href="#get_message_rawmessage_id-str">get_message_raw(message_id): str</a></h4>
<p>Gets the raw message string from the message id.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td>[message_id]</td><td><code>str</code></td><td><code>undefined</code></td><td>The message id</td></tr>
</tbody></table>
<p><strong>Returns</strong> the raw message string.</p>
<h4 id="get_message_childrenmessage_id-liststr"><a class="header" href="#get_message_childrenmessage_id-liststr">get_message_children(message_id): list[str]</a></h4>
<p>Gets the children of the given message.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td>[message_id]</td><td><code>str</code></td><td><code>undefined</code></td><td>The message id</td></tr>
</tbody></table>
<p><strong>Returns</strong> the list of children strings.</p>
<h4 id="get_message_indexindex-liststr"><a class="header" href="#get_message_indexindex-liststr">get_message_index(index): list[str]</a></h4>
<p>Gets the list of message indices from the message_id.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td>[index]</td><td><code>str</code></td><td><code>undefined</code></td><td>The identifier of message</td></tr>
</tbody></table>
<p><strong>Returns</strong> the list of message ids.</p>
<h4 id="find_messagesindexation_keys-optional-message_ids-optional-listmessage"><a class="header" href="#find_messagesindexation_keys-optional-message_ids-optional-listmessage">find_messages(indexation_keys (optional), message_ids (optional)): list[Message]</a></h4>
<p>Finds all messages associated with the given indexation keys and message ids.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td>[indexation_keys]</td><td><code>list[str]</code></td><td><code>undefined</code></td><td>The list of indexations keys too search</td></tr>
<tr><td>[message_ids]</td><td><code>list[str]</code></td><td><code>undefined</code></td><td>The list of message ids to search</td></tr>
</tbody></table>
<p><strong>Returns</strong> the list of the found messages.</p>
<h4 id="get_unspent_addressseed-account_index-optional-initial_address_indexoptional-str-int"><a class="header" href="#get_unspent_addressseed-account_index-optional-initial_address_indexoptional-str-int">get_unspent_address(seed, account_index (optional), initial_address_index(optional)): (str, int)</a></h4>
<p>Gets a valid unspent address.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td>[seed]</td><td><code>str</code></td><td><code>undefined</code></td><td>The hex-encoded seed to search</td></tr>
<tr><td>[account_index]</td><td><code>int</code></td><td><code>undefined</code></td><td>The account index</td></tr>
<tr><td>[initial_address_index]</td><td><code>int</code></td><td><code>undefined</code></td><td>The initial address index</td></tr>
</tbody></table>
<p><strong>Returns</strong> a tuple with type of <code>(str, int)</code> as the address and corresponding index in the account.</p>
<h4 id="get_addressesseed-account_index-optional-input_range_begin-optional-input_range_end-optional-get_all-optional-liststr-bool-optional"><a class="header" href="#get_addressesseed-account_index-optional-input_range_begin-optional-input_range_end-optional-get_all-optional-liststr-bool-optional">get_addresses(seed, account_index (optional), input_range_begin (optional), input_range_end (optional) get_all (optional)): list[(str, bool (optional))]</a></h4>
<p>Finds addresses from the seed regardless of their validity.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td>[seed]</td><td><code>str</code></td><td><code>undefined</code></td><td>The hex-encoded seed to search</td></tr>
<tr><td>[account_index]</td><td><code>int</code></td><td><code>undefined</code></td><td>The account index</td></tr>
<tr><td>[input_range_begin]</td><td><code>int</code></td><td><code>undefined</code></td><td>The begin of the address range</td></tr>
<tr><td>[input_range_end]</td><td><code>int</code></td><td><code>undefined</code></td><td>The end of the address range</td></tr>
<tr><td>[get_all]</td><td><code>bool</code></td><td><code>undefined</code></td><td>Get all addresses</td></tr>
</tbody></table>
<p><strong>Returns</strong> a list of tuples with type of <code>(str, int)</code> as the address and corresponding index in the account.</p>
<h4 id="get_balanceseed-account_index-optional-initial_address_indexoptional-gap_limitoptional-int"><a class="header" href="#get_balanceseed-account_index-optional-initial_address_indexoptional-gap_limitoptional-int">get_balance(seed, account_index (optional), initial_address_index(optional), gap_limit(optional)): int</a></h4>
<p>Get balance on a given seed and its wallet account index.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td>[seed]</td><td><code>str</code></td><td><code>undefined</code></td><td>The hex-encoded seed to search</td></tr>
<tr><td>[account_index]</td><td><code>int</code></td><td><code>undefined</code></td><td>The account index</td></tr>
<tr><td>[initial_address_index]</td><td><code>int</code></td><td><code>undefined</code></td><td>The initial address index</td></tr>
<tr><td>[gap_limit]</td><td><code>int</code></td><td><code>undefined</code></td><td>The gap limit</td></tr>
</tbody></table>
<p><strong>Returns</strong> the amount of balance.</p>
<h4 id="get_address_balancesaddresses-listaddressbalancepair"><a class="header" href="#get_address_balancesaddresses-listaddressbalancepair">get_address_balances(addresses): list[AddressBalancePair]</a></h4>
<p>Get the balance in iotas for the given addresses.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td>[addresses]</td><td><code>list[str]</code></td><td><code>undefined</code></td><td>The list of addresses to search</td></tr>
</tbody></table>
<p><strong>Returns</strong> the list of <a href="libraries/client-lib/docs/libraries/python/api_reference.html#addressbalancepair">AddressBalancePair</a>.</p>
<h4 id="bech32_to_hexbech32"><a class="header" href="#bech32_to_hexbech32">bech32_to_hex(bech32)</a></h4>
<p>Returns a parsed hex String from bech32.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td>bech32</td><td><code>string</code></td><td><code>undefined</code></td><td>The address Bech32 string</td></tr>
</tbody></table>
<p><strong>Returns</strong> A String</p>
<h4 id="hex_to_bech32hex-bech32_hrp-optional"><a class="header" href="#hex_to_bech32hex-bech32_hrp-optional">hex_to_bech32(hex, bech32_hrp (optional))</a></h4>
<p>Returns a parsed bech32 String from hex.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td>bech32</td><td><code>string</code></td><td><code>undefined</code></td><td>The address Bech32 string</td></tr>
<tr><td>bech32_hrp</td><td><code>string</code></td><td><code>undefined</code></td><td>The Bech32 hrp string</td></tr>
</tbody></table>
<p><strong>Returns</strong> A String</p>
<h4 id="is_address_validaddress-bool"><a class="header" href="#is_address_validaddress-bool">is_address_valid(address): bool</a></h4>
<p>Checks if a given address is valid.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td>address</td><td><code>string</code></td><td><code>undefined</code></td><td>The address Bech32 string</td></tr>
</tbody></table>
<p><strong>Returns</strong> A boolean.</p>
<h4 id="retrymessage_id-str-message"><a class="header" href="#retrymessage_id-str-message">retry(message_id): (str, Message)</a></h4>
<p>Retries (promotes or reattaches) the message associated with the given id.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td>[message_id]</td><td><code>str</code></td><td><code>undefined</code></td><td>The message id</td></tr>
</tbody></table>
<p><strong>Returns</strong> the message id and the retried <a href="libraries/client-lib/docs/libraries/python/api_reference.html#message">Message</a>.</p>
<h4 id="retry_until_includedmessage_id-interval-optional-max_attempts-optional-liststr-message"><a class="header" href="#retry_until_includedmessage_id-interval-optional-max_attempts-optional-liststr-message">retry_until_included(message_id, interval (optional), max_attempts (optional)): list[(str, Message)]</a></h4>
<p>Retries (promotes or reattaches) the message associated with the given id.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td>[message_id]</td><td><code>str</code></td><td><code>undefined</code></td><td>The message id</td></tr>
<tr><td>interval</td><td><code>int</code></td><td><code>5</code></td><td>The interval in seconds in which we retry the message.</td></tr>
<tr><td>max_attempts</td><td><code>int</code></td><td><code>10</code></td><td>The maximum of attempts we retry the message.</td></tr>
</tbody></table>
<p><strong>Returns</strong> the message ids and <a href="libraries/client-lib/docs/libraries/python/api_reference.html#message">Message</a> of reattached messages.</p>
<h4 id="reattachmessage_id-str-message"><a class="header" href="#reattachmessage_id-str-message">reattach(message_id): (str, Message)</a></h4>
<p>Reattaches the message associated with the given id.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td>[message_id]</td><td><code>str</code></td><td><code>undefined</code></td><td>The message id</td></tr>
</tbody></table>
<p><strong>Returns</strong> the message id and the reattached <a href="libraries/client-lib/docs/libraries/python/api_reference.html#message">Message</a>.</p>
<h4 id="promotemessage_id-str-message"><a class="header" href="#promotemessage_id-str-message">promote(message_id): (str, Message)</a></h4>
<p>Promotes the message associated with the given id.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td>[message_id]</td><td><code>str</code></td><td><code>undefined</code></td><td>The message id</td></tr>
</tbody></table>
<p><strong>Returns</strong> the message id and the promoted <a href="libraries/client-lib/docs/libraries/python/api_reference.html#message">Message</a>.</p>
<h3 id="mqtt-apis"><a class="header" href="#mqtt-apis">MQTT APIs</a></h3>
<h4 id="subscribe_topictopic-callback-void"><a class="header" href="#subscribe_topictopic-callback-void">subscribe_topic(topic, callback): void</a></h4>
<p>Subscribe a topic and assign the associated callback.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td>[topic]</td><td><code>str</code></td><td><code>undefined</code></td><td>The MQTT topic</td></tr>
<tr><td>[callback]</td><td><code>function</code></td><td><code>undefined</code></td><td>The callback function</td></tr>
</tbody></table>
<h4 id="subscribe_topicstopics-callback-void"><a class="header" href="#subscribe_topicstopics-callback-void">subscribe_topics(topics, callback): void</a></h4>
<p>Subscribe topics and assign the associated callbacks, respectively.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td>[topics]</td><td><code>list[str]</code></td><td><code>undefined</code></td><td>The MQTT topics</td></tr>
<tr><td>[callback]</td><td><code>function</code></td><td><code>undefined</code></td><td>The callback functions</td></tr>
</tbody></table>
<h4 id="unsubscribe-void"><a class="header" href="#unsubscribe-void">unsubscribe(): void</a></h4>
<p>Unsubscribe all topics.</p>
<h4 id="disconnect-void"><a class="header" href="#disconnect-void">disconnect(): void</a></h4>
<p>Disconnect the mqtt broker.</p>
<h4 id="walletaddress"><a class="header" href="#walletaddress">WalletAddress</a></h4>
<p>A dict with the following key/value pairs.</p>
<pre><code class="language-python">message_metadata_response = {
    'message_id': str,
    'parent_message_ids': list[str],
    'is_solid': bool,
    'referenced_by_milestone_index': int, # (optional)
    'milestone_index': int,  # (optional)
    'ledger_inclusion_state': LedgerInclusionStateDto,  # (optional)
    'conflict_reason': int,  # (optional)
    'should_promote:' bool  # (optional)
    'should_reattach': bool  # (optional)
}
</code></pre>
<p>Please refer to <a href="libraries/client-lib/docs/libraries/python/api_reference.html#ledgerinclusionstatedto">LedgerInclusionStateDto</a> for the details of this type.</p>
<h4 id="balanceaddressresponse"><a class="header" href="#balanceaddressresponse">BalanceAddressResponse</a></h4>
<p>A dict with the following key/value pairs.</p>
<pre><code class="language-python">balance_for_address_response = {
    'address_type': int,
    'address': str,
    'balance': int
}
</code></pre>
<h4 id="addressbalancepair"><a class="header" href="#addressbalancepair">AddressBalancePair</a></h4>
<p>A dict with the following key/value pairs.</p>
<pre><code class="language-python">address_balance_pair = {
    'address': str,
    'balance': int
}
</code></pre>
<h4 id="milestonedto"><a class="header" href="#milestonedto">MilestoneDto</a></h4>
<p>A dict with the following key/value pairs.</p>
<pre><code class="language-python">milestoned_to = {
    'index': int,
    'timestamp': int,
    'message_id':  str
}
</code></pre>
<h4 id="milestoneutxochanges-1"><a class="header" href="#milestoneutxochanges-1">MilestoneUTXOChanges</a></h4>
<p>A dict with the following key/value pairs.</p>
<pre><code class="language-python">milestone_utxo_changes = {
    'index': int,
    'created_outputs': list[str],
    'consumed_outputs': list[str]
}
</code></pre>
<h4 id="receiptdto"><a class="header" href="#receiptdto">ReceiptDto</a></h4>
<p>A dict with the following key/value pairs.</p>
<pre><code class="language-python">receiptDto = {
    'receipt': Receipt,
    'milestone_index': int,
}
</code></pre>
<h4 id="treasuryresponse"><a class="header" href="#treasuryresponse">TreasuryResponse</a></h4>
<p>A dict with the following key/value pairs.</p>
<pre><code class="language-python">treasuryResponse = {
    'milestone_id': str,
    'amount': int,
}
</code></pre>
<h4 id="utxoinput"><a class="header" href="#utxoinput">UtxoInput</a></h4>
<p>A dict with the following key/value pairs.</p>
<pre><code class="language-python">utxo_input = {
    'transaction_id': list[int],
    'index': int
}
</code></pre>
<h4 id="outputresponse"><a class="header" href="#outputresponse">OutputResponse</a></h4>
<p>A dict with the following key/value pairs.</p>
<pre><code class="language-python">output_response = {
    'message_id': str,
    'transaction_id': str,
    'output_index': int,
    'is_spent': bool,
    'output': OutputDto
}
</code></pre>
<p>Please refer to <a href="libraries/client-lib/docs/libraries/python/api_reference.html#outputdto">OutputDto</a> for the details of this type.</p>
<h4 id="outputdto"><a class="header" href="#outputdto">OutputDto</a></h4>
<p>A dict with the following key/value pairs.</p>
<pre><code class="language-python">output_dto = {
    'treasury': TreasuryOutputDto, # (opitonal)
    'signature_locked_single': SignatureLockedSingleOutputDto, # (opitonal)
    'signature_locked_dust_allowance': SignatureLockedDustAllowanceOutputDto # (opitonal)
}
</code></pre>
<p>Please refer to <a href="libraries/client-lib/docs/libraries/python/api_reference.html#treasuryoutputdto">TreasuryOutputDto</a>, <a href="libraries/client-lib/docs/libraries/python/api_reference.html#signaturelockedsingleoutputdto">SignatureLockedSingleOutputDto</a>, and <a href="libraries/client-lib/docs/libraries/python/api_reference.html#signaturelockedDustallowanceoutputdto">SignatureLockedDustAllowanceOutputDto</a> for the details of these types.</p>
<h4 id="signaturelockedsingleoutputdto"><a class="header" href="#signaturelockedsingleoutputdto">SignatureLockedSingleOutputDto</a></h4>
<p>A dict with the following key/value pairs.</p>
<pre><code class="language-python">signature_locked_single_output_dto = {
    'kind': int,
    'address': AddressDto,
    'amount': int
}
</code></pre>
<p>Please refer to <a href="libraries/client-lib/docs/libraries/python/api_reference.html#addressdto">AddressDto</a> for the details of this type.</p>
<h4 id="signaturelockeddustallowanceoutputdto"><a class="header" href="#signaturelockeddustallowanceoutputdto">SignatureLockedDustAllowanceOutputDto</a></h4>
<p>A dict with the following key/value pairs.</p>
<pre><code class="language-python">signature_locked_dust_allowance_output_dto = {
    'kind': int,
    'address': AddressDto,
    'amount': int
}
</code></pre>
<p>Please refer to <a href="libraries/client-lib/docs/libraries/python/api_reference.html#addressdto">AddressDto</a> for the details of this type.</p>
<h4 id="pub-struct-treasuryoutputdto-"><a class="header" href="#pub-struct-treasuryoutputdto-">pub struct TreasuryOutputDto {</a></h4>
<p>A dict with the following key/value pairs.</p>
<pre><code class="language-python">treasury_output_dto = {
    'kind': int,
    'amount':int
}
</code></pre>
<h4 id="addressdto"><a class="header" href="#addressdto">AddressDto</a></h4>
<p>A dict with the following key/value pairs.</p>
<pre><code class="language-python">address_dto = {
    'ed25519': Ed25519AddressDto
}
</code></pre>
<p>Please refer to <a href="libraries/client-lib/docs/libraries/python/api_reference.html#ed25519addressdto">Ed25519AddressDto</a> for the details of this type.</p>
<h4 id="ed25519addressdto"><a class="header" href="#ed25519addressdto">Ed25519AddressDto</a></h4>
<p>A dict with the following key/value pairs.</p>
<pre><code class="language-python">ed25519_address_dto = {
    'kind': int,
    'address': str
}
</code></pre>
<h4 id="message-1"><a class="header" href="#message-1">Message</a></h4>
<p>A dict with the following key/value pairs.</p>
<pre><code class="language-python">message = {
    'message_id': str,
    'network_id': int,
    'parents': list[str],
    'payload': Payload, # (optional)
    'nonce': int
}
</code></pre>
<p>Please refer to <a href="libraries/client-lib/docs/libraries/python/api_reference.html#payload">Payload</a> for the details of this type.</p>
<h4 id="payload-1"><a class="header" href="#payload-1">Payload</a></h4>
<p>A dict with the following key/value pairs.</p>
<pre><code class="language-python">payload = {
    'transaction': list[Transaction], # (optional)
    'milestone': list[Milestone], # (optional)
    'indexation': list[Indexation], # (optional)
}
</code></pre>
<p>Please refer to <a href="libraries/client-lib/docs/libraries/python/api_reference.html#transaction">Transaction</a>, <a href="libraries/client-lib/docs/libraries/python/api_reference.html#milestone">Milestone</a>, and <a href="libraries/client-lib/docs/libraries/python/api_reference.html#indexation">Indexation</a> for the details of these types.</p>
<h4 id="transaction"><a class="header" href="#transaction">Transaction</a></h4>
<p>A dict with the following key/value pairs.</p>
<pre><code class="language-python">transaction = {
    'essence': RegularEssence,
    'unlock_blocks': list[UnlockBlock]
}
</code></pre>
<p>Please refer to <a href="libraries/client-lib/docs/libraries/python/api_reference.html#regularessence">RegularEssence</a>, and <a href="libraries/client-lib/docs/libraries/python/api_reference.html#unlockblock">UnlockBlock</a> for the details of these types.</p>
<h4 id="milestone"><a class="header" href="#milestone">Milestone</a></h4>
<p>A dict with the following key/value pairs.</p>
<pre><code class="language-python">milestone = {
    'essence': MilestonePayloadEssence,
    'signatures': list[list[int]]
}
</code></pre>
<p>Please refer to <a href="libraries/client-lib/docs/libraries/python/api_reference.html#milestonepayloadessence">MilestonePayloadEssence</a> for the details of this type.</p>
<h4 id="milestonepayloadessence"><a class="header" href="#milestonepayloadessence">MilestonePayloadEssence</a></h4>
<p>A dict with the following key/value pairs.</p>
<pre><code class="language-python">milestone_payload_essence = {
    'index': int,
    'timestamp': int,
    'parents': list[str],
    'merkle_proof': list[int],
    'next_pow_score': int,
    'next_pow_score_milestone_index': int,
    'public_keys': list[list[int]]
}
</code></pre>
<h4 id="indexation"><a class="header" href="#indexation">Indexation</a></h4>
<p>A dict with the following key/value pairs.</p>
<pre><code class="language-python">indexation = {
    'index': str,
    'data': list[int]
}
</code></pre>
<h4 id="regularessence"><a class="header" href="#regularessence">RegularEssence</a></h4>
<p>A dict with the following key/value pairs.</p>
<pre><code class="language-python">regular_essence = {
    'inputs': list[Input],
    'outputs': list[Output],
    'payload': list[Payload]
}
</code></pre>
<p>Please refer to <a href="libraries/client-lib/docs/libraries/python/api_reference.html#input">Input</a>, <a href="libraries/client-lib/docs/libraries/python/api_reference.html#output">Output</a>, and <a href="libraries/client-lib/docs/libraries/python/api_reference.html#payload">Payload</a> for the details of these types.</p>
<h4 id="output"><a class="header" href="#output">Output</a></h4>
<p>A dict with the following key/value pairs.</p>
<pre><code class="language-python">output = {
    'address': str,
    'amount': int
}
</code></pre>
<h4 id="input"><a class="header" href="#input">Input</a></h4>
<p>A dict with the following key/value pairs.</p>
<pre><code class="language-python">input = {
    'transaction_id': str,
    'index': int
}
</code></pre>
<h4 id="unlockblock"><a class="header" href="#unlockblock">UnlockBlock</a></h4>
<p>A dict with the following key/value pairs.</p>
<pre><code class="language-python">unlock_block = {
    'signature': Ed25519Signature, # (optional)
    'reference': int # (optional)
}
</code></pre>
<p>Please refer to <a href="libraries/client-lib/docs/libraries/python/api_reference.html#ed25519Signature">Ed25519Signature</a> for the details of this type.</p>
<h4 id="ed25519signature"><a class="header" href="#ed25519signature">Ed25519Signature</a></h4>
<p>A dict with the following key/value pairs.</p>
<pre><code class="language-python">ed25519_signature = {
    'public_key': list[int],
    'signature': list[int]
}
</code></pre>
<h4 id="brokeroptions-1"><a class="header" href="#brokeroptions-1">BrokerOptions</a></h4>
<p>A dict with the following key/value pairs.</p>
<pre><code class="language-python">broker_options = {
    'automatic_disconnect': bool,
    'timeout': int,
    'max_reconnection_attempts': int,
}
</code></pre>
<h4 id="ledgerinclusionstatedto"><a class="header" href="#ledgerinclusionstatedto">LedgerInclusionStateDto</a></h4>
<p>A dict with the following key/value pairs.</p>
<pre><code class="language-python">ledger_inclusion_state_dto = {
    'state': str
}
</code></pre>
<h4 id="inforesponse"><a class="header" href="#inforesponse">InfoResponse</a></h4>
<p>A dict with the following key/value pairs.</p>
<pre><code class="language-python">info_response = {
    'name': str,
    'version': str,
    'is_healthy': bool,
    'network_id': str,
    'bech32_hrp': str,
    'min_pow_score': float,
    'messages_per_second': float,
    'referenced_messages_per_second': float,
    'referenced_rate': float,
    'latest_milestone_timestamp': u64,
    'latest_milestone_index': int,
    'confirmed_milestone_index': int,
    'pruning_index': int,
    'features': list[str],
    'min_pow_score': float,
}
</code></pre>
<h4 id="networkinfo-1"><a class="header" href="#networkinfo-1">NetworkInfo</a></h4>
<p>A dict with the following key/value pairs.</p>
<pre><code class="language-python">network_info = {
    'network': str,
    'network_id': int,
    'bech32_hrp': str,
    'min_pow_score': float,
    'local_pow': bool,
    'tips_interval': int,
}
</code></pre>
<h4 id="peerdto"><a class="header" href="#peerdto">PeerDto</a></h4>
<p>A dict with the following key/value pairs.</p>
<pre><code class="language-python">peer_dto = {
    'id': str,
    'multi_addresses': list[str],
    'alias': str, # (optional)
    'relation': RelationDto,
    'connected': bool,
    'gossip': GossipDto, # (optional)
}
</code></pre>
<p>Please refer to <a href="libraries/client-lib/docs/libraries/python/api_reference.html#relationdto">RelationDto</a> and <a href="libraries/client-lib/docs/libraries/python/api_reference.html#gossipdto">GossipDto</a> for the details of these types.</p>
<h4 id="relationdto"><a class="header" href="#relationdto">RelationDto</a></h4>
<p>A dict with the following key/value pairs.</p>
<pre><code class="language-python">relation_dto = {
    'relation': str
}
</code></pre>
<h4 id="gossipdto"><a class="header" href="#gossipdto">GossipDto</a></h4>
<p>A dict with the following key/value pairs.</p>
<pre><code class="language-python">gossip_dto = {
    'heartbeat': HeartbeatDto,
    'metrics': MetricsDto
}
</code></pre>
<p>Please refer to <a href="libraries/client-lib/docs/libraries/python/api_reference.html#heartbeatdto">HeartbeatDto</a> and <a href="libraries/client-lib/docs/libraries/python/api_reference.html#metricsdto">MetricsDto</a> for the details of these types.</p>
<h4 id="heartbeatdto"><a class="header" href="#heartbeatdto">HeartbeatDto</a></h4>
<p>A dict with the following key/value pairs.</p>
<pre><code class="language-python">heart_beat_dto = {
    'solid_milestone_index': int,
    'pruned_milestone_index': int,
    'latest_milestone_index': int,
    'connected_neighbors': int,
    'synced_neighbors': int
}
</code></pre>
<h4 id="metricsdto"><a class="header" href="#metricsdto">MetricsDto</a></h4>
<p>A dict with the following key/value pairs.</p>
<pre><code class="language-python">metrics_dto = {
    'received_messages': int,
    'known_messages': int,
    'received_message_requests': int,
    'received_milestone_requests': int,
    'received_heartbeats': int,
    'sent_messages': int,
    'sent_message_requests': int,
    'sent_milestone_requests': int,
    'sent_heartbeats': int,
    'dropped_packets': int,
}
</code></pre>
<h4 id="addressoutputsoptions"><a class="header" href="#addressoutputsoptions">AddressOutputsOptions</a></h4>
<p>A dict with the following key/value pairs.</p>
<pre><code class="language-python">options = {
    'include_spent': bool,
    'output_type': string
}</code></pre>
<h1 id="troubleshooting-2"><a class="header" href="#troubleshooting-2">Troubleshooting</a></h1>
<h2 id="stackexchange-2"><a class="header" href="#stackexchange-2">StackExchange</a></h2>
<blockquote>
<p><a href="https://iota.stackexchange.com/">https://iota.stackexchange.com</a></p>
</blockquote>
<p>The IOTA StackExchange a a nice tool for developers to find answers for a problem. Just search your problem and find your answer! If there is no one, submit your question and share it in the discussion channel below.</p>
<h2 id="joining-the-discussion-6"><a class="header" href="#joining-the-discussion-6">Joining the discussion</a></h2>
<p>If you want to get involved in discussions about this library, or you're looking for support, go to the #clients-discussion channel on <a href="https://discord.iota.org">Discord</a>.</p>
<h1 id="high-level-api-specification"><a class="header" href="#high-level-api-specification">High Level API Specification</a></h1>
<h2 id="table-of-contents"><a class="header" href="#table-of-contents">Table of Contents</a></h2>
<ul>
<li><a href="libraries/client-lib/docs/specs/index.html#Introduction">Introduction</a></li>
<li><a href="libraries/client-lib/docs/specs/index.html#Builder">Builder</a></li>
<li><a href="libraries/client-lib/docs/specs/index.html#General-high-level-API">General high level API</a>
<ul>
<li><a href="libraries/client-lib/docs/specs/index.html#message"><code>message</code></a></li>
<li><a href="libraries/client-lib/docs/specs/index.html#get_message"><code>get_message</code></a></li>
<li><a href="libraries/client-lib/docs/specs/index.html#find_messages"><code>find_messages</code></a></li>
<li><a href="libraries/client-lib/docs/specs/index.html#get_unspent_address"><code>get_unspent_address</code></a></li>
<li><a href="libraries/client-lib/docs/specs/index.html#get_addresses"><code>get_addresses</code></a></li>
<li><a href="libraries/client-lib/docs/specs/index.html#get_balance"><code>get_balance</code></a></li>
<li><a href="libraries/client-lib/docs/specs/index.html#get_address_balances"><code>get_address_balances</code></a></li>
<li><a href="libraries/client-lib/docs/specs/index.html#bech32_to_hex"><code>bech32_to_hex</code></a></li>
<li><a href="libraries/client-lib/docs/specs/index.html#hex_to_bech32"><code>hex_to_bech32</code></a></li>
<li><a href="libraries/client-lib/docs/specs/index.html#parse_bech32_address"><code>parse_bech32_address</code></a></li>
<li><a href="libraries/client-lib/docs/specs/index.html#is_address_valid"><code>is_address_valid</code></a></li>
<li><a href="libraries/client-lib/docs/specs/index.html#subscriber"><code>subscriber</code></a></li>
<li><a href="libraries/client-lib/docs/specs/index.html#retry"><code>retry</code></a></li>
<li><a href="libraries/client-lib/docs/specs/index.html#retry_until_included"><code>retry_until_included</code></a></li>
<li><a href="libraries/client-lib/docs/specs/index.html#reattach"><code>reattach</code></a></li>
<li><a href="libraries/client-lib/docs/specs/index.html#promote"><code>promote</code></a></li>
</ul>
</li>
<li><a href="libraries/client-lib/docs/specs/index.html#Full-node-API">Full node API</a>
<ul>
<li><a href="libraries/client-lib/docs/specs/index.html#get_health"><code>get_health</code></a></li>
<li><a href="libraries/client-lib/docs/specs/index.html#get_peers"><code>get_health</code></a></li>
<li><a href="libraries/client-lib/docs/specs/index.html#get_info"><code>get_info</code></a></li>
<li><a href="libraries/client-lib/docs/specs/index.html#get_tips"><code>get_tips</code></a></li>
<li><a href="libraries/client-lib/docs/specs/index.html#post_message"><code>post_message</code></a></li>
<li><a href="libraries/client-lib/docs/specs/index.html#get_output"><code>get_output</code></a></li>
<li><a href="libraries/client-lib/docs/specs/index.html#get_address"><code>get_address</code></a></li>
<li><a href="libraries/client-lib/docs/specs/index.html#find_outputs"><code>find_outputs</code></a></li>
<li><a href="libraries/client-lib/docs/specs/index.html#get_milestone"><code>get_milestone</code></a></li>
<li><a href="libraries/client-lib/docs/specs/index.html#get_milestone_utxo_changes"><code>get_milestone_utxo_changes</code></a></li>
<li><a href="libraries/client-lib/docs/specs/index.html#get_receipts"><code>get_receipts</code></a></li>
<li><a href="libraries/client-lib/docs/specs/index.html#get_receipts_migrated_at"><code>get_receipts_migrated_at</code></a></li>
<li><a href="libraries/client-lib/docs/specs/index.html#get_treasury"><code>get_treasury</code></a></li>
<li><a href="libraries/client-lib/docs/specs/index.html#get_included_message"><code>get_included_message</code></a></li>
</ul>
</li>
<li><a href="libraries/client-lib/docs/specs/index.html#Objects">Objects</a>
<ul>
<li>[Network]</li>
<li><a href="libraries/client-lib/docs/specs/index.html#Seed">Seed</a></li>
<li><a href="libraries/client-lib/docs/specs/index.html#Message">Message</a></li>
<li>[Payload]</li>
<li>[Output]</li>
<li><a href="libraries/client-lib/docs/specs/index.html#Address">Address</a></li>
<li><a href="libraries/client-lib/docs/specs/index.html#AddressBalancePair">AddressBalancePair</a></li>
<li><a href="libraries/client-lib/docs/specs/index.html#Milestone">Milestone</a></li>
<li><a href="libraries/client-lib/docs/specs/index.html#Api">API</a></li>
<li><a href="libraries/client-lib/docs/specs/index.html#BrokerOptions">BrokerOptions</a></li>
<li><a href="libraries/client-lib/docs/specs/index.html#Topic">Topic</a></li>
</ul>
</li>
</ul>
<h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>This document specifies a user friendly API to be used in the client libraries. The main implementation will be in Rust which will receive automatically compiled client libraries in other languages via C or Webassembly bindings. There are also many crates to support developers creating foreign function interfaces with native bindings.</p>
<h1 id="builder"><a class="header" href="#builder">Builder</a></h1>
<p>The data structure to initialize the instance of the Higher level client library. This is always called first when starting a new interaction with the library. Note: This is the common approach to do initialization in Rust. Different languages might use different methods such as just calling an initialization function directly.</p>
<h3 id="parameters"><a class="header" href="#parameters">Parameters</a></h3>
<table><thead><tr><th>Parameter</th><th>Required</th><th>Default Value</th><th>Type</th><th>Definition</th></tr></thead><tbody>
<tr><td><strong>network</strong></td><td>✘</td><td>Testnet</td><td>&amp;str</td><td>Optional, the network type can be &quot;testnet&quot; or &quot;mainnet&quot;. If no node url is provided, some default nodes are used for the specified network. Nodes that aren't in this network will be ignored.</td></tr>
<tr><td><strong>node</strong></td><td>✘</td><td>None</td><td>&amp;str</td><td>The URL of a node to connect to; format: <code>https://node:port</code></td></tr>
<tr><td><strong>node_auth</strong></td><td>✘</td><td>None</td><td>&amp;str, &amp;str, &amp;str</td><td>The URL of a node to connect to with name and password for basic authentication; format: <code>https://node:port</code>, <code>name</code>, <code>password</code></td></tr>
<tr><td><strong>nodes</strong></td><td>✘</td><td>None</td><td>&amp;[&amp;str]</td><td>A list of nodes to connect to; nodes are added with the <code>https://node:port</code> format. The amount of nodes specified in quorum_size are randomly selected from this node list to check for quorum based on the quorum threshold. If quorum_size is not given the full list of nodes is checked.</td></tr>
<tr><td><strong>node_sync_interval</strong></td><td>✘</td><td>Duration::from_secs(60)</td><td>std::time::Duration</td><td>The interval in milliseconds to check for node health and sync</td></tr>
<tr><td><strong>node_sync_disabled</strong></td><td>✘</td><td>false</td><td>bool</td><td>If disabled also unhealty nodes will be used</td></tr>
<tr><td><strong>node_pool_urls</strong></td><td>None</td><td>✘</td><td>&amp;[String]</td><td>A list of node_pool_urls from which nodes are added. The amount of nodes specified in quorum_size are randomly selected from this node list to check for quorum based on the quorum threshold. If quorum_size is not given the full list of nodes is checked.</td></tr>
<tr><td><strong>request_timeout</strong></td><td>✘</td><td>Duration::from_secs(30)</td><td>std::time::Duration</td><td>The amount of seconds a request can be outstanding to a node before it's considered timed out</td></tr>
<tr><td><strong>api_timeout</strong></td><td>✘</td><td>Api::GetInfo: Duration::from_secs(2)),<br /> Api::GetHealth: Duration::from_secs(2),<br />Api::GetPeers: Duration::from_secs(2),<br />Api::GetMilestone: Duration::from_secs(2),<br />Api::GetTips: Duration::from_secs(2),<br />Api::PostMessage: Duration::from_secs(2),<br />Api::PostMessageWithRemotePow: Duration::from_secs(30),<br />Api::GetOutput: Duration::from_secs(2)</td><td>HashMap&lt;<a href="libraries/client-lib/docs/specs/index.html#Api">Api</a>,<br /> std::time::Duration&gt;</td><td>The amount of milliseconds a request to a specific Api endpoint can be outstanding to a node before it's considered timed out.</td></tr>
<tr><td><strong>local_pow</strong></td><td>✘</td><td>True</td><td>bool</td><td>If not defined it defaults to local PoW to offload node load times</td></tr>
<tr><td><strong>tips_interval</strong></td><td>✘</td><td>15</td><td>u64</td><td>Time interval during PoW when new tips get requested.</td></tr>
<tr><td><strong>mqtt_broker_options</strong></td><td>✘</td><td>True,<br />Duration::from_secs(30),<br />True</td><td><a href="libraries/client-lib/docs/specs/index.html#BrokerOptions">BrokerOptions</a></td><td>If not defined the default values will be used</td></tr>
</tbody></table>
<ul>
<li>Note that there must be at least one node to build the instance successfully.</li>
</ul>
<h3 id="return"><a class="header" href="#return">Return</a></h3>
<p>Finalize the builder with <code>finish()</code> will run the instance in the background. Users don’t need to worry about the return object handling.</p>
<h2 id="on-initialization"><a class="header" href="#on-initialization">On initialization</a></h2>
<p>On initialisation, call getNodeInfo API. Check the health of each node in the node list, and put healty nodes, matching the PoW settings and network in a synced nodelist.</p>
<table><thead><tr><th>Node metadata</th><th>Description</th></tr></thead><tbody>
<tr><td>network</td><td>If this parameter does not match the global builder parameter, don't add it to the synced nodelist.</td></tr>
<tr><td>pow</td><td>If the global local_pow parameter is set to false, then put only nodes with the PoW feature in the synced nodelist.</td></tr>
</tbody></table>
<h2 id="sync-process"><a class="header" href="#sync-process">Sync Process</a></h2>
<p>When a <code>Client</code> instance (The instance which is used for calling the client APIs) is built, the status of each node listed is checked. If the returned status of the node information is healthy, which means the node is synced, then this node will be pushed into a <code>synced_nodes</code> list. The rust-like pseudo code of <code>synced_nodes</code> construction process follows. The process of syncing a node is repeated every 60 seconds or at the interval specified in the <code>node_sync_interval</code> argument of the initializer if set.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>synced_nodes = Vec::new()
for node in node_pool_urls{
   status = Client.get_info(node).await?;
   if status == healthy{
      synced_nodes.push(node)
   }
}
<span class="boring">}
</span></code></pre></pre>
<h1 id="general-high-level-api"><a class="header" href="#general-high-level-api"><code>General high level API</code></a></h1>
<p>Here is the high level abstraction API collection with sensible default values for users easy to use.</p>
<h2 id="message-2"><a class="header" href="#message-2"><code>message()</code></a></h2>
<p>A generic send function for easily sending a message.</p>
<h3 id="parameters-1"><a class="header" href="#parameters-1">Parameters</a></h3>
<table><thead><tr><th>Parameter</th><th>Required</th><th>Default</th><th>Type</th><th>Definition</th></tr></thead><tbody>
<tr><td><strong>seed</strong></td><td>✘</td><td>None</td><td><a href="libraries/client-lib/docs/specs/index.html#Seed">Seed</a></td><td>The seed of the account we are going to spend, only needed for transactions</td></tr>
<tr><td><strong>account_index</strong></td><td>✘</td><td>0</td><td>usize</td><td>The account index, responsible for the value <code>✘</code> in the Bip32Path <code>m/44'/4218'/✘'/0'/0'</code>.</td></tr>
<tr><td><strong>initial_address_index</strong></td><td>✘</td><td>0</td><td>usize</td><td>The index from where to start looking for balance. Responsible for the value <code>✘</code> in the Bip32Path <code>m/44'/4218'/0'/0'/✘'</code>.</td></tr>
<tr><td><strong>input</strong></td><td>✘</td><td>None</td><td>UtxoInput</td><td>Users can manually select their UtxoInputs instead of having automatically selected inputs.</td></tr>
<tr><td><strong>input_range</strong></td><td>✘</td><td>0..100</td><td>Range</td><td>Custom range to search for the input addresses if custom inputs are provided.</td></tr>
<tr><td><strong>output</strong></td><td>✘</td><td>None</td><td>address: &amp;[String],<br />amount: u64</td><td>Address to send to and amount to send. Address needs to be Bech32 encoded.</td></tr>
<tr><td><strong>output_hex</strong></td><td>✘</td><td>None</td><td>address: &amp;str,<br />amount: u64</td><td>Address to send to and amount to send. Address needs to be hex encoded.</td></tr>
<tr><td><strong>index</strong></td><td>✘</td><td>None</td><td>&amp;[u8] / &amp;str</td><td>An optional indexation key for an indexation payload. 1-64 bytes long.</td></tr>
<tr><td><strong>data</strong></td><td>✘</td><td>None</td><td>Vec<u8></td><td>Optional data for the indexation payload.</td></tr>
<tr><td><strong>parents</strong></td><td>✘</td><td>None</td><td><a href="libraries/client-lib/docs/specs/index.html#MessageId">MessageId</a></td><td>1-8 optional parents <a href="libraries/client-lib/docs/specs/index.html#MessageId">MessageId</a> to be used.</td></tr>
</tbody></table>
<p>Depending on the provided values this function will create a message with:</p>
<ul>
<li>no payload</li>
<li>an indexation payload</li>
<li>a transaction payload</li>
<li>a transaction payload containing an indexation payload</li>
</ul>
<h3 id="return-1"><a class="header" href="#return-1">Return</a></h3>
<p>The <a href="libraries/client-lib/docs/specs/index.html#Message">Message</a> object we build.</p>
<h3 id="implementation-details"><a class="header" href="#implementation-details">Implementation Details</a></h3>
<ul>
<li>Validate inputs, such as address and seed to check if they are correct.</li>
<li>Check if account balance is bigger or equal to the value using method similar to <a href="libraries/client-lib/docs/specs/index.html#get_balance"><code>get_balance()</code></a>;</li>
<li>Build and validate the message with signed transaction payload accordingly;</li>
<li>Get tips using <a href="libraries/client-lib/docs/specs/index.html#get_tips"><code>get_tips()</code></a>;</li>
<li>Perform proof-of-work locally (if not set to remote);</li>
<li>Send the message using <a href="libraries/client-lib/docs/specs/index.html#post_messages"><code>post_messages()</code></a>;</li>
</ul>
<h2 id="get_message"><a class="header" href="#get_message"><code>get_message()</code></a></h2>
<p>(<code>GET /api/v1/messages</code>)</p>
<p>Endpoint collection all about GET messages.</p>
<h3 id="parameters-2"><a class="header" href="#parameters-2">Parameters</a></h3>
<table><thead><tr><th>Parameter</th><th>Required</th><th>Type</th><th>Definition</th></tr></thead><tbody>
<tr><td><strong>message_id</strong></td><td>✔</td><td><a href="libraries/client-lib/docs/specs/index.html#MessageId">MessageId</a></td><td>The identifier of message.</td></tr>
<tr><td><strong>index</strong></td><td>✔</td><td>&amp;[u8] / &amp;str</td><td>An indexation key.</td></tr>
</tbody></table>
<h3 id="returns"><a class="header" href="#returns">Returns</a></h3>
<p>Depend on the final calling method, users could get different results they need:</p>
<ul>
<li><code>metadata(&amp;MessageId)</code>: Return <a href="libraries/client-lib/docs/specs/index.html#MessageMetadata">MessageMetadata</a> of the message.</li>
<li><code>data(&amp;MessageId)</code>: Return a <a href="libraries/client-lib/docs/specs/index.html#Message">Message</a> object.</li>
<li><code>raw(&amp;MessageId)</code>: Return the raw data of given message.</li>
<li><code>children(&amp;MessageId)</code>: Return the list of <a href="libraries/client-lib/docs/specs/index.html#MessageId">MessageId</a>s that reference a message by its identifier.</li>
<li><code>index(&amp;[u8] | &amp;str)</code> : Return the list of <a href="libraries/client-lib/docs/specs/index.html#MessageId">MessageId</a>s that have this str as indexation key</li>
</ul>
<h2 id="find_messages"><a class="header" href="#find_messages"><code>find_messages()</code></a></h2>
<p>Find all messages by provided message IDs.</p>
<h3 id="parameters-3"><a class="header" href="#parameters-3">Parameters</a></h3>
<table><thead><tr><th>Parameter</th><th>Required</th><th>Type</th><th>Definition</th></tr></thead><tbody>
<tr><td><strong>indexation_keys</strong></td><td>✘</td><td>[&amp;[u8] / &amp;str]</td><td>The index key of the indexation payload.</td></tr>
<tr><td><strong>message_ids</strong></td><td>✘</td><td>[<a href="libraries/client-lib/docs/specs/index.html#MessageId">MessageId</a>]</td><td>The identifier of message.</td></tr>
</tbody></table>
<h3 id="returns-1"><a class="header" href="#returns-1">Returns</a></h3>
<p>A vector of <a href="libraries/client-lib/docs/specs/index.html#Message">Message</a> Object.</p>
<h2 id="get_unspent_address"><a class="header" href="#get_unspent_address"><code>get_unspent_address()</code></a></h2>
<p>Return a valid unspent public Bech32 encoded address.</p>
<h3 id="parameters-4"><a class="header" href="#parameters-4">Parameters</a></h3>
<table><thead><tr><th>Parameter</th><th>Required</th><th>Default</th><th>Type</th><th>Definition</th></tr></thead><tbody>
<tr><td><strong>seed</strong></td><td>✔</td><td>-</td><td><a href="libraries/client-lib/docs/specs/index.html#Seed">Seed</a></td><td>The seed we want to use.</td></tr>
<tr><td><strong>account_index</strong></td><td>✘</td><td>0</td><td>usize</td><td>The account index, responsible for the value <code>✘</code> in the Bip32Path <code>m/44'/4218'/✘'/0'/0'</code>.</td></tr>
<tr><td><strong>initial_address_index</strong></td><td>✘</td><td>0</td><td>usize</td><td>Start index of the addresses to search. Responsible for the value <code>✘</code> in the Bip32Path <code>m/44'/4218'/0'/0'/✘'</code>.</td></tr>
</tbody></table>
<h3 id="return-2"><a class="header" href="#return-2">Return</a></h3>
<p>Return a tuple with type of <code>(String, usize)</code> as the address and corresponding index in the account.</p>
<h3 id="implementation-details-1"><a class="header" href="#implementation-details-1">Implementation Details</a></h3>
<p>Following are the steps for implementing this method:</p>
<ul>
<li>Start generating addresses with given account index and starting index. We will have a default <a href="https://blog.blockonomics.co/bitcoin-what-is-this-gap-limit-4f098e52d7e1">gap limit</a> of 20 at a time;</li>
<li>Check for balances on the generated addresses using <a href="libraries/client-lib/docs/specs/index.html#find_outputs"><code>find_outputs()</code></a> and keep track of the positive balances;</li>
<li>Repeat the above step till there's an unspent address found;</li>
<li>Return the address with corresponding index on the wallet chain;</li>
</ul>
<h2 id="get_addresses"><a class="header" href="#get_addresses"><code>get_addresses()</code></a></h2>
<p>Return a list of addresses from the seed regardless of their validity.</p>
<h3 id="parameters-5"><a class="header" href="#parameters-5">Parameters</a></h3>
<table><thead><tr><th>Parameter</th><th>Required</th><th>Default</th><th>Type</th><th>Definition</th></tr></thead><tbody>
<tr><td><strong>seed</strong></td><td>✔</td><td>None</td><td><a href="libraries/client-lib/docs/specs/index.html#Seed">Seed</a></td><td>The seed we want to search for.</td></tr>
<tr><td><strong>account_index</strong></td><td>✘</td><td>0</td><td>usize</td><td>The account index, responsible for the value <code>✘</code> in the Bip32Path <code>m/44'/4218'/✘'/0'/0'</code>.</td></tr>
<tr><td><strong>range</strong></td><td>✘</td><td>None</td><td>std::ops::Range</td><td>Range indices of the addresses we want to search for. Default is (0..20)</td></tr>
<tr><td><strong>get_all</strong></td><td>✘</td><td>✘</td><td>✘</td><td>Get public and <a href="https://bitcoin.stackexchange.com/questions/75033/bip44-and-change-addresses">change addresses</a>. Will return Vec&lt;([String], bool)&gt;, where the bool is indicating whether it's a change address</td></tr>
</tbody></table>
<h3 id="return-3"><a class="header" href="#return-3">Return</a></h3>
<p>Vec&lt;[String]&gt;, with the public addresses</p>
<h2 id="get_balance"><a class="header" href="#get_balance"><code>get_balance()</code></a></h2>
<p>Return the balance for a provided seed and its wallet account index.</p>
<h3 id="parameters-6"><a class="header" href="#parameters-6">Parameters</a></h3>
<table><thead><tr><th>Parameter</th><th>Required</th><th>Default</th><th>Type</th><th>Definition</th></tr></thead><tbody>
<tr><td><strong>seed</strong></td><td>✔</td><td>-</td><td><a href="libraries/client-lib/docs/specs/index.html#Seed">Seed</a></td><td>The seed we want to search for.</td></tr>
<tr><td><strong>account_index</strong></td><td>✘</td><td>0</td><td>usize</td><td>The account index, responsible for the value <code>✘</code> in the Bip32Path <code>m/44'/4218'/✘'/0'/0'</code>.</td></tr>
<tr><td><strong>initial_address_index</strong></td><td>✘</td><td>0</td><td>usize</td><td>Start index from which to generate addresses. Default is 0. Responsible for the value <code>✘</code> in the Bip32Path <code>m/44'/4218'/0'/0'/✘'</code>.</td></tr>
<tr><td><strong>gap_limit</strong></td><td>✘</td><td>20</td><td>usize</td><td>The gap limit specifies how many addresses will be checked each round. If gap_limit amount of addresses in a row have no balance the function will return.</td></tr>
</tbody></table>
<h3 id="return-4"><a class="header" href="#return-4">Return</a></h3>
<p>Total account balance.</p>
<h3 id="implementation-details-2"><a class="header" href="#implementation-details-2">Implementation Details</a></h3>
<p>Following are the steps for implementing this method:</p>
<ul>
<li>Start generating addresses with given wallet account index and starting index. We will have a default <a href="https://blog.blockonomics.co/bitcoin-what-is-this-gap-limit-4f098e52d7e1">gap limit</a> of 20 at a time;</li>
<li>Check for balances on the generated addresses using <a href="libraries/client-lib/docs/specs/index.html#find_outputs"><code>find_outputs()</code></a> and keep track of the positive balances;</li>
<li>Repeat the above step till an address of zero balance is found;</li>
<li>Accumulate the positive balances and return the result.</li>
</ul>
<h2 id="get_address_balances"><a class="header" href="#get_address_balances"><code>get_address_balances()</code></a></h2>
<p>Return the balance in iota for the given addresses; No seed or security level needed to do this since we are only checking and already know the addresses.</p>
<h3 id="parameters-7"><a class="header" href="#parameters-7">Parameters</a></h3>
<table><thead><tr><th>Parameter</th><th>Required</th><th>Type</th><th>Definition</th></tr></thead><tbody>
<tr><td><strong>addresses</strong></td><td>✔</td><td>[[String]]</td><td>List of Bech32 encoded addresses.</td></tr>
</tbody></table>
<h3 id="return-5"><a class="header" href="#return-5">Return</a></h3>
<p>A list of tuples with value of <a href="libraries/client-lib/docs/specs/index.html#AddressBalancePair">AddressBalancePair</a>. The usize is the balance of the address accordingly.</p>
<h3 id="implementation-details-3"><a class="header" href="#implementation-details-3">Implementation details:</a></h3>
<p>Following are the steps for implementing this method:</p>
<ul>
<li>Validate <em>address</em> semantics;</li>
<li>Get latest balance for the provided address using <a href="libraries/client-lib/docs/specs/index.html#find_outputs"><code>find_outputs()</code></a> with addresses as parameter;</li>
<li>Return the list of Output which contains corresponding pairs of address and balance.</li>
</ul>
<h2 id="bech32_to_hex"><a class="header" href="#bech32_to_hex"><code>bech32_to_hex()</code></a></h2>
<p>Returns a parsed hex String from bech32.</p>
<h3 id="parameters-8"><a class="header" href="#parameters-8">Parameters</a></h3>
<table><thead><tr><th>Parameter</th><th>Required</th><th>Type</th><th>Definition</th></tr></thead><tbody>
<tr><td><strong>bech32</strong></td><td>✔</td><td>[String]</td><td>Bech32 encoded address.</td></tr>
</tbody></table>
<h3 id="return-6"><a class="header" href="#return-6">Return</a></h3>
<p>Parsed [String].</p>
<h2 id="hex_to_bech32"><a class="header" href="#hex_to_bech32"><code>hex_to_bech32()</code></a></h2>
<p>Returns a parsed bech32 String from hex.</p>
<h3 id="parameters-9"><a class="header" href="#parameters-9">Parameters</a></h3>
<table><thead><tr><th>Parameter</th><th>Required</th><th>Type</th><th>Definition</th></tr></thead><tbody>
<tr><td><strong>hex</strong></td><td>✔</td><td>[String]</td><td>Hex encoded address.</td></tr>
<tr><td><strong>bech32_hrp</strong></td><td>✔</td><td>[Option<String>]</td><td>Optional bech32 hrp.</td></tr>
</tbody></table>
<h3 id="return-7"><a class="header" href="#return-7">Return</a></h3>
<p>Parsed [String].</p>
<h2 id="parse_bech32_address"><a class="header" href="#parse_bech32_address"><code>parse_bech32_address()</code></a></h2>
<p>Returns a valid Address parsed from a String.</p>
<h3 id="parameters-10"><a class="header" href="#parameters-10">Parameters</a></h3>
<table><thead><tr><th>Parameter</th><th>Required</th><th>Type</th><th>Definition</th></tr></thead><tbody>
<tr><td><strong>address</strong></td><td>✔</td><td>[String]</td><td>Bech32 encoded address.</td></tr>
</tbody></table>
<h3 id="return-8"><a class="header" href="#return-8">Return</a></h3>
<p>Parsed <a href="libraries/client-lib/docs/specs/index.html#Address">Address</a>.</p>
<h2 id="is_address_valid"><a class="header" href="#is_address_valid"><code>is_address_valid()</code></a></h2>
<h3 id="parameters-11"><a class="header" href="#parameters-11">Parameters</a></h3>
<table><thead><tr><th>Parameter</th><th>Required</th><th>Type</th><th>Definition</th></tr></thead><tbody>
<tr><td><strong>address</strong></td><td>✔</td><td>[String]</td><td>Bech32 encoded address.</td></tr>
</tbody></table>
<h3 id="return-9"><a class="header" href="#return-9">Return</a></h3>
<p>A boolean showing if the address is valid.</p>
<h2 id="subscriber"><a class="header" href="#subscriber"><code>subscriber()</code></a></h2>
<p>Subscribe to a node event <a href="libraries/client-lib/docs/specs/index.html#Topic">Topic</a> (MQTT)</p>
<p>Required: one of</p>
<ul>
<li>
<p><code>topic()</code>: Add a new <a href="libraries/client-lib/docs/specs/index.html#Topic">Topic</a> to the list.</p>
</li>
<li>
<p><code>topics()</code>: Add a vector of <a href="libraries/client-lib/docs/specs/index.html#Topic">Topic</a> to the list.</p>
</li>
<li>
<p><code>subscribe()</code>: Subscribe to the given topics with the callback, which will be called every time when the topic is detected.</p>
</li>
<li>
<p><code>unsubscribe()</code>: Unsubscribes from all subscriptions.</p>
</li>
<li>
<p><code>disconnect()</code>: Disconnects the broker. This will clear the stored topic handlers and close the MQTT connection.</p>
</li>
</ul>
<h3 id="returns-2"><a class="header" href="#returns-2">Returns</a></h3>
<p>Nothing apart from a Ok(()) result if successful</p>
<h2 id="retry"><a class="header" href="#retry"><code>retry()</code></a></h2>
<p>Retries (promotes or reattaches) a message for provided <a href="libraries/client-lib/docs/specs/index.html#MessageId">MessageId</a> if the node suggests it. The need to use this function should be low, because the confirmation throughput of the node is expected to be quite high.</p>
<h3 id="parameters-12"><a class="header" href="#parameters-12">Parameters</a></h3>
<table><thead><tr><th>Parameter</th><th>Required</th><th>Type</th><th>Definition</th></tr></thead><tbody>
<tr><td><strong>message_id</strong></td><td>✔</td><td><a href="libraries/client-lib/docs/specs/index.html#MessageId">MessageId</a></td><td>The identifier of message.</td></tr>
</tbody></table>
<h3 id="returns-3"><a class="header" href="#returns-3">Returns:</a></h3>
<p>A tuple with the newly promoted or reattached <code>(MessageId,  Message)</code>.</p>
<h3 id="implementation-details-4"><a class="header" href="#implementation-details-4">Implementation Details</a></h3>
<p>Following are the steps for implementing this method:</p>
<ul>
<li>Only unconfirmed messages should be allowed to retry. The method should validate the confirmation state of the provided messages. If a message id of a confirmed message is provided, the method should error out;</li>
<li>The method should also validate if a retry is necessary. This can be done by leveraging the <code>/messages/{messageId}/metadata</code> endpoint (already available through <a href="libraries/client-lib/docs/specs/index.html#get_message">get_message</a>). See <a href="https://github.com/iotaledger/trinity-wallet/blob/develop/src/shared/libs/iota/transfers.js#L105-L131">this</a> implementation for reference;</li>
<li>Use <a href="libraries/client-lib/docs/specs/index.html#reattach">reattach</a> or <a href="libraries/client-lib/docs/specs/index.html#promote">promote</a> accordingly.</li>
</ul>
<h2 id="retry_until_included"><a class="header" href="#retry_until_included"><code>retry_until_included()</code></a></h2>
<p>Retries (promotes or reattaches) a message for provided <a href="libraries/client-lib/docs/specs/index.html#MessageId">MessageId</a> until it's included (referenced by a milestone). Default interval is 5 seconds and max attempts is 10. The need to use this function should be low, because the confirmation throughput of the node is expected to be quite high.</p>
<h3 id="parameters-13"><a class="header" href="#parameters-13">Parameters</a></h3>
<table><thead><tr><th>Parameter</th><th>Required</th><th>Type</th><th>Definition</th></tr></thead><tbody>
<tr><td><strong>message_id</strong></td><td>✔</td><td>[&amp;MessageId]</td><td>The identifier of message.</td></tr>
<tr><td><strong>interval</strong></td><td>✘</td><td>Option<u64></td><td>The interval in which we retry the message.</td></tr>
<tr><td><strong>max_attempts</strong></td><td>✘</td><td>Option<u64></td><td>The maximum of attempts we retry the message.</td></tr>
</tbody></table>
<h3 id="returns-4"><a class="header" href="#returns-4">Returns:</a></h3>
<p>An array of tuples with the newly reattached <code>(MessageId,  Message)</code>.</p>
<h2 id="reattach"><a class="header" href="#reattach"><code>reattach()</code></a></h2>
<p>Depends on <a href="libraries/client-lib/docs/specs/index.html#find_messages">find_messages</a>, <a href="libraries/client-lib/docs/specs/index.html#get_message">get_message</a> and <a href="libraries/client-lib/docs/specs/index.html#post_message">post_message</a>.</p>
<p>Reattaches a message. The method should validate if a reattachment is necessary through <a href="libraries/client-lib/docs/specs/index.html#get_message">get_message</a>. If not, the method should error out and should not allow unnecessary reattachments.</p>
<h3 id="parameters-14"><a class="header" href="#parameters-14">Parameters</a></h3>
<table><thead><tr><th>Parameter</th><th>Required</th><th>Type</th><th>Definition</th></tr></thead><tbody>
<tr><td><strong>message_id</strong></td><td>✔</td><td><a href="libraries/client-lib/docs/specs/index.html#MessageId">MessageId</a></td><td>The identifier of message.</td></tr>
</tbody></table>
<h3 id="returns-5"><a class="header" href="#returns-5">Returns</a></h3>
<p>A tuple with the newly reattached <code>(MessageId,  Message)</code>.</p>
<h2 id="promote"><a class="header" href="#promote"><code>promote()</code></a></h2>
<p>Depends on <a href="libraries/client-lib/docs/specs/index.html#find_messages">find_messages</a>, <a href="libraries/client-lib/docs/specs/index.html#get_message">get_message</a> and <a href="libraries/client-lib/docs/specs/index.html#post_message">post_message</a>.</p>
<p>Promotes a message. The method should validate if a promotion is necessary through <a href="libraries/client-lib/docs/specs/index.html#get_message">get_message</a>. If not, the method should error out and should not allow unnecessary promotions.</p>
<h3 id="parameters-15"><a class="header" href="#parameters-15">Parameters</a></h3>
<table><thead><tr><th>Parameter</th><th>Required</th><th>Type</th><th>Definition</th></tr></thead><tbody>
<tr><td><strong>message_id</strong></td><td>✔</td><td><a href="libraries/client-lib/docs/specs/index.html#MessageId">MessageId</a></td><td>The identifier of message.</td></tr>
</tbody></table>
<h3 id="returns-6"><a class="header" href="#returns-6">Returns</a></h3>
<p>A tuple with the newly promoted <code>(MessageId,  Message)</code>.</p>
<h1 id="full-node-api"><a class="header" href="#full-node-api">Full node API</a></h1>
<p>Full node API of Bee and HORNET will still be public. Users who know these relative low level Restful API can still call them directly if they are confident and think it’s good for them. Note that both Bee and HORNET haven't finalized their APIs either. Following items and signatures might change later.</p>
<h2 id="get_health"><a class="header" href="#get_health"><code>get_health()</code></a></h2>
<p>(<code>GET /health</code>)</p>
<p>Returns the health of the node, which can be used for load-balancing or uptime monitoring.</p>
<h3 id="parameters-16"><a class="header" href="#parameters-16">Parameters</a></h3>
<p>None</p>
<h3 id="returns-7"><a class="header" href="#returns-7">Returns</a></h3>
<p>Boolean to indicate if node is healthy.</p>
<h2 id="get_peers"><a class="header" href="#get_peers"><code>get_peers()</code></a></h2>
<p>(<code>GET /peers</code>)</p>
<p>Get information about the peers of the node.</p>
<h3 id="parameters-17"><a class="header" href="#parameters-17">Parameters</a></h3>
<p>None</p>
<h3 id="returns-8"><a class="header" href="#returns-8">Returns</a></h3>
<pre><code class="language-Rust">pub struct PeerDto {
    pub id: String,
    #[serde(rename = &quot;multiAddresses&quot;)]
    pub multi_addresses: Vec&lt;String&gt;,
    pub alias: Option&lt;String&gt;,
    pub relation: RelationDto,
    pub connected: bool,
    pub gossip: Option&lt;GossipDto&gt;,
}
</code></pre>
<h2 id="get_info"><a class="header" href="#get_info"><code>get_info()</code></a></h2>
<p>(<code>GET /api/v1/info</code>)</p>
<p>Returns information about the node.</p>
<h3 id="parameters-18"><a class="header" href="#parameters-18">Parameters</a></h3>
<p>None</p>
<h3 id="returns-9"><a class="header" href="#returns-9">Returns</a></h3>
<p>A Response Object similar to this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct NodeInfo {
    pub name: String,
    pub version: String,
    pub is_healthy: bool,
    pub network_id: String,
    pub latest_milestone_index: usize,
    pub min_pow_score: f64,
    pub messages_per_second: f64,
    pub referenced_messages_per_second: f64,
    pub referenced_rate: f64,
    pub latest_milestone_timestamp: u64,
    pub confirmed_milestone_index: usize,
    pub pruning_index: usize,
    pub features: Vec&lt;String&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="get_tips"><a class="header" href="#get_tips"><code>get_tips()</code></a></h2>
<p>(<code>GET /tips</code>)</p>
<p>Returns two non-lazy tips. In case the node can only provide one tip, tip1 and tip2 are identical.</p>
<h3 id="parameters-19"><a class="header" href="#parameters-19">Parameters</a></h3>
<p>None</p>
<h3 id="returns-10"><a class="header" href="#returns-10">Returns</a></h3>
<p>A tuple with two <a href="libraries/client-lib/docs/specs/index.html#MessageId">MessageId</a>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>(MessageId, MessageId)
<span class="boring">}
</span></code></pre></pre>
<h2 id="post_message"><a class="header" href="#post_message"><code>post_message()</code></a></h2>
<p>(<code>POST /message</code>)</p>
<p>Submit a message. The node takes care of missing fields and tries to build the message. On success, the message will be stored in the Tangle. This endpoint will return the identifier of the message.</p>
<h3 id="parameters-20"><a class="header" href="#parameters-20">Parameters</a></h3>
<table><thead><tr><th>Parameter</th><th>Required</th><th>Type</th><th>Definition</th></tr></thead><tbody>
<tr><td><strong>message</strong></td><td>✔</td><td><a href="libraries/client-lib/docs/specs/index.html#Message">Message</a></td><td>The message object.</td></tr>
</tbody></table>
<h3 id="returns-11"><a class="header" href="#returns-11">Returns</a></h3>
<p>The <a href="libraries/client-lib/docs/specs/index.html#MessageId">MessageId</a> of the message object.</p>
<h2 id="get_output"><a class="header" href="#get_output"><code>get_output()</code></a></h2>
<p>(<code>GET /outputs</code>)</p>
<p>Get the producer of the output, the corresponding address, amount and spend status of an output. This information can only be retrieved for outputs which are part of a confirmed transaction.</p>
<h3 id="parameters-21"><a class="header" href="#parameters-21">Parameters</a></h3>
<table><thead><tr><th>Parameter</th><th>Required</th><th>Type</th><th>Definition</th></tr></thead><tbody>
<tr><td><strong>output_id</strong></td><td>✔</td><td>UtxoInput</td><td>Identifier of the output.</td></tr>
</tbody></table>
<h3 id="returns-12"><a class="header" href="#returns-12">Returns</a></h3>
<p>An <a href="libraries/client-lib/docs/specs/index.html#OutputMetadata">OutputMetadata</a> that contains various information about the output.</p>
<h2 id="get_address"><a class="header" href="#get_address"><code>get_address()</code></a></h2>
<p>(<code>GET /addresses</code>)</p>
<h3 id="parameters-22"><a class="header" href="#parameters-22">Parameters</a></h3>
<table><thead><tr><th>Parameter</th><th>Required</th><th>Type</th><th>Definition</th></tr></thead><tbody>
<tr><td><strong>address</strong></td><td>✔</td><td>[String]</td><td>The address to search for.</td></tr>
</tbody></table>
<h3 id="returns-13"><a class="header" href="#returns-13">Returns</a></h3>
<p>Depend on the final calling method, users could get different outputs they need:</p>
<ul>
<li><code>balance()</code>: Return confirmed balance of the address.</li>
<li><code>outputs([options])</code>: Return UtxoInput array (transaction IDs with corresponding output index).</li>
</ul>
<h2 id="find_outputs"><a class="header" href="#find_outputs"><code>find_outputs()</code></a></h2>
<p>Find all outputs based on the requests criteria.</p>
<h3 id="parameters-23"><a class="header" href="#parameters-23">Parameters</a></h3>
<table><thead><tr><th>Parameter</th><th>Required</th><th>Type</th><th>Definition</th></tr></thead><tbody>
<tr><td><strong>output_id</strong></td><td>✘</td><td>[UtxoInput]</td><td>The identifier of output.</td></tr>
<tr><td><strong>addresses</strong></td><td>✘</td><td>[[String]]</td><td>The Bech32 encoded address.</td></tr>
</tbody></table>
<h3 id="returns-14"><a class="header" href="#returns-14">Returns</a></h3>
<p>A vector of <a href="libraries/client-lib/docs/specs/index.html#OutputMetadata">OutputMetadata</a>.</p>
<h2 id="get_milestone"><a class="header" href="#get_milestone"><code>get_milestone()</code></a></h2>
<p>(<code>GET /milestones</code>)</p>
<p>Get the milestone by the given index.</p>
<h3 id="parameters-24"><a class="header" href="#parameters-24">Parameters</a></h3>
<table><thead><tr><th>Parameter</th><th>Required</th><th>Type</th><th>Definition</th></tr></thead><tbody>
<tr><td><strong>index</strong></td><td>✔</td><td>u32</td><td>Index of the milestone.</td></tr>
</tbody></table>
<h3 id="returns-15"><a class="header" href="#returns-15">Returns</a></h3>
<p>An <a href="libraries/client-lib/docs/specs/index.html#Milestone">Milestone</a> object.</p>
<h2 id="get_milestone_utxo_changes"><a class="header" href="#get_milestone_utxo_changes"><code>get_milestone_utxo_changes()</code></a></h2>
<p>(<code>GET /milestones/{}/utxo-changes</code>)</p>
<p>Get all UTXO changes of a given milestone.</p>
<h3 id="parameters-25"><a class="header" href="#parameters-25">Parameters</a></h3>
<table><thead><tr><th>Parameter</th><th>Required</th><th>Type</th><th>Definition</th></tr></thead><tbody>
<tr><td><strong>index</strong></td><td>✔</td><td>u32</td><td>Index of the milestone.</td></tr>
</tbody></table>
<h3 id="returns-16"><a class="header" href="#returns-16">Returns</a></h3>
<pre><code class="language-Rust">MilestoneUTXOChanges {
    index: 1,
    created_outputs: [],
    consumed_outputs: [],
}
</code></pre>
<h2 id="get_receipts"><a class="header" href="#get_receipts"><code>get_receipts()</code></a></h2>
<p>(<code>GET /receipts</code>)</p>
<p>Get all receipts.</p>
<h3 id="returns-17"><a class="header" href="#returns-17">Returns</a></h3>
<pre><code class="language-Rust">Vec&lt;ReceiptDto&gt;
</code></pre>
<h2 id="get_receipts_migrated_at"><a class="header" href="#get_receipts_migrated_at"><code>get_receipts_migrated_at()</code></a></h2>
<p>(<code>GET /receipts/{migratedAt}</code>)</p>
<p>Get all receipts for a given milestone index.</p>
<h3 id="returns-18"><a class="header" href="#returns-18">Returns</a></h3>
<pre><code class="language-Rust">Vec&lt;ReceiptDto&gt;
</code></pre>
<h2 id="get_treasury"><a class="header" href="#get_treasury"><code>get_treasury()</code></a></h2>
<p>(<code>GET /treasury</code>)</p>
<p>Get the treasury amount.</p>
<h3 id="returns-19"><a class="header" href="#returns-19">Returns</a></h3>
<pre><code class="language-Rust">pub struct TreasuryResponse {
    #[serde(rename = &quot;milestoneId&quot;)]
    milestone_id: String,
    amount: u64,
}
</code></pre>
<h2 id="get_included_message"><a class="header" href="#get_included_message"><code>get_included_message()</code></a></h2>
<p>(<code>GET /transactions/{transactionId}/included-message</code>)</p>
<p>Get the included message of the transaction.</p>
<h3 id="parameters-26"><a class="header" href="#parameters-26">Parameters</a></h3>
<table><thead><tr><th>Parameter</th><th>Required</th><th>Type</th><th>Definition</th></tr></thead><tbody>
<tr><td><strong>transaction_id</strong></td><td>✔</td><td>[TransactionId]</td><td>The id of the transaction.</td></tr>
</tbody></table>
<h3 id="returns-20"><a class="header" href="#returns-20">Returns</a></h3>
<pre><code class="language-Rust">struct Message {
    parents: Vec&lt;MessageId&gt;,
    payload: Option&lt;Payload&gt;,
    nonce: u64,
}
</code></pre>
<h1 id="objects"><a class="header" href="#objects">Objects</a></h1>
<p>Here are the objects used in the API above. They aim to provide a secure way to handle certain data structures specified in the Iota stack.</p>
<h2 id="messageid"><a class="header" href="#messageid"><code>MessageId</code></a></h2>
<p>MessageId is a 32 bytes array which can represent as hex string.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct MessageId([u8; MESSAGE_ID_LENGTH]);
<span class="boring">}
</span></code></pre></pre>
<h2 id="seed-1"><a class="header" href="#seed-1"><code>Seed</code></a></h2>
<pre><code class="language-Rust">pub enum Seed {
    /// Ed25519 variant
    Ed25519(Ed25519Seed)
}
</code></pre>
<p>An IOTA seed that inner structure is omitted. Users can create this type by passing a String. It will verify and return an error if it’s not valid. |</p>
<h2 id="message-3"><a class="header" href="#message-3"><code>Message</code></a></h2>
<p>The message object returned by various functions; based on the <a href="https://github.com/GalRogozinski/protocol-rfcs/blob/message/text/0017-message/0017-message.md">RFC</a> for the Message object. Here's the brief overview of each components in Message type would look like:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Message {
    parents: Vec&lt;MessageId&gt;,
    payload: Option&lt;Payload&gt;,
    nonce: u64,
}

enum Payload {
    Transaction(Box&lt;Transaction&gt;),
    Milestone(Box&lt;Milestone&gt;),
    Indexation(Box&lt;Indexation&gt;),
}

struct Transaction {
    pub essence: TransactionPayloadEssence,
    pub unlock_blocks: Vec&lt;UnlockBlock&gt;,
}

struct Milestone {
    essence: MilestoneEssence,
    signatures: Vec&lt;Box&lt;[u8]&gt;&gt;,
}

struct Indexation {
    index: String,
    data: Box&lt;[u8]&gt;,
}

struct TransactionPayloadEssence {
    pub(crate) inputs: Box&lt;[Input]&gt;,
    pub(crate) outputs: Box&lt;[Output]&gt;,
    pub(crate) payload: Option&lt;Payload&gt;,
}

enum Input {
    UTXO(UtxoInput(OutputId)),
}

struct OutputId {
    transaction_id: TransactionId,
    index: u16,
}

enum Output {
    SignatureLockedSingle(SignatureLockedSingleOutput),
}

struct SignatureLockedSingleOutput {
    address: Address,
    amount: u64,
}

enum UnlockBlock {
    Signature(SignatureUnlock),
    Reference(ReferenceUnlock),
}

enum SignatureUnlock {
    Ed25519(Ed25519Signature),
}

struct Ed25519Signature {
    public_key: [u8; 32],
    signature: Box&lt;[u8]&gt;,
}

struct ReferenceUnlock(u16);
<span class="boring">}
</span></code></pre></pre>
<h2 id="messagemetadata-1"><a class="header" href="#messagemetadata-1"><code>MessageMetadata</code></a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct MessageMetadata {
    /// Message ID
    pub message_id: String,
    /// Message IDs of parents
    pub parents: Vec&lt;String&gt;,
    /// Solid status
    pub is_solid: bool,
    /// Should promote
    pub should_promote: Option&lt;bool&gt;,
    /// Should reattach
    pub should_reattach: Option&lt;bool&gt;,
    /// Referenced by milestone index
    pub referenced_by_milestone_index: Option&lt;u32&gt;,
    /// Ledger inclusion state
    pub ledger_inclusion_state: Option&lt;String&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="outputmetadata-1"><a class="header" href="#outputmetadata-1"><code>OutputMetadata</code></a></h2>
<p>The metadata of an output:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct OutputMetadata {
    /// Message ID of the output
    pub message_id: Vec&lt;u8&gt;,
    /// Transaction ID of the output
    pub transaction_id: Vec&lt;u8&gt;,
    /// Output index.
    pub output_index: u16,
    /// Spend status of the output
    pub is_spent: bool,
    /// Corresponding address
    pub address: Address,
    /// Balance amount
    pub amount: u64,
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="address-1"><a class="header" href="#address-1"><code>Address</code></a></h2>
<p>An Ed25519 address can be encoded in Bech32 or Hex, with Bech32 being preferred and also used in most functions.</p>
<pre><code class="language-Rust">pub enum Address {
    Ed25519(Ed25519Address),
}
</code></pre>
<h2 id="addressbalancepair-1"><a class="header" href="#addressbalancepair-1"><code>AddressBalancePair</code></a></h2>
<pre><code class="language-Rust">pub struct AddressBalancePair {
    /// Address, bech32 encoded
    pub address: String,
    /// Balance in the address
    pub balance: u64,
}
</code></pre>
<h2 id="milestone-1"><a class="header" href="#milestone-1"><code>Milestone</code></a></h2>
<p>A milestone metadata.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct MilestoneMetadata {
    /// Milestone index
    pub milestone_index: u32,
    /// Milestone ID
    pub message_id: String,
    /// Timestamp
    pub timestamp: u64,
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="api"><a class="header" href="#api"><code>Api</code></a></h2>
<pre><code class="language-Rust">pub enum Api {
    /// `get_health` API
    GetHealth,
    /// `get_info`API
    GetInfo,
    /// `get_tips` API
    GetTips,
    /// `post_message` API
    PostMessage,
    /// `post_message` API with remote pow
    PostMessageWithRemotePow,
    /// `get_output` API
    GetOutput,
    /// `get_milestone` API
    GetMilestone,
}
</code></pre>
<h2 id="brokeroptions-2"><a class="header" href="#brokeroptions-2"><code>BrokerOptions</code></a></h2>
<pre><code class="language-Rust">pub struct BrokerOptions {
    #[serde(default = &quot;default_broker_automatic_disconnect&quot;, rename = &quot;automaticDisconnect&quot;)]
    pub(crate) automatic_disconnect: bool,
    #[serde(default = &quot;default_broker_timeout&quot;)]
    pub(crate) timeout: std::time::Duration,
    #[serde(rename = &quot;maxReconnectionAttempts&quot;, default)]
    pub(crate) max_reconnection_attempts: usize,
}
</code></pre>
<h2 id="topic"><a class="header" href="#topic"><code>Topic</code></a></h2>
<p>A string with the exact MQTT topic to monitor, can have one of the following variations:</p>
<pre><code>milestones/latest
milestones/confirmed

messages
messages/referenced
messages/indexation/{index}
messages/{messageId}/metadata
transactions/{transactionId}/included-message

outputs/{outputId}

addresses/{address}/outputs
addresses/ed25519/{address}/outputs
</code></pre>
<h1 id="contribute-to-the-project"><a class="header" href="#contribute-to-the-project">Contribute to the project</a></h1>
<p><strong>Thanks for thinking about contributing to the project! We have the following ways that you can contribute.</strong></p>
<h2 id="join-the-iota-libraries-initiative"><a class="header" href="#join-the-iota-libraries-initiative">Join the IOTA Libraries Initiative</a></h2>
<p>The <a href="https://github.com/iota-community/X-Team_IOTA_Libraries">IOTA Libraries Initiative</a> is a collaborative effort to help improve the developer experience.</p>
<ul>
<li>Quality assurance and review</li>
<li>Documentation</li>
<li>Code samples</li>
</ul>
<p>If you'd like to get involved, join the #experience channel on <a href="https://discord.iota.org">Discord</a>.</p>
<h2 id="contribute-to-the-projects-github-repository"><a class="header" href="#contribute-to-the-projects-github-repository">Contribute to the project's GitHub repository</a></h2>
<p>All the code is open source and hosted on <a href="https://github.com/iotaledger/iota.rs">GitHub</a> where you can do the following:</p>
<ul>
<li>Report a bug</li>
<li>Suggest a new feature</li>
<li>Contribute to the documentation</li>
</ul>
<h2 id="contribute-to-the-documentation"><a class="header" href="#contribute-to-the-documentation">Contribute to the documentation</a></h2>
<p>This documentation is also open source and hosted on GitHub.</p>
<p>If you want to contribute new documentation or fix an error, see the <a href="https://github.com/iotaledger/documentation/blob/develop/.github/CONTRIBUTING.md">contribution guidelines</a>.</p>
<h2 id="share-your-knowledge"><a class="header" href="#share-your-knowledge">Share your knowledge</a></h2>
<p>Helping others is an important part of any open source ecosystem.</p>
<p>By sharing your knowledge with others, you can provide a lot of value to the community and maybe inspire someone else to learn and contribute.</p>
<p>Take a look at what discussions are going on in the #clients-discussion channel on <a href="https://discord.iota.org">Discord</a>.</p>
<p>Thanks :heart:</p>
<h1 id="welcome-2"><a class="header" href="#welcome-2">Welcome</a></h1>
<p>This is the documentation for the official IOTA Wallet Library Software. It can be used to easily integrate an IOTA Wallet into your applications. You can read more about core principles behind IOTA client libraries in the following blog <a href="https://blog.iota.org/the-new-iota-client-libraries-harder-better-faster-stronger/">post</a>.</p>
<p><code>Wallet.rs</code> is a general wallet library written in Rust. It is being utilized by our wallet software <code>Firefly</code> and other software components across IOTA ecosystem. <code>Wallet.rs</code> contains all the logic to safely build wallets or integrations that require value-based transfers (such as exchanges, pay-as-you-go systems, etc.). It includes account state management and backup, account creation, transferring tokens and much more. Needless to say, it is also based on our official <code>one-source-code-of-truth</code> <a href="https://github.com/iotaledger/iota.rs">IOTA Rust library</a> and can be integrated with the <a href="https://blog.iota.org/iota-stronghold-6ce55d311d7c/">Stronghold enclave</a> to achieve a maximum level of security.</p>
<blockquote>
<p>Using <code>stronghold</code> is a recommended approach to store account data using <code>wallet.rs</code>. The best security practices are integrated for free </p>
</blockquote>
<p>With the <code>wallet.rs</code> library, developers do not need to use a self-generated seed anymore. By default, the seed is created and stored in Stronghold encrypted at rest. It is not possible to extract the seed from Stronghold for security purposes. Stronghold uses encrypted snapshots that can easily be backed up and securely shared between devices. These snapshots are further secured with a password.</p>
<h2 id="iota-15-chrysalis-in-a-nutshell-1"><a class="header" href="#iota-15-chrysalis-in-a-nutshell-1">IOTA 1.5 (Chrysalis) in a nutshell</a></h2>
<ul>
<li>IOTA network uses a DAG (Directed Acyclic Graph) to store its transactions. Each transaction can reference up to 8 parent transactions</li>
<li>There is a breaking change moving from IOTA 1.0 to IOTA 1.5 (Chrysalis). IOTA address was originally based on WOTS signature scheme (81 trytes) and it has been replaced by a Ed25519 signature scheme</li>
<li>In contrast to IOTA 1.0, IOTA 1.5 addresses are perfectly reusable: so even if one spent funds from the given address it can be used again</li>
<li>There are new client libraries developed in rust, specifically <code>iota.rs</code>, <code>wallet.rs</code> and <code>stronghold.rs</code> that serve as <code>one-source-code-of-truth</code> to IOTA users and providing binding to other programming languages </li>
</ul>
<h3 id="iota-15-address-anatomy-2"><a class="header" href="#iota-15-address-anatomy-2">IOTA 1.5 address anatomy</a></h3>
<p>IOTA address is based on Ed25519 signature scheme and it is usually represented by Bech32 (checksummed base32) format string of 64 characters:</p>
<table>
    <thead>
        <tr>
            <th colspan=4><center>iota11qykf7rrdjzhgynfkw6z7360avhaaywf5a4vtyvvk6a06gcv5y7sksu7n5cs</center></th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan=4><center>three distinguished parts</center></td>
        </tr>
        <tr>
            <td><center><strong>human-readable id</strong></center></td>
            <td><center><strong>separator</strong></center></td>
            <td><center><strong>data</strong></center></td>
            <td><center><strong>checksum</strong></center></td>
        </tr>
        <tr>
            <td><center>iota | atoi</center></td>
            <td><center>1</center></td>
            <td><center>48 bytes [0..9a..z]</center></td>
            <td><center>6 characters [0..9a..z]</center></td>
        </tr>
        <tr>
            <td><center>iota</center></td>
            <td><center>1</center></td>
            <td><center>1qykf7rrdjzhgynfkw6z7360avhaaywf5a4vtyvvk6a06gcv5y7sks</center></td>
            <td><center>u7n5cs</center></td>
        </tr>
        <tr>
            <td colspan=4>iota = mainnet; atoi = testnet</td>
        </tr>
    </tbody>
</table>
<p>More details: <a href="https://github.com/iotaledger/protocol-rfcs/pull/20">RFC: Bech32 Address Format</a></p>
<h2 id="warning-4"><a class="header" href="#warning-4">Warning</a></h2>
<p>This library is in active development. The library targets the Chrysalis testnet and does not work with current IOTA mainnet.</p>
<h2 id="testnet-2"><a class="header" href="#testnet-2">Testnet</a></h2>
<p>To join the Chrysalis public testnet checkout <a href="https://blog.iota.org/chrysalis-phase-2-testnet-out-now/">this link</a>. More information about Chrysalis components is available at <a href="https://chrysalis.docs.iota.org/">documentation portal</a>.</p>
<h2 id="joining-the-discussion-7"><a class="header" href="#joining-the-discussion-7">Joining the discussion</a></h2>
<p>If you want to get involved in discussions about this library, or you're looking for support, go to the #clients-discussion channel on <a href="https://discord.iota.org">Discord</a>.</p>
<h2 id="what-you-will-find-here-1"><a class="header" href="#what-you-will-find-here-1">What you will find here</a></h2>
<p>This documentation has five paths:</p>
<ol>
<li>The Overview, an detailed overview of the wallet library. </li>
<li>Libraries, all avaiable programming languages and their resources.</li>
<li>The Specification, detailed explaination requirements and functionality.</li>
<li>Contribute, how you can work on the wallet software.</li>
<li>Get in touch, join the community and become part of the X-Team!</li>
</ol>
<h1 id="overview-4"><a class="header" href="#overview-4">Overview</a></h1>
<p>The wallet library is a stateful package with a standardized interface for developers to build applications involving IOTA value transactions. It provides abstractions to handle IOTA payments and can optionally interact with <a href="https://github.com/iotaledger/stronghold.rs/">IOTA Stronghold enclave</a> for seed handling, seed storage and state backup. </p>
<p>See the full specification <a href="https://github.com/iotaledger/wallet.rs/blob/master/specs/wallet-ENGINEERING-SPEC-0000.md">here</a>.</p>
<h2 id="high-level-layered-overview-1"><a class="header" href="#high-level-layered-overview-1">High level layered overview:</a></h2>
<p><img src="libraries/wallet-lib/docs/overview/iota_layers_overview.svg" alt="iota layers overview" /></p>
<h1 id="iota-wallet-libraries"><a class="header" href="#iota-wallet-libraries">IOTA Wallet Libraries</a></h1>
<p>There are currently available the following official bindings to <code>wallet.rs</code>:</p>
<ul>
<li><a href="libraries/wallet-lib/docs/libraries/./rust/">Rust</a> </li>
<li><a href="libraries/wallet-lib/docs/libraries/./nodejs/">Node.js</a> </li>
<li><a href="libraries/wallet-lib/docs/libraries/./python/">Python</a></li>
</ul>
<h2 id="getting-started-1"><a class="header" href="#getting-started-1">Getting Started</a></h2>
<p>It is a recommended approach to start your interactions with IOTA on a <code>testnet</code> network.  API load balancer: api.lb-0.testnet.chrysalis2.com</p>
<p>Network explorer is available at <a href="https://explorer.iota.org/chrysalis">IOTA Tangle Explorer</a>.</p>
<p>In order to properly test value-based transactions on testnet network, you are going to need some tokens! You can get some testnet tokens using the <a href="https://faucet.testnet.chrysalis2.com/">faucet</a>.</p>
<h2 id="the-library-in-a-nutshell"><a class="header" href="#the-library-in-a-nutshell">The library in a nutshell</a></h2>
<p>In the <code>wallet.rs</code>, we use an account model, so you can create an account for each of your users. The other approach would be to use one account and generate many addresses, which you can link to your users in your database. The library allows users to assign a meaningful alias to each account. It also leaves the choice to users if they want to segregate their funds across multiple accounts or multiple addresses. So basically it is up to a developer to decide whether <code>single-account approach</code> or <code>multi-account approach</code> is chosen. The library provides a support to any of the scenarios.</p>
<p>The library is based on a derivation for multiple accounts from a single seed. An account is simply a deterministic identifier from which multiple addresses can be further derived. The following illustrates the relationships between seed, accounts and addresses:</p>
<p><img src="libraries/wallet-lib/docs/libraries/accounts_addresses.svg" alt="accounts" /></p>
<h1 id="iota-wallet-rust-library"><a class="header" href="#iota-wallet-rust-library">IOTA Wallet Rust Library</a></h1>
<p><a href="https://github.com/iotaledger/wallet.rs"><img src="https://img.shields.io/badge/Status-Alpha-yellow.svg" alt="status" /></a></p>
<h2 id="warning-5"><a class="header" href="#warning-5">Warning</a></h2>
<p>This library is in active development. The library targets the Chrysalis testnet and does not work with current IOTA mainnet.</p>
<h2 id="joining-the-discussion-8"><a class="header" href="#joining-the-discussion-8">Joining the discussion</a></h2>
<p>If you want to get involved in discussions about this library, or you're looking for support, go to the #clients-discussion channel on <a href="https://discord.iota.org">Discord</a>.</p>
<h2 id="overview-5"><a class="header" href="#overview-5">Overview</a></h2>
<ul>
<li><a href="libraries/wallet-lib/docs/libraries/rust/">Getting Started with wallet.rs</a></li>
<li><a href="libraries/wallet-lib/docs/libraries/rust/">Examples</a></li>
<li><a href="libraries/wallet-lib/docs/libraries/rust/">API Reference</a></li>
<li><a href="libraries/wallet-lib/docs/libraries/rust/">Troubleshooting</a></li>
</ul>
<h1 id="getting-started-with-rust-1"><a class="header" href="#getting-started-with-rust-1">Getting Started with Rust</a></h1>
<h2 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h2>
<p><code>Rust</code> and <code>Cargo</code> are required. Install them <a href="https://doc.rust-lang.org/cargo/getting-started/installation.html">here</a>.</p>
<p>We recommend you update Rust to the latest stable version <a href="https://github.com/rust-lang/rustup.rs#keeping-rust-up-to-date"><code>rustup update stable</code></a>. Nightly should be fine but there's a chance some changes are not compatible.</p>
<p><code>no_std</code> is not supported currently, but we are working on it, and will provide it as a feature once the new implementation is ready.</p>
<h3 id="dependencies"><a class="header" href="#dependencies">Dependencies</a></h3>
<p><code>cmake</code> and <code>openssl</code> are required. In order to run the build process succesfully using Cargo you might need install additional build tools on your system. </p>
<h3 id="windows"><a class="header" href="#windows">Windows</a></h3>
<p><code>cmake</code> can be downloaded on the <a href="https://cmake.org/download/">official website</a> and <code>openssl</code> can be installed with <a href="https://github.com/microsoft/vcpkg">vcpkg</a> or <a href="https://chocolatey.org/">chocolatey</a>.</p>
<ul>
<li>Installing <code>openssl</code> with <code>vcpkg</code>:</li>
</ul>
<pre><code>$ ./vcpkg.exe install openssl:x64-windows
$ ./vcpkg.exe integrate install
# you may want to add this to the system environment variables since you'll need it to compile the crate
$ set VCPKGRS_DYNAMIC=1
</code></pre>
<ul>
<li>Installing <code>openssl</code> with <code>chocolatey</code>:</li>
</ul>
<pre><code>$ choco install openssl
# you may need to set the OPENSSL_ROOT_DIR environment variable
$ set OPENSSL_ROOT_DIR=&quot;C:\Program Files\OpenSSL-Win64&quot;
</code></pre>
<h3 id="macos"><a class="header" href="#macos">macOS</a></h3>
<p><code>cmake</code> and <code>openssl</code> can be installed with <code>Homebrew</code>:</p>
<pre><code>$ brew install cmake
$ brew install openssl@1.1
# you may want to add this to your .zshrc or .bashrc since you'll need it to compile the crate
$ OPENSSL_ROOT_DIR=$(brew --prefix openssl@1.1)
</code></pre>
<h3 id="linux"><a class="header" href="#linux">Linux</a></h3>
<p>Install <code>cmake</code> and <code>openssl</code> with your distro's package manager or download from their websites. On Debian and Ubuntu you will also need <code>build-essential</code>.</p>
<h2 id="usage-1"><a class="header" href="#usage-1">Usage</a></h2>
<p>To use the library, add this to your <code>Cargo.toml</code>:</p>
<pre><code>[dependencies]
iota-wallet = { git = &quot;https://github.com/iotaledger/wallet.rs&quot; }
</code></pre>
<h3 id="initialisation-1"><a class="header" href="#initialisation-1">Initialisation</a></h3>
<p>In order to use the library you first need to create an <code>AccountManager</code>:</p>
<pre><pre class="playground"><code class="language-rust">use iota_wallet::{
    account_manager::AccountManager, client::ClientOptionsBuilder, signing::SignerType,
};
use std::path::PathBuf;

#[tokio::main]
async fn main() -&gt; iota_wallet::Result&lt;()&gt; {
    let storage_folder: PathBuf = &quot;./my-db&quot;.into();
    let manager =
        AccountManager::builder()
            .with_storage(&amp;storage_folder, None)
            .finish()
            .await?;
    let client_options = ClientOptionsBuilder::new().with_node(&quot;http://api.lb-0.testnet.chrysalis2.com&quot;)?.build();
    let account = manager
        .create_account(client_options)
        .signer_type(SignerType::EnvMnemonic)
        .initialise()
        .await?;
    Ok(())
}
</code></pre></pre>
<h1 id="examples-3"><a class="header" href="#examples-3">Examples</a></h1>
<p>You can see the examples in the <a href="libraries/wallet-lib/docs/libraries/rust/examples/">examples</a> directory and try them with:</p>
<pre><code>cargo run --example # lists the available examples
cargo run --example transfer # execute the `transfer` example
</code></pre>
<h2 id="backup-and-restore-example"><a class="header" href="#backup-and-restore-example">Backup and restore example</a></h2>
<p>Create an account manager and set an password:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut manager = AccountManager::builder().finish().await.unwrap();

manager.set_stronghold_password(&quot;password&quot;).await.unwrap();
manager.store_mnemonic(SignerType::Stronghold, None).await.unwrap();

<span class="boring">}
</span></code></pre></pre>
<p>Create your account:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let client_options = ClientOptionsBuilder::new()
    .with_node(&quot;https://api.lb-0.testnet.chrysalis2.com&quot;)?
    .build()
    .unwrap();
let account_handle = manager
    .create_account(client_options)?
    .alias(&quot;alias&quot;)
    .initialise()
    .await?;
let id = account_handle.id().await;

<span class="boring">}
</span></code></pre></pre>
<p>Now you can secure your account in a backup file:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// backup the stored accounts to ./backup/${backup_name}
let backup_path = manager.backup(&quot;./backup&quot;).await?;

<span class="boring">}
</span></code></pre></pre>
<p>You can import the backup later or by another application like here:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>manager.import_accounts(backup_path, &quot;password&quot;).await?;

let imported_account_handle = manager.get_account(&amp;id).await?;

let account = account_handle.read().await;
let imported_account = imported_account_handle.read().await;

<span class="boring">}
</span></code></pre></pre>
<p>That's it! Now you know, how do backup and restore your account!</p>
<p>See the full example <a href="https://github.com/iotaledger/wallet.rs/blob/develop/examples/backup_and_restore.rs">here</a></p>
<h1 id="api-reference-4"><a class="header" href="#api-reference-4">API Reference</a></h1>
<p>Link to hosted api documentation: TODO</p>
<p>If you'd like to explore the implementation in more depth, the following command generates docs for the whole crate:</p>
<pre><code>cargo doc --document-private-items --no-deps --open
</code></pre>
<h1 id="troubleshooting-3"><a class="header" href="#troubleshooting-3">Troubleshooting</a></h1>
<h2 id="stackexchange-3"><a class="header" href="#stackexchange-3">StackExchange</a></h2>
<blockquote>
<p><a href="https://iota.stackexchange.com/">https://iota.stackexchange.com</a></p>
</blockquote>
<p>The IOTA StackExchange a a nice Tool for developers to find  Answers for a problem. Just search your problem and find your answer! If there is no one, submit your question and share it in the discussion channel below.</p>
<h2 id="joining-the-discussion-9"><a class="header" href="#joining-the-discussion-9">Joining the discussion</a></h2>
<p>If you want to get involved in discussions about this library, or you're looking for support, go to the #clients-discussion channel on <a href="https://discord.iota.org">Discord</a>.</p>
<h1 id="iota-wallet-nodejs-library"><a class="header" href="#iota-wallet-nodejs-library">IOTA Wallet Node.js Library</a></h1>
<p><a href="https://github.com/iotaledger/wallet.rs"><img src="https://img.shields.io/badge/Status-Alpha-yellow.svg" alt="status" /></a></p>
<h2 id="warning-6"><a class="header" href="#warning-6">Warning</a></h2>
<p>This library is in active development. The library targets the Chrysalis testnet and does not work with current IOTA mainnet.</p>
<h2 id="joining-the-discussion-10"><a class="header" href="#joining-the-discussion-10">Joining the discussion</a></h2>
<p>If you want to get involved in discussions about this library, or you're looking for support, go to the #clients-discussion channel on <a href="https://discord.iota.org">Discord</a>.</p>
<h2 id="overview-6"><a class="header" href="#overview-6">Overview</a></h2>
<ul>
<li><a href="libraries/wallet-lib/docs/libraries/nodejs/./getting_started.html">Getting Started with wallet and node.js</a></li>
<li><a href="libraries/wallet-lib/docs/libraries/nodejs/./examples.html">Examples</a></li>
<li><a href="libraries/wallet-lib/docs/libraries/nodejs/./api_reference.html">API Reference</a></li>
<li><a href="libraries/wallet-lib/docs/libraries/nodejs/./troubleshooting.html">Troubleshooting</a></li>
</ul>
<h1 id="getting-started-with-nodejs-1"><a class="header" href="#getting-started-with-nodejs-1">Getting Started with Node.js</a></h1>
<p>The <a href="https://www.npmjs.com/package/@iota/wallet">IOTA Wallet Node.js binding</a> is published on npmjs.org.</p>
<h2 id="installation-2"><a class="header" href="#installation-2">Installation</a></h2>
<p>Currently the package isn't published so you'd need to link it to your project using <code>npm</code> or <code>yarn</code>.</p>
<ul>
<li>Using NPM:</li>
</ul>
<pre><code>$ npm install @iota/wallet
</code></pre>
<ul>
<li>Using yarn: </li>
</ul>
<pre><code>$ yarn install @iota/wallet
</code></pre>
<h2 id="usage-2"><a class="header" href="#usage-2">Usage</a></h2>
<pre><code class="language-javascript">/**
 * This example creates a new database and account
 */

require('dotenv').config()

async function run() {
    const { AccountManager, SignerType } = require('@iota/wallet')
    const manager = new AccountManager({
        storagePath: './alice-database',
    })
    manager.setStrongholdPassword(process.env.SH_PASSWORD)
    manager.storeMnemonic(SignerType.Stronghold)

    const account = await manager.createAccount({
        clientOptions: { node: &quot;https://api.lb-0.testnet.chrysalis2.com&quot;, localPow: true },
        alias: 'Alice',
    })

    console.log('Account created:', account.alias())
      
}

run()
</code></pre>
<h1 id="examples-4"><a class="header" href="#examples-4">Examples</a></h1>
<p>There are several examples to show the usage of the library.</p>
<blockquote>
<p>All examples can be found in <a href="https://github.com/iotaledger/wallet.rs/bindings/nodejs/examples/">/bindings/nodejs/examples</a></p>
</blockquote>
<h2 id="setup"><a class="header" href="#setup">Setup</a></h2>
<p>First, setup your environment as follows:</p>
<pre><code>git clone https://github.com/iotaledger/wallet.rs
cd bindings/node/examples
npm install # or `yarn`
cp .env.example .env
</code></pre>
<p>Add your custom password to the <code>.env</code> file.</p>
<h2 id="1-example-create-an-account"><a class="header" href="#1-example-create-an-account">1. Example: Create an Account</a></h2>
<p>Run:</p>
<pre><code>node 1-create-account.js
</code></pre>
<p>Code:</p>
<pre><code class="language-javascript">/**
 * This example creates a new database and account
 */

require('dotenv').config()

async function run() {
    const { AccountManager, SignerType } = require('@iota/wallet')
    const manager = new AccountManager({
        storagePath: './alice-database',
    })
    manager.setStrongholdPassword(process.env.SH_PASSWORD)
    manager.storeMnemonic(SignerType.Stronghold)

    const account = await manager.createAccount({
        clientOptions: { node: &quot;https://api.lb-0.testnet.chrysalis2.com&quot;, localPow: true },
        alias: 'Alice',
    })

    console.log('Account created:', account.alias())
      
}

run()
</code></pre>
<h2 id="2-generate-address"><a class="header" href="#2-generate-address">2. Generate Address</a></h2>
<p>Run:</p>
<pre><code>node 2-generate-address.js
</code></pre>
<p>Code:</p>
<pre><code class="language-javascript">/**
 * This example genrates a new address.
 */

require('dotenv').config()

async function run() {
	const { AccountManager } = require('@iota/wallet')
    const manager = new AccountManager({
        storagePath: './alice-database'
    })

    manager.setStrongholdPassword(process.env.SH_PASSWORD)

    const account = manager.getAccount('Alice')
    console.log('Account:', account.alias())

    // Always sync before doing anything with the account
    const synced = await account.sync()
    console.log('Syncing...')

    const { address } = account.generateAddress()
    console.log('New address:', address)

    // You can also get the latest unused address:
    // const addressObject = account.latestAddress()
    // console.log(&quot;Address:&quot;, addressObject.address)

    // Use the Chrysalis Faucet to send testnet tokens to your address:
    console.log(&quot;Fill your address with the Faucet: https://faucet.testnet.chrysalis2.com/&quot;)
}

run()
</code></pre>
<h2 id="3-example-check-balance"><a class="header" href="#3-example-check-balance">3. Example: Check Balance</a></h2>
<p>Run:</p>
<pre><code>node 3-check_balance
</code></pre>
<p>Code:</p>
<pre><code class="language-javascript">/**
 * This example creates a new database and account
 */

require('dotenv').config()

async function run() {
	const { AccountManager } = require('@iota/wallet')
    const manager = new AccountManager({
        storagePath: './alice-database'
    })

    manager.setStrongholdPassword(process.env.SH_PASSWORD)

    const account = manager.getAccount('Alice')
    
    console.log('Account:', account.alias())
    
    // Always sync before doing anything with the account
    const synced = await account.sync()
    console.log('Syncing...')

    console.log('Available balance', account.balance().available)
}

run()
</code></pre>
<h2 id="4-example-check-balance"><a class="header" href="#4-example-check-balance">4. Example: Check Balance</a></h2>
<p>Now you can send the test tokens to an address! </p>
<p>Run</p>
<pre><code>node 4-send.js
</code></pre>
<p>Code:</p>
<pre><code class="language-javascript">/**
 * This example sends IOTA Toens to an address.
 */

 require('dotenv').config();

async function run() {
	const { AccountManager } = require('@iota/wallet')
    const manager = new AccountManager({
        storagePath: './alice-database'
    })

    manager.setStrongholdPassword(process.env.SH_PASSWORD)

    const account = manager.getAccount('Alice')
    
    console.log('alias', account.alias())
    console.log('syncing...')
    const synced = await account.sync()
    console.log('available balance', account.balance().available)
    
    //TODO: Replace with the address of your choice!
	const addr = 'atoi1qykf7rrdjzhgynfkw6z7360avhaaywf5a4vtyvvk6a06gcv5y7sksu7n5cs'
	const amount = 10000000

	const node_response = await synced.send(
		addr,
		amount
    ) 

    console.log(`Check your message on https://explorer.iota.org/chrysalis/message/${node_response.id}`)
}

run()
</code></pre>
<h2 id="5-backup"><a class="header" href="#5-backup">5. Backup</a></h2>
<p>Run</p>
<pre><code>node 5-backup.js
</code></pre>
<p>Code:</p>
<pre><code class="language-javascript">/**
 * This example backups your data in a secure file. 
 * You can move this file to another app or device and restore it.
 */

require('dotenv').config();

async function run() {

    const { AccountManager } = require('@iota/wallet')
    const manager = new AccountManager({
        storagePath: './alice-database'
    })

    manager.setStrongholdPassword(process.env.SH_PASSWORD)

    let backup_path = await manager.backup(&quot;./backup&quot;)
    
    console.log('Backup path:', backup_path)
}

run()
</code></pre>
<h2 id="6-restore"><a class="header" href="#6-restore">6. Restore</a></h2>
<p>Run</p>
<pre><code>node 6-restore.js
</code></pre>
<p>Code:</p>
<pre><code class="language-javascript">/**
 * This example restores a secured backup file. 
 */

require('dotenv').config();

async function run() {

    const { AccountManager } = require('@iota/wallet')
    const manager = new AccountManager({
        storagePath: './alice-database'
    })

    // Add the path to the file from example 5-backup.js
    // for example: ./backup/2021-02-12T01-23-11-iota-wallet-backup-wallet.stronghold
    let backup_path = &quot;input your backup file&quot;

    await manager.importAccounts(backup_path, process.env.SH_PASSWORD)
    const account = manager.getAccount('Alice')
    console.log('Account:', account.alias())
}

run()
</code></pre>
<h2 id="7-events"><a class="header" href="#7-events">7. Events</a></h2>
<p>Run</p>
<pre><code>node 7-events.js
</code></pre>
<p>Code:</p>
<pre><code class="language-javascript">/**
 * This example shows some events.
 */

require('dotenv').config()

async function run() {
	const { AccountManager, addEventListener } = require('@iota/wallet')
    const manager = new AccountManager({
        storagePath: './alice-database'
    })

    manager.setStrongholdPassword(process.env.SH_PASSWORD)

    const account = manager.getAccount('Alice')
    console.log('Account:', account.alias())

    // Always sync before doing anything with the account
    const synced = await account.sync()
    console.log('Syncing...')
    // let address = account.generateAddress()
    
    // get latest address
    let addressObject = account.latestAddress()

    console.log(&quot;Address:&quot;, addressObject.address)
    
    // Use the Chrysalis Faucet to send testnet tokens to your address:
    console.log(&quot;Fill your address with the Faucet: https://faucet.testnet.chrysalis2.com/&quot;)


    const callback = function(data) {
        console.log(&quot;data:&quot;, data)
    }

    addEventListener(&quot;BalanceChange&quot;, callback)

    // Possible Event Types:
    //
    // ErrorThrown
    // BalanceChange
    // NewTransaction
    // ConfirmationStateChange
    // Reattachment
    // Broadcast
}

run()
</code></pre>
<h1 id="api-reference-5"><a class="header" href="#api-reference-5">API Reference</a></h1>
<h3 id="initloggerconfig-logoptions"><a class="header" href="#initloggerconfig-logoptions">initLogger(config: LogOptions)</a></h3>
<p>Initializes the logging system.</p>
<h4 id="logoptions"><a class="header" href="#logoptions">LogOptions</a></h4>
<table><thead><tr><th>Param</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td>color_enabled</td><td><code>boolean</code></td><td><code>undefined</code></td><td>Whether to enable colored output or not</td></tr>
<tr><td>outputs</td><td><code>LogOutput[]</code></td><td><code>undefined</code></td><td>The log outputs</td></tr>
</tbody></table>
<h4 id="logoutput"><a class="header" href="#logoutput">LogOutput</a></h4>
<table><thead><tr><th>Param</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td>name</td><td><code>string</code></td><td><code>undefined</code></td><td>'stdout' or a path to a file</td></tr>
<tr><td>level_filter</td><td><code>string</code></td><td><code>'info'</code></td><td>The maximum log level that this output accepts</td></tr>
<tr><td>target_filters</td><td><code>string[]</code></td><td><code>[]</code></td><td>Filters on the log target (library and module names)</td></tr>
</tbody></table>
<h3 id="addeventlistenerevent-cb"><a class="header" href="#addeventlistenerevent-cb">addEventListener(event, cb)</a></h3>
<p>Adds a new event listener with a callback in the form of <code>(err, data) =&gt; {}</code>.
Supported event names:</p>
<ul>
<li>ErrorThrown</li>
<li>BalanceChange</li>
<li>NewTransaction</li>
<li>ConfirmationStateChange</li>
<li>Reattachment</li>
<li>Broadcast</li>
<li>TransferProgress</li>
</ul>
<h3 id="accountmanager"><a class="header" href="#accountmanager">AccountManager</a></h3>
<h4 id="constructoroptions"><a class="header" href="#constructoroptions">constructor([options])</a></h4>
<p>Creates a new instance of the AccountManager.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td>[options]</td><td><code>object</code></td><td><code>undefined</code></td><td>The options to configure the account manager</td></tr>
<tr><td>[storagePath]</td><td><code>string</code></td><td><code>undefined</code></td><td>The path where the database file will be saved</td></tr>
<tr><td>[storagePassword]</td><td><code>string</code></td><td><code>undefined</code></td><td>The storage password</td></tr>
<tr><td>[outputConsolidationThreshold]</td><td><code>number</code></td><td><code>100</code></td><td>The number of outputs an address must have to trigger the automatic consolidation process</td></tr>
<tr><td>[automaticOutputConsolidation]</td><td><code>boolean</code></td><td><code>true</code></td><td>Disables the automatic output consolidation if false</td></tr>
<tr><td>[syncSpentOutputs]</td><td><code>boolean</code></td><td><code>false</code></td><td>Enables fetching spent output history on account sync</td></tr>
<tr><td>[persistEvents]</td><td><code>boolean</code></td><td><code>false</code></td><td>Enables event persistence</td></tr>
<tr><td>[allowCreateMultipleEmptyAccounts]</td><td><code>boolean</code></td><td>code<false></td><td>Enables creating accounts with latest account being empty</td></tr>
</tbody></table>
<h4 id="setstrongholdpasswordpassword-void"><a class="header" href="#setstrongholdpasswordpassword-void">setStrongholdPassword(password): void</a></h4>
<p>Sets the stronghold password and initialises it.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td>password</td><td><code>string</code></td><td><code>undefined</code></td><td>The stronghold snapshot password</td></tr>
</tbody></table>
<h4 id="changestrongholdpasswordcurrentpassword-newpassword-void"><a class="header" href="#changestrongholdpasswordcurrentpassword-newpassword-void">changeStrongholdPassword(currentPassword, newPassword): void</a></h4>
<p>Changes the stronghold password.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td>currentPassword</td><td><code>string</code></td><td><code>undefined</code></td><td>The current stronghold password</td></tr>
<tr><td>newPassword</td><td><code>string</code></td><td><code>undefined</code></td><td>The new stronghold password</td></tr>
</tbody></table>
<h4 id="createaccountaccount-account"><a class="header" href="#createaccountaccount-account">createAccount(account): Account</a></h4>
<p>Creates a new account.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td>account</td><td><code>object</code></td><td><code>{}</code></td><td>The account to be created</td></tr>
<tr><td>account.clientOptions</td><td><code><a href="libraries/wallet-lib/docs/libraries/nodejs/api_reference.html#clientoptions">ClientOptions</a></code></td><td><code>undefined</code></td><td>The node configuration</td></tr>
<tr><td>[account.mnemonic]</td><td><code>string</code></td><td><code>undefined</code></td><td>The account BIP39 mnemonic</td></tr>
<tr><td>[account.alias]</td><td><code>string</code></td><td><code>Account ${index + 1}</code></td><td>The account alias</td></tr>
<tr><td>[account.createdAt]</td><td><code>string</code></td><td>the current date and time</td><td>The ISO 8601 date string of the account creation</td></tr>
<tr><td>[account.signerType]</td><td><code>number</code></td><td>1 = Stronghold</td><td>The account signer type. 1 = Stronghold, 2 = EnvMnemonic</td></tr>
</tbody></table>
<h4 id="getaccountaccountid"><a class="header" href="#getaccountaccountid">getAccount(accountId)</a></h4>
<p>Gets the account with the given identifier or index.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td>accountId</td><td><code>string | number</code></td><td><code>null</code></td><td>The account identifier or account index</td></tr>
</tbody></table>
<p><strong>Returns</strong> the associated Account instance or undefined if the account wasn't found.</p>
<h4 id="getaccountbyaliasalias"><a class="header" href="#getaccountbyaliasalias">getAccountByAlias(alias)</a></h4>
<p>Gets the account with the given alias (case insensitive).</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td>alias</td><td><code>string</code></td><td><code>null</code></td><td>The account alias</td></tr>
</tbody></table>
<p><strong>Returns</strong> the associated Account instance or undefined if the account wasn't found.</p>
<h4 id="getaccounts"><a class="header" href="#getaccounts">getAccounts()</a></h4>
<p>Gets all stored accounts.</p>
<p><strong>Returns</strong> an array of <a href="libraries/wallet-lib/docs/libraries/nodejs/api_reference.html#account">Account objects</a>.</p>
<h4 id="removeaccountaccountid"><a class="header" href="#removeaccountaccountid">removeAccount(accountId)</a></h4>
<p>Removes the account with the given identifier or index.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td>accountId</td><td><code>string | number</code></td><td><code>null</code></td><td>The account identifier or account index</td></tr>
</tbody></table>
<h4 id="syncaccountsoptions"><a class="header" href="#syncaccountsoptions">syncAccounts([options])</a></h4>
<p>Synchronize all stored accounts with the Tangle.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td>[options]</td><td><code>object</code></td><td><code>{}</code></td><td>The sync options</td></tr>
<tr><td>[options.addressIndex]</td><td><code>number</code></td><td><code>latest address index</code></td><td>The index of the first account address to sync</td></tr>
<tr><td>[options.gapLimit]</td><td><code>number</code></td><td><code>10</code></td><td>The number of addresses to check on each account sync</td></tr>
</tbody></table>
<p><strong>Returns</strong> A promise resolving to an array of <a href="libraries/wallet-lib/docs/libraries/nodejs/api_reference.html#syncedaccount">SyncedAccount</a>.</p>
<h4 id="internaltransferfromaccount-toaccount-amount"><a class="header" href="#internaltransferfromaccount-toaccount-amount">internalTransfer(fromAccount, toAccount, amount)</a></h4>
<p>Transfers an amount from one subaccount to another.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td>fromAccount</td><td><code><a href="libraries/wallet-lib/docs/libraries/nodejs/api_reference.html#account">Account</a></code></td><td><code>null</code></td><td>The source account</td></tr>
<tr><td>toAccount</td><td><code><a href="libraries/wallet-lib/docs/libraries/nodejs/api_reference.html#account">Account</a></code></td><td><code>null</code></td><td>The destination account</td></tr>
<tr><td>amount</td><td><code>number</code></td><td><code>undefined</code></td><td>The transfer amount</td></tr>
</tbody></table>
<p><strong>Returns</strong> A promise resolving to the transfer's Message.</p>
<h4 id="backupdestination-password"><a class="header" href="#backupdestination-password">backup(destination, password)</a></h4>
<p>Backups the database.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td>destination</td><td><code>string</code></td><td><code>undefined</code></td><td>The path to the backup file</td></tr>
<tr><td>password</td><td><code>string</code></td><td><code>undefined</code></td><td>The backup stronghold password</td></tr>
</tbody></table>
<p><strong>Returns</strong> The full path to the backup file.</p>
<h4 id="importaccountssource"><a class="header" href="#importaccountssource">importAccounts(source)</a></h4>
<p>Imports a database file.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td>source</td><td><code>string</code></td><td><code>undefined</code></td><td>The path to the backup file</td></tr>
<tr><td>password</td><td><code>string</code></td><td><code>undefined</code></td><td>The backup stronghold password</td></tr>
</tbody></table>
<h4 id="islatestaddressunused"><a class="header" href="#islatestaddressunused">isLatestAddressUnused()</a></h4>
<p>Determines whether all accounts has unused latest address after syncing with the Tangle.</p>
<p><strong>Returns</strong> A promise resolving to the boolean value.</p>
<h4 id="setclientoptionsoptions"><a class="header" href="#setclientoptionsoptions">setClientOptions(options)</a></h4>
<p>Updates the client options for all accounts.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td>options</td><td><code><a href="libraries/wallet-lib/docs/libraries/nodejs/api_reference.html#clientoptions">ClientOptions</a></code></td><td><code>null</code></td><td>The new account client options</td></tr>
</tbody></table>
<h4 id="generatemigrationaddressaddress"><a class="header" href="#generatemigrationaddressaddress">generateMigrationAddress(address)</a></h4>
<p>Convert a Ed25519 to a Tryte migration address with checksum (last 9 Trytes)</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td>address</td><td><code>string</code></td><td><code>null</code></td><td>Bech32 encoded Ed25519 address</td></tr>
</tbody></table>
<h4 id="getbalancechangeeventscount-skip-fromtimestamp"><a class="header" href="#getbalancechangeeventscount-skip-fromtimestamp">getBalanceChangeEvents([count, skip, fromTimestamp])</a></h4>
<p>Gets the persisted balance change events.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td>[count]</td><td><code>number</code></td><td><code>0</code></td><td>The number of events to return (<code>0</code> to return all)</td></tr>
<tr><td>[skip]</td><td><code>number</code></td><td><code>0</code></td><td>The number of events to skip</td></tr>
<tr><td>[fromTimestamp]</td><td><code>number</code></td><td><code>null</code></td><td>Filter events that were stored after the given UTC timestamp</td></tr>
</tbody></table>
<p>Event object: { indexationId: string, accountId: string, address: string, message?: string, balanceChange: { spent: number, received: number } }</p>
<h4 id="getbalancechangeeventcountfromtimestamp"><a class="header" href="#getbalancechangeeventcountfromtimestamp">getBalanceChangeEventCount([fromTimestamp])</a></h4>
<p>Gets the number of persisted balance change events.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td>[fromTimestamp]</td><td><code>number</code></td><td><code>null</code></td><td>Filter events that were stored after the given UTC timestamp</td></tr>
</tbody></table>
<h4 id="gettransactionconfirmationeventscount-skip-fromtimestamp"><a class="header" href="#gettransactionconfirmationeventscount-skip-fromtimestamp">getTransactionConfirmationEvents([count, skip, fromTimestamp])</a></h4>
<p>Gets the persisted transaction confirmation change events.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td>[count]</td><td><code>number</code></td><td><code>0</code></td><td>The number of events to return (<code>0</code> to return all)</td></tr>
<tr><td>[skip]</td><td><code>number</code></td><td><code>0</code></td><td>The number of events to skip</td></tr>
<tr><td>[fromTimestamp]</td><td><code>number</code></td><td><code>null</code></td><td>Filter events that were stored after the given UTC timestamp</td></tr>
</tbody></table>
<p>Event object: { indexationId: string, accountId: string, message: Message, confirmed: boolean }</p>
<h4 id="gettransactionconfirmationeventcountfromtimestamp"><a class="header" href="#gettransactionconfirmationeventcountfromtimestamp">getTransactionConfirmationEventCount([fromTimestamp])</a></h4>
<p>Gets the number of persisted transaction confirmation change events.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td>[fromTimestamp]</td><td><code>number</code></td><td><code>null</code></td><td>Filter events that were stored after the given UTC timestamp</td></tr>
</tbody></table>
<h4 id="getnewtransactioneventscount-skip-fromtimestamp"><a class="header" href="#getnewtransactioneventscount-skip-fromtimestamp">getNewTransactionEvents([count, skip, fromTimestamp])</a></h4>
<p>Gets the persisted new transaction events.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td>[count]</td><td><code>number</code></td><td><code>0</code></td><td>The number of events to return (<code>0</code> to return all)</td></tr>
<tr><td>[skip]</td><td><code>number</code></td><td><code>0</code></td><td>The number of events to skip</td></tr>
<tr><td>[fromTimestamp]</td><td><code>number</code></td><td><code>null</code></td><td>Filter events that were stored after the given UTC timestamp</td></tr>
</tbody></table>
<p>Event object: { indexationId: string, accountId: string, message: Message }</p>
<h4 id="getnewtransactioneventcountfromtimestamp"><a class="header" href="#getnewtransactioneventcountfromtimestamp">getNewTransactionEventCount([fromTimestamp])</a></h4>
<p>Gets the number of persisted new transaction events.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td>[fromTimestamp]</td><td><code>number</code></td><td><code>null</code></td><td>Filter events that were stored after the given UTC timestamp</td></tr>
</tbody></table>
<h4 id="getreattachmenteventscount-skip-fromtimestamp"><a class="header" href="#getreattachmenteventscount-skip-fromtimestamp">getReattachmentEvents([count, skip, fromTimestamp])</a></h4>
<p>Gets the persisted transaction reattachment events.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td>[count]</td><td><code>number</code></td><td><code>0</code></td><td>The number of events to return (<code>0</code> to return all)</td></tr>
<tr><td>[skip]</td><td><code>number</code></td><td><code>0</code></td><td>The number of events to skip</td></tr>
<tr><td>[fromTimestamp]</td><td><code>number</code></td><td><code>null</code></td><td>Filter events that were stored after the given UTC timestamp</td></tr>
</tbody></table>
<p>Event object: { indexationId: string, accountId: string, message: Message }</p>
<h4 id="getreattachmenteventcountfromtimestamp"><a class="header" href="#getreattachmenteventcountfromtimestamp">getReattachmentEventCount([fromTimestamp])</a></h4>
<p>Gets the number of persisted transaction reattachment events.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td>[fromTimestamp]</td><td><code>number</code></td><td><code>null</code></td><td>Filter events that were stored after the given UTC timestamp</td></tr>
</tbody></table>
<h4 id="getbroadcasteventscount-skip-fromtimestamp"><a class="header" href="#getbroadcasteventscount-skip-fromtimestamp">getBroadcastEvents([count, skip, fromTimestamp])</a></h4>
<p>Gets the persisted transaction broadcast events.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td>[count]</td><td><code>number</code></td><td><code>0</code></td><td>The number of events to return (<code>0</code> to return all)</td></tr>
<tr><td>[skip]</td><td><code>number</code></td><td><code>0</code></td><td>The number of events to skip</td></tr>
<tr><td>[fromTimestamp]</td><td><code>number</code></td><td><code>null</code></td><td>Filter events that were stored after the given UTC timestamp</td></tr>
</tbody></table>
<p>Event object: { indexationId: string, accountId: string, message: Message }</p>
<h4 id="getbroadcasteventcountfromtimestamp"><a class="header" href="#getbroadcasteventcountfromtimestamp">getBroadcastEventCount([fromTimestamp])</a></h4>
<p>Gets the number of persisted transaction broadcast events.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td>[fromTimestamp]</td><td><code>number</code></td><td><code>null</code></td><td>Filter events that were stored after the given UTC timestamp</td></tr>
</tbody></table>
<h3 id="syncedaccount"><a class="header" href="#syncedaccount">SyncedAccount</a></h3>
<p>The result of a <code>sync</code> operation on an Account.</p>
<h3 id="account"><a class="header" href="#account">Account</a></h3>
<h4 id="id"><a class="header" href="#id">id()</a></h4>
<p>Returns the account's identifier.</p>
<h4 id="index"><a class="header" href="#index">index()</a></h4>
<p>Returns the account's index.</p>
<h4 id="alias"><a class="header" href="#alias">alias()</a></h4>
<p>Returns the account's alias.</p>
<h4 id="balance-accountbalance"><a class="header" href="#balance-accountbalance">balance(): AccountBalance</a></h4>
<p>Returns the account's balance information object.</p>
<p>Balance object: { total: number, available: number, incoming: number, outgoing: number }</p>
<h4 id="messagecounttype"><a class="header" href="#messagecounttype">messageCount([type])</a></h4>
<p>Returns the number of messages associated with the account.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td>[type]</td><td><code>number</code></td><td><code>null</code></td><td>The message type filter (Received = 1, Sent = 2, Failed = 3, Unconfirmed = 4, Value = 5)</td></tr>
</tbody></table>
<h4 id="listmessagescount-from-type"><a class="header" href="#listmessagescount-from-type">listMessages([count, from, type])</a></h4>
<p>Returns the account's messages.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td>[count]</td><td><code>number</code></td><td><code>0</code></td><td>The number of messages to return (<code>0</code> to return all)</td></tr>
<tr><td>[skip]</td><td><code>number</code></td><td><code>0</code></td><td>The number of messages to skip</td></tr>
<tr><td>[type]</td><td><code>number</code></td><td><code>null</code></td><td>The message type filter (Received = 1, Sent = 2, Failed = 3, Unconfirmed = 4, Value = 5)</td></tr>
</tbody></table>
<p>Message object: { confirmed: boolean, broadcasted: boolean, incoming: boolean, value: number }</p>
<h4 id="listaddressesunspent"><a class="header" href="#listaddressesunspent">listAddresses([unspent])</a></h4>
<p>Returns the account's addresses.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td>[unspent]</td><td><code>boolean</code></td><td><code>null</code></td><td>The <code>unspent</code> status filter</td></tr>
</tbody></table>
<p>Address object: { address: string, keyIndex: number }</p>
<h4 id="syncoptions"><a class="header" href="#syncoptions">sync([options])</a></h4>
<p>Synchronizes the account with the Tangle.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td>[options]</td><td><code>object</code></td><td><code>{}</code></td><td>The sync options</td></tr>
<tr><td>[options.addressIndex]</td><td><code>number</code></td><td><code>latest address index</code></td><td>The index of the first address to sync</td></tr>
<tr><td>[options.gapLimit]</td><td><code>number</code></td><td><code>10</code></td><td>The number of addresses to check</td></tr>
</tbody></table>
<p><strong>Returns</strong> a <a href="libraries/wallet-lib/docs/libraries/nodejs/api_reference.html#syncedaccount">SyncedAccount</a> instance.</p>
<h4 id="sendaddress-amount-options"><a class="header" href="#sendaddress-amount-options">send(address, amount[, options])</a></h4>
<p>Send funds to the given address.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td>address</td><td><code>string</code></td><td><code>null</code></td><td>The bech32 string of the transfer address</td></tr>
<tr><td>amount</td><td><code>number</code></td><td><code>undefined</code></td><td>The transfer amount</td></tr>
<tr><td>options</td><td><code>TransferOptions</code></td><td><code>undefined</code></td><td>The transfer options</td></tr>
</tbody></table>
<h5 id="transferoptions"><a class="header" href="#transferoptions">TransferOptions</a></h5>
<table><thead><tr><th>Param</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td>remainderValueStrategy</td><td><code>RemainderValueStrategy</code></td><td><code>null</code></td><td>The strategy to use for the remainder value if any</td></tr>
<tr><td>indexation</td><td><code>{ index: string, data?: Uint8Array }</code></td><td><code>null</code></td><td>Message indexation</td></tr>
</tbody></table>
<h5 id="remaindervaluestrategy"><a class="header" href="#remaindervaluestrategy">RemainderValueStrategy</a></h5>
<h6 id="changeaddress"><a class="header" href="#changeaddress">changeAddress()</a></h6>
<p>Send the remainder value to an internal address.</p>
<h6 id="reuseaddress"><a class="header" href="#reuseaddress">reuseAddress()</a></h6>
<p>Send the remainder value to its original address.</p>
<h6 id="accountaddressaddress-string"><a class="header" href="#accountaddressaddress-string">accountAddress(address: string)</a></h6>
<p>Send the remainder value to a specific address that must belong to the account.</p>
<h4 id="retrymessageid"><a class="header" href="#retrymessageid">retry(messageId)</a></h4>
<p>Retries (promotes or reattaches) the given message.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td>messageId</td><td><code>string</code></td><td><code>null</code></td><td>The message's identifier</td></tr>
</tbody></table>
<h4 id="reattachmessageid"><a class="header" href="#reattachmessageid">reattach(messageId)</a></h4>
<p>Reattach the given message.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td>messageId</td><td><code>string</code></td><td><code>null</code></td><td>The message's identifier</td></tr>
</tbody></table>
<h4 id="promotemessageid"><a class="header" href="#promotemessageid">promote(messageId)</a></h4>
<p>Promote the given message.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td>messageId</td><td><code>string</code></td><td><code>null</code></td><td>The message's identifier</td></tr>
</tbody></table>
<h4 id="consolidateoutputs"><a class="header" href="#consolidateoutputs">consolidateOutputs()</a></h4>
<p>Consolidate the outputs on all account addresses.</p>
<h4 id="islatestaddressunused-1"><a class="header" href="#islatestaddressunused-1">isLatestAddressUnused()</a></h4>
<p>Determines whether the account has unused latest address after syncing with the Tangle.</p>
<p><strong>Returns</strong> A promise resolving to the boolean value.</p>
<h4 id="setaliasalias"><a class="header" href="#setaliasalias">setAlias(alias)</a></h4>
<p>Updates the account alias.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td>alias</td><td><code>string</code></td><td><code>null</code></td><td>The new account alias</td></tr>
</tbody></table>
<h4 id="setclientoptionsoptions-1"><a class="header" href="#setclientoptionsoptions-1">setClientOptions(options)</a></h4>
<p>Updates the account client options.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td>options</td><td><code><a href="libraries/wallet-lib/docs/libraries/nodejs/api_reference.html#clientoptions">ClientOptions</a></code></td><td><code>null</code></td><td>The new account client options</td></tr>
</tbody></table>
<h4 id="getmessagemessageid"><a class="header" href="#getmessagemessageid">getMessage(messageId)</a></h4>
<p>Gets the message associated with the given identifier.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td>messageId</td><td><code>string</code></td><td><code>null</code></td><td>The message's identifier</td></tr>
</tbody></table>
<h4 id="getaddressaddressbech32"><a class="header" href="#getaddressaddressbech32">getAddress(addressBech32)</a></h4>
<p>Gets the address object by its bech32 representation.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td>addressBech32</td><td><code>string</code></td><td><code>null</code></td><td>The address bech32 representation</td></tr>
</tbody></table>
<h4 id="generateaddress"><a class="header" href="#generateaddress">generateAddress()</a></h4>
<p>Generates a new unused address and returns it.</p>
<h4 id="latestaddress"><a class="header" href="#latestaddress">latestAddress()</a></h4>
<p>Returns the latest address (the one with the biggest keyIndex).</p>
<h4 id="getunusedaddress"><a class="header" href="#getunusedaddress">getUnusedAddress()</a></h4>
<p>Synchronizes the account addresses with the Tangle and returns the latest address in the account,
which is an address without balance.</p>
<h3 id="clientoptions"><a class="header" href="#clientoptions">ClientOptions</a></h3>
<table><thead><tr><th>Field</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td>[network]</td><td><code>number</code></td><td><code>undefined</code></td><td>The tangle network to connect to (Mainnet = 1, Devnet = 1, Comnet = 3)</td></tr>
<tr><td>[node]</td><td><code>string</code></td><td><code>undefined</code></td><td>A node URL to connect to</td></tr>
<tr><td>[nodes]</td><td><code>string[]</code></td><td><code>undefined</code></td><td>A list node URL to connect to</td></tr>
<tr><td>[quorumSize]</td><td><code>number</code></td><td><code>undefined</code></td><td>If multiple nodes are provided, quorum size determines the number of nodes to query to check for quorum.</td></tr>
<tr><td>[quorumThreshold]</td><td><code>number</code></td><td><code>undefined</code></td><td>Minimum number of nodes from the quorum pool that need to agree to consider a result true.</td></tr>
<tr><td>[localPow]</td><td><code>boolean</code></td><td><code>true</code></td><td>Whether to use local or remote PoW.</td></tr>
</tbody></table>
<h1 id="troubleshooting-4"><a class="header" href="#troubleshooting-4">Troubleshooting</a></h1>
<h2 id="stackexchange-4"><a class="header" href="#stackexchange-4">StackExchange</a></h2>
<blockquote>
<p><a href="https://iota.stackexchange.com/">https://iota.stackexchange.com</a></p>
</blockquote>
<p>The IOTA StackExchange a a nice Tool for developers to find  Answers for a problem. Just search your problem and find your answer! If there is no one, submit your question and share it in the discussion channel below.</p>
<h2 id="joining-the-discussion-11"><a class="header" href="#joining-the-discussion-11">Joining the discussion</a></h2>
<p>If you want to get involved in discussions about this library, or you're looking for support, go to the #clients-discussion channel on <a href="https://discord.iota.org">Discord</a>.</p>
<h1 id="iota-wallet-python-library"><a class="header" href="#iota-wallet-python-library">IOTA Wallet Python Library</a></h1>
<p><a href="https://github.com/iotaledger/wallet.rs"><img src="https://img.shields.io/badge/Status-Alpha-yellow.svg" alt="status" /></a></p>
<h2 id="warning-7"><a class="header" href="#warning-7">Warning</a></h2>
<p>This library is in active development. The library targets the Chrysalis testnet and does not work with current IOTA mainnet.</p>
<h2 id="joining-the-discussion-12"><a class="header" href="#joining-the-discussion-12">Joining the discussion</a></h2>
<p>If you want to get involved in discussions about this library, or you're looking for support, go to the #clients-discussion channel on <a href="https://discord.iota.org">Discord</a>.</p>
<h2 id="overview-7"><a class="header" href="#overview-7">Overview</a></h2>
<ul>
<li><a href="libraries/wallet-lib/docs/libraries/python/./getting_started.html">Getting Started with wallet and python</a></li>
<li><a href="libraries/wallet-lib/docs/libraries/python/./examples.html">Examples</a></li>
<li><a href="libraries/wallet-lib/docs/libraries/python/./api_reference.html">API Reference</a></li>
<li><a href="libraries/wallet-lib/docs/libraries/python/./troubleshooting.html">Troubleshooting</a></li>
</ul>
<h1 id="getting-started-with-iota-wallet-python-binding"><a class="header" href="#getting-started-with-iota-wallet-python-binding">Getting Started with IOTA Wallet Python binding</a></h1>
<h2 id="installation-3"><a class="header" href="#installation-3">Installation</a></h2>
<p>Easiest way how to get python binding up and running is to leverage pre-built python libraries for linux/macos/windows that can be installed to your python environment (3.6+) via <code>pip</code>. The binding is automagically generated using github <a href="https://github.com/iotaledger/wallet.rs/actions/workflows/python_binding_publish.yml">actions</a>.</p>
<p>The latest artifacts for major python versions can be also grabbed using <a href="https://nightly.link/iotaledger/wallet.rs/workflows/python_binding_publish/develop">nighly.link service</a>. Download zip file for the given os and pyversion, unpack wheel file (<code>.whl</code>) and install it via <code>pip</code>:</p>
<pre><code class="language-bash">pip install &lt;wheel_file&gt;
</code></pre>
<p>Once it has been properly installed you can double check it using <code>pip</code>:</p>
<pre><code class="language-bash">pip list
</code></pre>
<p>You should see the similar output:</p>
<pre><code class="language-plaintext">Package                    Version
-------------------------- -------
iota-wallet-python-binding 0.1.0
</code></pre>
<p>Once installed in the given python environment you are all set and can start hacking using python binding!</p>
<h2 id="usage-3"><a class="header" href="#usage-3">Usage</a></h2>
<pre><code class="language-python">import iota_wallet
print(iota_wallet.__doc__)
</code></pre>
<h1 id="examples-5"><a class="header" href="#examples-5">Examples</a></h1>
<h2 id="account-manager-and-individual-accounts"><a class="header" href="#account-manager-and-individual-accounts">Account manager and individual accounts</a></h2>
<p>First of all, let's initialize (open) a secure storage for individual accounts (backed up by Stronghold by default) using <code>AccountManager</code> instance:</p>
<pre><code class="language-python"># Copyright 2020 IOTA Stiftung
# SPDX-License-Identifier: Apache-2.0


import iota_wallet as iw
import os
from dotenv import load_dotenv


# Load the env variables
load_dotenv()

# Get the stronghold password
STRONGHOLD_PASSWORD = os.getenv('STRONGHOLD_PASSWORD')

account_manager = iw.AccountManager(
    storage_path='./alice-database'
)  # note: `storage` and `storage_path` have to be declared together

account_manager.set_stronghold_password(STRONGHOLD_PASSWORD)

# mnemonic (seed) should be set only for new storage
# once the storage has been initialized earlier then you should omit this step
account_manager.store_mnemonic(&quot;Stronghold&quot;)
</code></pre>
<ul>
<li>Storage is initialized under the given path (<code>./alice-database</code>)</li>
<li>Password is set (<code>password</code>)</li>
<li>Only during the initialization new database: stronghold mnemonic (seed) is automatically generated and stored by default</li>
</ul>
<p>The storage is encrypted at rest and so you need a strong password and location where to put your storage. </p>
<blockquote>
<p>Please note: deal with the password with utmost care</p>
</blockquote>
<p>Technically speaking, the storage means a single file called <code>wallet.stronghold</code>. It is also needed to generate a seed (mnemonic) that serves as a cryptographic key from which all accounts and related addresses are generated.</p>
<p>One of the key principle behind the <code>stronghold</code>-based storage is that no one can get a seed from the storage. You deal with all accounts purely via <code>Account_Manager</code> instance and all complexities are hidden under the hood and are dealt with in a secure way.</p>
<p>In case one would like to store a seed also somewhere else, there is a method <code>AccountManager.generate_mnemonic()</code> that generates random seed and it can be leveraged before the actual account initialization.</p>
<p>Please note, it is highly recommended to store <code>stronghold</code> password and <code>stronghold</code> database on separate devices.</p>
<h3 id="accounts"><a class="header" href="#accounts">Accounts</a></h3>
<p>The library uses a model of individual accounts to separate individual users/clients from each other. It is possible to generate multiple addresses for each account deterministically. </p>
<p>Please note, it is important to declare on which IOTA network should be the given account created (argument <code>node</code>).</p>
<pre><code class="language-python"># ... continue from prev example 1a

# general Tangle specific options
client_options = {
    &quot;nodes&quot;: [
        {
            &quot;url&quot;: &quot;https://api.hornet-0.testnet.chrysalis2.com&quot;,
            &quot;auth&quot;: None,
            &quot;disabled&quot;: False
        }
    ],
    &quot;local_pow&quot;: True
}

# an account is generated with the given alias via `account_initialiser`
account_initialiser = account_manager.create_account(client_options)
account_initialiser.alias('Alice')

# initialise account based via `account_initialiser`
# store it to db and sync with Tangle
account = account_initialiser.initialise()
print(f'Account created: {account.alias()}')
</code></pre>
<p>Once an account has been created you get an instance of it using the following methods: <code>get_account(account_id: str)</code> or <code>get_accounts()</code>.
An account can be then referred to via <code>index</code>, <code>alias</code> or one of its generated <code>addresses</code>. The network against which the account is active can be checked via <code>account.bech32_hrp()</code>.</p>
<p>Overview of all accounts:</p>
<pre><code class="language-python">for acc in account_manager.get_accounts():
  print(f&quot;Account alias: {acc.alias()}; network: {acc.bech32_hrp()}&quot;)
</code></pre>
<p>Get the instance of a specific account:</p>
<pre><code class="language-python">account = account_manager.get_account(&quot;Alice&quot;)
</code></pre>
<p>Several api calls can be performed via <code>account</code> instance. Note: it is a good practice to sync the given account with the Tangle every time you work with <code>account</code> instance to rely on the latest information available: <code>account.sync().execute()</code>.</p>
<p>The most common methods:</p>
<ul>
<li><code>account.alias()</code>: returns an alias of the given account</li>
<li><code>account.addresses()</code>: returns list of addresses related to the account</li>
<li><code>account.get_unused_address()</code>: returns a first unused address</li>
<li><code>account.is_latest_address_unused()</code>: it queries the Tangle and returns <code>bool</code> whether latest address was already used</li>
<li><code>account.generate_address()</code>: generate a new address for the address index incremented by 1</li>
<li><code>account.balance()</code>: returns the balance for the given account</li>
<li><code>account.sync()</code>: sync the account information with the tangle</li>
</ul>
<h2 id="generating-addresses-1"><a class="header" href="#generating-addresses-1">Generating address(es)</a></h2>
<p>Each account can posses multiple addresses. Addresses are generated deterministically based on the account and address index. It means that the combination of account and index uniquely identifies the given address.</p>
<p>Addresses are of two types: <code>internal</code> and <code>public</code> (external):</p>
<ul>
<li>each set of addresses is independent from each other and has independent <code>index</code> id</li>
<li>addresses that are created by <code>account.generate_address()</code> are indicated as <code>internal=false</code> (public)</li>
<li>internal addresses (<code>internal=true</code>) are so called <code>change</code> addresses and are used to send the excess funds to</li>
<li>the approach is also known as a <em>BIP32 Hierarchical Deterministic wallet (HD Wallet)</em>.</li>
</ul>
<p><em>Note: You may remember IOTA 1.0 network in which addresses were not reusable. It is no longer true and addresses can be reused multiple times in IOTA 1.5 (Chrysalis) network.</em></p>
<p>Addresses are generated via instance of <code>account</code> that is gotten from the <code>account_manager</code> instance:</p>
<pre><code class="language-python"># Copyright 2020 IOTA Stiftung
# SPDX-License-Identifier: Apache-2.0


import iota_wallet as iw
import os
from dotenv import load_dotenv

# Load the env variables
load_dotenv()

# Get the stronghold password
STRONGHOLD_PASSWORD = os.getenv('STRONGHOLD_PASSWORD')

# This example generates a new address.
account_manager = iw.AccountManager(
    storage_path='./alice-database'
)

account_manager.set_stronghold_password(STRONGHOLD_PASSWORD)

# get a specific instance of some account
account = account_manager.get_account('Alice')
print(f'Account: {account.alias()}')

# Always sync before doing anything with the account
print('Syncing...')
synced = account.sync().execute()

# generate new address
address = account.generate_address()
print(f'New address: {address}')

# print all addresses generated so far
print(&quot;List of addresses:&quot;)
print(account.addresses())

# You can also get the latest unused address
last_address_obj = account.latest_address()
print(f&quot;Last address: {last_address_obj['address']}&quot;)
</code></pre>
<p>Output example:</p>
<pre><code class="language-json">[{'address': {'inner': 'atoi1qzy79ew8x4hn4dsr0t3j8ce8hdwdrh8xzx85x2gkse6k0fx2jkyaqdgd2rn'},
  'balance': 0,
  'key_index': 0,
  'internal': False,
  'outputs': []},
 {'address': {'inner': 'atoi1qzht4m2jt0q50lhlqa786pcx6vardm4xj8za72fezde6tj39acatq5zh2cg'},
  'balance': 0,
  'key_index': 1,
  'internal': False,
  'outputs': []}]
</code></pre>
<p>Take a closer look at the output above and check the beginning of both addresses. As mentioned in <a href="libraries/wallet-lib/docs/libraries/python/../../welcome.html">overview chapter</a> there are two human-readable prefixes in IOTA 1.5 network: <code>iota</code> (mainnet) and <code>atoi</code> (testnet).</p>
<h2 id="checking-the-balance"><a class="header" href="#checking-the-balance">Checking the balance</a></h2>
<p>Before we continue further, go to <a href="https://faucet.testnet.chrysalis2.com/">IOTA testnet faucet service</a> and send to your testnet addresses some tokens:
<img src="libraries/wallet-lib/docs/libraries/python/screenshot_faucet.png" alt="faucet screenshot" /></p>
<pre><code class="language-python"># Copyright 2020 IOTA Stiftung
# SPDX-License-Identifier: Apache-2.0


import iota_wallet as iw
import os
from dotenv import load_dotenv

# Load the env variables
load_dotenv()

# Get the stronghold password
STRONGHOLD_PASSWORD = os.getenv('STRONGHOLD_PASSWORD')

# This example checks the account balance.
account_manager = iw.AccountManager(
    storage_path='./alice-database'
)

account_manager.set_stronghold_password(STRONGHOLD_PASSWORD)

# get a specific instance of some account
account = account_manager.get_account('Alice')
print(f'Account: {account.alias()}')

# Always sync before doing anything with the account
print('Syncing...')
synced = account.sync().execute()

# get total balance for the account
print(&quot;Total balance:&quot;)
print(account.balance())

print(&quot;Balance per individual addresses:&quot;)
print(account.addresses())
</code></pre>
<p>Output:</p>
<pre><code class="language-json">Total balance:
{'total': 10000000, 'available': 10000000, 'incoming': 10000000, 'outgoing': 0}

Balance per individual addresses:
[{'address': {'inner': 'atoi1qzy79ew8x4hn4dsr0t3j8ce8hdwdrh8xzx85x2gkse6k0fx2jkyaqdgd2rn'},
  'balance': 0,
  'key_index': 0,
  'internal': False,
  'outputs': []},
 {'address': {'inner': 'atoi1qzht4m2jt0q50lhlqa786pcx6vardm4xj8za72fezde6tj39acatq5zh2cg'},
  'balance': 10000000,
  'key_index': 1,
  'internal': False,
  'outputs': [{'transaction_id': '1c88c91fe0a8eed074b5ccdfdad52403d7908d157b231ae1ef28b0e20ba14e8e',
    'message_id': 'f1575f984f7fda6e9b3e23e96ef3304fcd0ba4ce323af3920856a427fabe1abe',
    'index': 0,
    'amount': 10000000,
    'is_spent': False,
    'address': {'inner': 'atoi1qzht4m2jt0q50lhlqa786pcx6vardm4xj8za72fezde6tj39acatq5zh2cg'}}]},
 {'address': {'inner': 'atoi1qpvnsgygzal4vkxhlc0ew7c6c6csnjr72x5rgn3txqswrsa2xfrec8v04f7'},
  'balance': 0,
  'key_index': 2,
  'internal': False,
  'outputs': []}]
</code></pre>
<p>In the detailed view per individual addresses, there is also <code>outputs</code> section that indicates transaction(s) (also known as <code>wallet message(s)</code>) &quot;responsible&quot; for the current amount. The amount can be also double checked using <a href="https://explorer.iota.org/chrysalis/addr/atoi1qzht4m2jt0q50lhlqa786pcx6vardm4xj8za72fezde6tj39acatq5zh2cg">Tangle Explorer</a>.</p>
<h2 id="sending-tokens"><a class="header" href="#sending-tokens">Sending tokens</a></h2>
<p>The process of sending tokens via <code>wallet.rs</code> can be described as follows:</p>
<ul>
<li>Create instance of <code>iota_wallet.Transfer()</code> class with the following mandatory arguments: <code>amount</code>, <code>address</code> and <code>remainder_value_strategy</code></li>
<li><code>remainder_value_strategy</code> can be: <code>ReuseAddress</code> or <code>ChangeAddress</code>. You may be familiar with a concept <code>changing address with every spent</code> in IOTA 1.0. It is not an issue in IOTA 1.5 world but it may still become handy depending on your use case</li>
<li>once instance of <code>iota_wallet.Transfer()</code> is created, it can be sent via <code>transfer()</code> function of the <code>Account</code> instance</li>
<li>needless to repeat, always sync the account information with the Tangle before do anything with the account</li>
</ul>
<pre><code class="language-python"># Copyright 2020 IOTA Stiftung
# SPDX-License-Identifier: Apache-2.0


import iota_wallet as iw
import os
from dotenv import load_dotenv

# Load the env variables
load_dotenv()

# Get the stronghold password
STRONGHOLD_PASSWORD = os.getenv('STRONGHOLD_PASSWORD')

# This example sends IOTA toens to an address.
account_manager = iw.AccountManager(
    storage_path='./alice-database'
)
account_manager.set_stronghold_password(STRONGHOLD_PASSWORD)

print(&quot;Selecting a specific account&quot;)
account = account_manager.get_account('Alice')
print(f'Account: {account.alias()} selected')

# Always sync before doing anything with the account
print('Syncing...')
synced = account.sync().execute()

print(f&quot;Available balance {account.balance()['available']}&quot;)

# TODO: Replace with the address of your choice!
transfer = iw.Transfer(
    amount=1_000_000,
    address='atoi1qzt0nhsf38nh6rs4p6zs5knqp6psgha9wsv74uajqgjmwc75ugupx3y7x0r',
    remainder_value_strategy='ReuseAddress'
)

# Propogate the Transfer to Tangle
# and get a response from the Tangle
node_response = account.transfer(transfer)
print(
    node_response
)
</code></pre>
<p>You receive an output similar to the following one:</p>
<pre><code class="language-json">{'id': '9d3c401d59b0a87f6fbaa58582bb71e1858d63336421ccbae834821d9be113d3',
 'version': 1,
 'parents': ['66009ff08637c3e74340fb9e09e30e3c4453728c857fd425df2d2e0587af6426',
  '6da392ac35f73594bf5509fb5c3304e972b36313ce98f2cc63def7cde2054b53',
  '9157b29cbffcd5c9669cf22004fbc557354e5ade7268f5bfe25fbc75ab29e3b1',
  'bfe860e09350cd3b8db90611e78e03fdda654139a4b34e68e4b1bb07528b2bef'],
 'payload_length': 233,
 'payload': {'transaction': [{'essence': {'regular': {'inputs': [{'transaction_id': '692d6660084dd3b6341ef4f761bc8b8bb27ac35bb0b352bfb030f2c80753815b',
        'index': 0,
        'metadata': {'transaction_id': '692d6660084dd3b6341ef4f761bc8b8bb27ac35bb0b352bfb030f2c80753815b',
         'message_id': 'c6284e0cc2a6383474782d4e6b6cfaf16c1831c8875cca262982782758a248c0',
         'index': 0,
         'amount': 10000000,
         'is_spent': False,
         'address': {'inner': 'atoi1qq24vlx53qdskyfw6940xa2vg55ma5egzyqv6glq23udx3e0zkmmg97cwze'}}}],
      'outputs': [{'address': 'atoi1qq24vlx53qdskyfw6940xa2vg55ma5egzyqv6glq23udx3e0zkmmg97cwze',
        'amount': 9000000},
       {'address': 'atoi1qpvnsgygzal4vkxhlc0ew7c6c6csnjr72x5rgn3txqswrsa2xfrec8v04f7',
        'amount': 1000000}],
      'payload': None}},
    'unlock_blocks': [{'signature': {'public_key': [15...&lt;TRIMMED&gt;...],
       'signature': [210...&lt;TRIMMED&gt;...]},
      'reference': None}]}],
  'milestone': None,
  'indexation': None},
 'timestamp': 1615132552,
 'nonce': 274654,
 'confirmed': None,
 'broadcasted': True,
 'incoming': False,
 'value': 1000000,
 'remainder_value': 9000000}
</code></pre>
<p>It is a <code>wallet message</code> that fully describes the given transaction.</p>
<p>Please, kindly get yourself familiar with a concept of <a href="https://chrysalis.docs.iota.org/introduction/what_is_chrysalis.html#switch-to-utxo-model">UTXO</a> to understand all aspects of messages.</p>
<p>The given message can be double checked via Tangle Explorer using <code>node_response['id']</code> field (<a href="https://explorer.iota.org/chrysalis/message/9d3c401d59b0a87f6fbaa58582bb71e1858d63336421ccbae834821d9be113d3">Tangle Explorer</a>).</p>
<p>Needless to say, if <code>remainder_value_strategy</code> == <code>ChangeAddress</code> is used, the given message transfer tokens to target address as well as new <code>internal</code> address within the given account (<code>internal=True</code>). </p>
<h3 id="reattachments"><a class="header" href="#reattachments">Reattachments</a></h3>
<p>If message reattachment is needed then <code>account_id</code> and <code>message_id</code> is passed to <code>iota_wallet.promote(account_id, message_id)</code> or <code>iota_wallet.reattach(account_id, message_id)</code>.</p>
<h3 id="list-of-messages-transactions"><a class="header" href="#list-of-messages-transactions">List of messages (transactions)</a></h3>
<p>List of all particular messages (transactions) related to the given account get be obtained via: <code>account.list_messages()</code> and related <code>account.message_count()</code>.</p>
<p>Those can be used also to check whether the given message was confirmed/broadcasted, etc. Needless to say, sync the account with the Tangle before checking confirmation status:</p>
<pre><code class="language-python"># Copyright 2020 IOTA Stiftung
# SPDX-License-Identifier: Apache-2.0


import iota_wallet as iw
import os
from dotenv import load_dotenv

# Load the env variables
load_dotenv()

# Get the stronghold password
STRONGHOLD_PASSWORD = os.getenv('STRONGHOLD_PASSWORD')

# This example sends IOTA toens to an address.
account_manager = iw.AccountManager(
    storage_path='./alice-database'
)
account_manager.set_stronghold_password(STRONGHOLD_PASSWORD)

account = account_manager.get_account('Alice')
print(f'Account: {account.alias()} selected')

# Always sync before doing anything with the account
print('Syncing...')
synced = account.sync().execute()

for ac in account.list_messages():
    print(f&quot;message {ac['id']}; confirmation status = {ac['confirmed']}'&quot;)
</code></pre>
<h3 id="dust-protection-2"><a class="header" href="#dust-protection-2">Dust protection</a></h3>
<p>Please note, there is also implemented a <a href="https://chrysalis.docs.iota.org/guides/dev_guide.html#dust-protection">dust protection</a> mechanism in the network protocol to avoid malicious actors to spam network in order to decrease node performance while keeping track of unspent amount (<code>UTXO</code>):</p>
<blockquote>
<p>&quot;... microtransaction below 1Mi of IOTA tokens [can be sent] to another address if there is already at least 1Mi on that address&quot;
That's why we did send 1Mi in the given example to comply with the protection.&quot;</p>
</blockquote>
<h2 id="backup-database"><a class="header" href="#backup-database">Backup database</a></h2>
<p>Underlying database (provided by <code>Stronghold</code> by default) is encrypted at rest and there is no way how to get a seed from it due to security practices that are incorporated in the Stronghold's DNA. It means you are dealing with the database as an atomic unit that includes all wallet information.</p>
<p>So backing up the database is very important task from this respect.</p>
<pre><code class="language-python"># Copyright 2020 IOTA Stiftung
# SPDX-License-Identifier: Apache-2.0


import iota_wallet as iw
import os
from dotenv import load_dotenv

# Load the env variables
load_dotenv()

# Get the stronghold password
STRONGHOLD_PASSWORD = os.getenv('STRONGHOLD_PASSWORD')

# This example backups your data in a secure file.
# You can move this file to another app or device and restore it.
account_manager = iw.AccountManager(
    storage_path='./alice-database'
)
account_manager.set_stronghold_password(STRONGHOLD_PASSWORD)

backup_dir_path = './backup'
if not os.path.exists(backup_dir_path):
    os.makedirs(backup_dir_path)
backup_file_path = account_manager.backup(backup_dir_path, STRONGHOLD_PASSWORD)

print(f'Backup path: {backup_file_path}')
</code></pre>
<p>Output:</p>
<pre><code class="language-plaintext">Backup path: ./backup/2021-03-07T18-24-06-iota-wallet-backup-wallet.stronghold
</code></pre>
<h2 id="restore-database"><a class="header" href="#restore-database">Restore database</a></h2>
<p>The process of restoring underlying database via <code>wallet.rs</code> can be described as follows:</p>
<ul>
<li>create new empty database with a password (without mnemonic [seed])</li>
<li>import all accounts from the file that has been backed up earlier</li>
</ul>
<pre><code class="language-python"># Copyright 2020 IOTA Stiftung
# SPDX-License-Identifier: Apache-2.0


import iota_wallet as iw
import os
from dotenv import load_dotenv

# Load the env variables
load_dotenv()

# Get the stronghold password
STRONGHOLD_PASSWORD = os.getenv('STRONGHOLD_PASSWORD')

# This example restores a secured backup file.
account_manager = iw.AccountManager(
    storage_path='./alice-database-restored'
)

# NOTE: In real use cases you need to set the password in a safer way, like getting it from env variables
account_manager.set_stronghold_password(STRONGHOLD_PASSWORD)

#  Add the path to the file from example 5-backup.js
#  for example: ./backup/2021-03-04T15-31-04-iota-wallet-backup-wallet.stronghold
backup_file_path = r'./backup/2021-03-31T14-45-23-iota-wallet-backup-wallet.stronghold'

# NOTE: In real use cases you need to set the password in a safer way, like getting it from env variables
account_manager.import_accounts(backup_file_path, STRONGHOLD_PASSWORD)
account = account_manager.get_account('Alice')
print(f'Account: {account.alias()}')
</code></pre>
<p>Since the backup file is just a copy of the original database it can be alternatively also renamed to <code>wallet.stronghold</code> and opened in a standard way:</p>
<pre><code class="language-python">account_manager = iw.AccountManager(
    storage_path='./alice-database'
)
account_manager.set_stronghold_password(&quot;password&quot;)
</code></pre>
<h2 id="listening-to-events"><a class="header" href="#listening-to-events">Listening to events</a></h2>
<p><code>Wallet.rs</code> also supports asynchronous event listeners to be listened to. In the python binding it is currently implemented in a way the provided callback is executed as soon as the event is triggered; <code>event</code> details are passed as an argument to the callback method. <em>No coroutines (async/await) are implemented in the python binding.</em></p>
<p>There are following event listeners supported:</p>
<ul>
<li><code>on_balance_change(callback): id</code></li>
<li><code>on_new_transaction(callback): id</code></li>
<li><code>on_confirmation_state_change(callback): id</code></li>
<li><code>on_reattachment(callback): id</code></li>
<li><code>on_broadcast(callback): id</code></li>
<li><code>on_error(callback): id</code></li>
<li><code>on_stronghold_status_change(callback): id</code></li>
</ul>
<p>When the event listener is registered by calling function above, it returns <code>id</code> of the listener as a <code>list[Bytes]</code>. This <code>id</code> can be then leveraged to deregister the given listener:</p>
<ul>
<li><code>remove_balance_change_listener(id)</code></li>
<li><code>remove_new_transaction_listener(id)</code></li>
<li><code>remove_confirmation_state_change_listener(id)</code></li>
<li><code>remove_reattachment_listener(id)</code></li>
<li><code>remove_broadcast_listener(id)</code></li>
<li><code>remove_error_listener(id)</code></li>
<li><code>remove_stronghold_status_change_listener(id)</code></li>
</ul>
<p>Example of listening to <code>on_balance_change</code> via simple event-based pattern in python:</p>
<pre><code class="language-python"># Copyright 2020 IOTA Stiftung
# SPDX-License-Identifier: Apache-2.0

import threading
import time
import iota_wallet as iw
import os
from dotenv import load_dotenv

# Load the env variables
load_dotenv()

# Get the stronghold password
STRONGHOLD_PASSWORD = os.getenv('STRONGHOLD_PASSWORD')

result_available = threading.Event()


def balance_changed_event_processing(event):
    print(f'On balanced changed: {event}')
    result_available.set()


# This example shows some events.
account_manager = iw.AccountManager(
    storage_path='./alice-database'
)

# NOTE: In real use cases you need to set the password in a safer way, like getting it from env variables
account_manager.set_stronghold_password(STRONGHOLD_PASSWORD)

account = account_manager.get_account('Alice')
print(f'Account: {account.alias()}')

# Always sync before doing anything with the account
print('Syncing...')
synced = account.sync().execute()

# Get the latest unused address
last_address_obj = account.latest_address()
print(f&quot;Address: {last_address_obj['address']}&quot;)

# Use the Chrysalis Faucet to send testnet tokens to your address:
print('Fill your address with the Faucet: https://faucet.tanglekit.de/')

iw.on_balance_change(balance_changed_event_processing)
print(&quot;Waiting for external event (on_balance_changed)...&quot;)

# wait for results to be available before continue
# will not wait longer than 360 seconds
result_available.wait(timeout=360)

print(&quot;Done.&quot;)
</code></pre>
<p>Output:</p>
<pre><code class="language-plaintext">Account: Alice
Syncing...
Address: {'inner': 'atoi1qquszp0hzfsrgx4vx58dfg4v6eh20d2k3ddfgg9dt5778c2egc9uyw7g457'}
Fill your address with the Faucet: https://faucet.testnet.chrysalis2.com/
Waiting for external event (on_balance_changed)...
On balanced changed: {&quot;indexationId&quot;:&quot;c3a7a1ab8ba78460954223a704693d088ddd0388681ac6cc1dd964a388d1a619&quot;,&quot;accountId&quot;:&quot;wallet-account://e51a6285ea2d8cbdf5b6da2b85a8344f619d798d869ef4fb88c5fac0e653d6cc&quot;,&quot;address&quot;:&quot;atoi1qquszp0hzfsrgx4vx58dfg4v6eh20d2k3ddfgg9dt5778c2egc9uyw7g457&quot;,&quot;balanceChange&quot;:{&quot;spent&quot;:0,&quot;received&quot;:10000000}}
Done.
</code></pre>
<p>Alternatively it can be consumed via queue-base pattern:</p>
<pre><code class="language-python"># Copyright 2020 IOTA Stiftung
# SPDX-License-Identifier: Apache-2.0


import iota_wallet
import threading
import queue
import time
import os
from dotenv import load_dotenv

# Load the env variables
load_dotenv()

# Get the stronghold password
STRONGHOLD_PASSWORD = os.getenv('STRONGHOLD_PASSWORD')

# This example shows how to listen to on_balance_change event.

# The queue to store received events
q = queue.Queue()


def worker():
    &quot;&quot;&quot;The worker to process the queued events.
    &quot;&quot;&quot;
    while True:
        item = q.get(True)
        print(f'Get event: {item}')
        q.task_done()


def balance_changed_event_processing(event):
    &quot;&quot;&quot;Processing function when event is received.
    &quot;&quot;&quot;
    print(f'On balanced changed: {event}')
    q.put(event)


# Get the acount manager
manager = iota_wallet.AccountManager(
    storage_path='./alice-database')

# NOTE: In real use cases you need to set the password in a safer way, like getting it from env variables
manager.set_stronghold_password(STRONGHOLD_PASSWORD)

# Get the account
account = manager.get_account('Alice')
print(f'Account: {account.alias()}')

# Always sync before doing anything with the account
print('Syncing...')
synced = account.sync().execute()

# Get the latest unused address
last_address_obj = account.latest_address()
print(f&quot;Address: {last_address_obj['address']}&quot;)

# turn-on the worker thread
threading.Thread(target=worker, daemon=True).start()

# listen to the on_balance_change event
iota_wallet.on_balance_change(balance_changed_event_processing)

# Use the Chrysalis Faucet to send testnet tokens to your address:
print(
    f&quot;Fill your Address ({last_address_obj['address']['inner']}) with the Faucet: https://faucet.tanglekit.de/&quot;)
print(&quot;To see how the on_balance_change is called, please send tokens to the address in 1 min&quot;)
time.sleep(60)

# block until all tasks are done
q.join()
print('All work completed')
</code></pre>
<h1 id="api-reference-6"><a class="header" href="#api-reference-6">API Reference</a></h1>
<p>Note that in the following APIs, the corresponding exception will be returned if an error occurs.
Also for all the optional values, the default values are the same as the ones in the Rust version.</p>
<h3 id="accountmanager-1"><a class="header" href="#accountmanager-1">AccountManager</a></h3>
<h4 id="constructorstorage_path-optional-password-optional-polling_interval-optional-automatic_output_consolidationoptional-output_consolidation_thresholdoptional-sync_spent_outputsoptional-persist_eventsoptional-a-hreflibrarieswallet-libdocslibrariespythonapi_referencehtmlaccountmanageraccountmanagera"><a class="header" href="#constructorstorage_path-optional-password-optional-polling_interval-optional-automatic_output_consolidationoptional-output_consolidation_thresholdoptional-sync_spent_outputsoptional-persist_eventsoptional-a-hreflibrarieswallet-libdocslibrariespythonapi_referencehtmlaccountmanageraccountmanagera">constructor(storage_path (optional), password (optional), polling_interval (optional), automatic_output_consolidation(optional), output_consolidation_threshold(optional), sync_spent_outputs(optional), persist_events(optional)): <a href="libraries/wallet-lib/docs/libraries/python/api_reference.html#accountmanager">AccountManager</a></a></h4>
<p>Creates a new instance of the AccountManager.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td>[storage_path]</td><td><code>str</code></td><td><code><code>./storage</code></code></td><td>The path where the database file will be saved</td></tr>
<tr><td>[storage_password]</td><td><code>str</code></td><td><code>undefined</code></td><td>The storage password to encrypt/decrypt accounts</td></tr>
<tr><td>[polling_interval]</td><td><code>int</code></td><td><code>30000</code></td><td>The polling interval in milliseconds</td></tr>
<tr><td>[automatic_output_consolidation]</td><td><code>bool</code></td><td><code>true</code></td><td>Disables the automatic output consolidation process</td></tr>
<tr><td>[output_consolidation_threshold]</td><td><code>int</code></td><td><code>100</code></td><td>Sets the number of outputs an address must have to trigger the automatic consolidation process</td></tr>
<tr><td>[sync_spent_outputs]</td><td><code>boolean</code></td><td><code>false</code></td><td>Enables fetching spent output history on account sync</td></tr>
<tr><td>[persist_events]</td><td><code>boolean</code></td><td><code>false</code></td><td>Enables event persistence</td></tr>
<tr><td>[allow_create_multiple_empty_accounts]</td><td><code>boolean</code></td><td>code<false></td><td>Enables creating accounts with latest account being empty</td></tr>
</tbody></table>
<p>Note: if the <code>storage_path</code> is set, then the <code>storage</code> needs to be set too. An exception will be thrown when errors happened.</p>
<p><strong>Returns</strong> The constructed <a href="libraries/wallet-lib/docs/libraries/python/api_reference.html#accountmanager">AccountManager</a>.</p>
<h4 id="stop_background_sync-void"><a class="header" href="#stop_background_sync-void">stop_background_sync(): void</a></h4>
<p>Stops the background polling and MQTT monitoring.</p>
<h4 id="set_storage_passwordpassword-void"><a class="header" href="#set_storage_passwordpassword-void">set_storage_password(password): void</a></h4>
<p>Sets the password used for encrypting the storage.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td>password</td><td><code>str</code></td><td><code>undefined</code></td><td>The storage password</td></tr>
</tbody></table>
<h4 id="set_stronghold_passwordpassword-void"><a class="header" href="#set_stronghold_passwordpassword-void">set_stronghold_password(password): void</a></h4>
<p>Sets the stronghold password.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td>password</td><td><code>str</code></td><td><code>undefined</code></td><td>The storage password</td></tr>
</tbody></table>
<h4 id="is_latest_address_unused-bool"><a class="header" href="#is_latest_address_unused-bool">is_latest_address_unused(): bool</a></h4>
<p>Determines whether all accounts have the latest address unused.</p>
<p><strong>Returns</strong> <code>true</code> if the latest address is unused.</p>
<h4 id="store_mnemonicsigner_type-mnemonic-optional-bool"><a class="header" href="#store_mnemonicsigner_type-mnemonic-optional-bool">store_mnemonic(signer_type, mnemonic (optional)): bool</a></h4>
<p>Stores a mnemonic for the given signer type.
If the mnemonic is not provided, we'll generate one.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td>signer_type</td><td><code>str</code></td><td><code>undefined</code></td><td>Should be <code>Stronghold</code>, <code>LedgerNano</code>, or <code>LedgerNanoSimulator</code></td></tr>
<tr><td>mnemonic</td><td><code>str</code></td><td><code>randomly generated</code></td><td>The provided mnemonic or the randomly generated one</td></tr>
</tbody></table>
<h4 id="generate_mnemonic-str"><a class="header" href="#generate_mnemonic-str">generate_mnemonic(): str</a></h4>
<p>Generates a new mnemonic.</p>
<p><strong>Returns</strong> The generated mnemonic string.</p>
<h4 id="verify_mnemonicmnemonic-void"><a class="header" href="#verify_mnemonicmnemonic-void">verify_mnemonic(mnemonic): void</a></h4>
<p>Checks is the mnemonic is valid. If a mnemonic was generated with <code>generate_mnemonic()</code>, the mnemonic here should match the generated.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td>mnemonic</td><td><code>str</code></td><td><code>undefined</code></td><td>The provided mnemonic</td></tr>
</tbody></table>
<h4 id="create_accountclient_options-a-hreflibrarieswallet-libdocslibrariespythonapi_referencehtmlaccountinitialiseraccountinitialisera"><a class="header" href="#create_accountclient_options-a-hreflibrarieswallet-libdocslibrariespythonapi_referencehtmlaccountinitialiseraccountinitialisera">create_account(client_options): <a href="libraries/wallet-lib/docs/libraries/python/api_reference.html#accountinitialiser">AccountInitialiser</a></a></h4>
<p>Creat a new account.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td>client_options</td><td><code><a href="libraries/wallet-lib/docs/libraries/python/api_reference.html#clientoptions">ClientOptions</a></code></td><td><code>undefined</code></td><td>The client options</td></tr>
</tbody></table>
<p><strong>Returns</strong> A constructed <a href="libraries/wallet-lib/docs/libraries/python/api_reference.html#accountinitialiser">AccountInitialiser</a>.</p>
<h4 id="remove_accountaccount_id-void"><a class="header" href="#remove_accountaccount_id-void">remove_account(account_id): void</a></h4>
<p>Deletes an account.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td>account_id</td><td><code>str</code></td><td><code>undefined</code></td><td>The account with this id to be deleted</td></tr>
</tbody></table>
<h4 id="sync_accounts-a-hreflibrarieswallet-libdocslibrariespythonapi_referencehtmlaccountssynchronizeraccountssynchronizera"><a class="header" href="#sync_accounts-a-hreflibrarieswallet-libdocslibrariespythonapi_referencehtmlaccountssynchronizeraccountssynchronizera">sync_accounts(): <a href="libraries/wallet-lib/docs/libraries/python/api_reference.html#accountssynchronizer">AccountsSynchronizer</a></a></h4>
<p><strong>Returns</strong> the <a href="libraries/wallet-lib/docs/libraries/python/api_reference.html#accountssynchronizer">AccountsSynchronizer</a> to setup the process to synchronize the accounts with the Tangle.</p>
<h4 id="internal_transferfrom_account_id-to_account_id-amount-walletmessage"><a class="header" href="#internal_transferfrom_account_id-to_account_id-amount-walletmessage">internal_transfer(from_account_id, to_account_id, amount): WalletMessage</a></h4>
<p>Transfers an amount from an account to another.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td>from_account_id</td><td><code>str</code></td><td><code>undefined</code></td><td>The source of account id in the transfering</td></tr>
<tr><td>to_account_id</td><td><code>str</code></td><td><code>undefined</code></td><td>The destination of account id in the transfering</td></tr>
<tr><td>amount</td><td><code>int</code></td><td><code>undefined</code></td><td>The transfer amount</td></tr>
</tbody></table>
<p><strong>Returns</strong> The transfer's <a href="libraries/wallet-lib/docs/libraries/python/api_reference.html#walletmessage">WalletMessage</a>.</p>
<h4 id="backupdestination-stronghold_password-str"><a class="header" href="#backupdestination-stronghold_password-str">backup(destination, stronghold_password): str</a></h4>
<p>Backups the storage to the given destination.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td>destination</td><td><code>str</code></td><td><code>undefined</code></td><td>The path to the backup file</td></tr>
<tr><td>stronghold_password</td><td><code>str</code></td><td><code>undefined</code></td><td>The backup stronghold password</td></tr>
</tbody></table>
<p><strong>Returns</strong> The full path to the backup file.</p>
<h4 id="import_accountssource-stronghold_password-void"><a class="header" href="#import_accountssource-stronghold_password-void">import_accounts(source, stronghold_password): void</a></h4>
<p>Imports a database file.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td>source</td><td><code>str</code></td><td><code>undefined</code></td><td>The path to the backup file</td></tr>
<tr><td>stronghold_password</td><td><code>str</code></td><td><code>undefined</code></td><td>The backup stronghold password</td></tr>
</tbody></table>
<h4 id="get_accountaccount_id-a-hreflibrarieswallet-libdocslibrariespythonapi_referencehtmlaccounthandleaccounthandlea"><a class="header" href="#get_accountaccount_id-a-hreflibrarieswallet-libdocslibrariespythonapi_referencehtmlaccounthandleaccounthandlea">get_account(account_id): <a href="libraries/wallet-lib/docs/libraries/python/api_reference.html#accounthandle">AccountHandle</a></a></h4>
<p>Gets the account with the given identifier or index.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td>account_id</td><td><code>str</code></td><td><code>undefined</code></td><td>The account id, alias, index or one of its addresses</td></tr>
</tbody></table>
<p><strong>Returns</strong> the associated AccountHandle object or undefined if the account wasn't found.</p>
<h4 id="get_accounts-lista-hreflibrarieswallet-libdocslibrariespythonapi_referencehtmlaccounthandleaccounthandlea"><a class="header" href="#get_accounts-lista-hreflibrarieswallet-libdocslibrariespythonapi_referencehtmlaccounthandleaccounthandlea">get_accounts(): list[<a href="libraries/wallet-lib/docs/libraries/python/api_reference.html#accounthandle">AccountHandle</a>]</a></h4>
<p>Gets all stored accounts.</p>
<p><strong>Returns</strong> an list of <a href="libraries/wallet-lib/docs/libraries/python/api_reference.html#accounthandle">AccountHandle</a>.</p>
<h4 id="retryaccount_id-message_id-a-hreflibrarieswallet-libdocslibrariespythonapi_referencehtmlwalletmessagewalletmessagea"><a class="header" href="#retryaccount_id-message_id-a-hreflibrarieswallet-libdocslibrariespythonapi_referencehtmlwalletmessagewalletmessagea">retry(account_id, message_id): <a href="libraries/wallet-lib/docs/libraries/python/api_reference.html#walletmessage">WalletMessage</a></a></h4>
<p>Retries (promotes or reattaches) the given message.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td>account_id</td><td><code>str</code></td><td><code>undefined</code></td><td>The account id, alias, index or one of its addresses</td></tr>
<tr><td>message_id</td><td><code>str</code></td><td><code>undefined</code></td><td>The message's identifier</td></tr>
</tbody></table>
<p><strong>Returns</strong> the retried <a href="libraries/wallet-lib/docs/libraries/python/api_reference.html#walletmessage">WalletMessage</a>.</p>
<h4 id="reattachaccount_id-message_id-a-hreflibrarieswallet-libdocslibrariespythonapi_referencehtmlwalletmessagewalletmessagea"><a class="header" href="#reattachaccount_id-message_id-a-hreflibrarieswallet-libdocslibrariespythonapi_referencehtmlwalletmessagewalletmessagea">reattach(account_id, message_id): <a href="libraries/wallet-lib/docs/libraries/python/api_reference.html#walletmessage">WalletMessage</a></a></h4>
<p>Reattach the given message.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td>account_id</td><td><code>str</code></td><td><code>undefined</code></td><td>The account id, alias, index or one of its addresses</td></tr>
<tr><td>message_id</td><td><code>str</code></td><td><code>undefined</code></td><td>The message's identifier</td></tr>
</tbody></table>
<p><strong>Returns</strong> the reattached <a href="libraries/wallet-lib/docs/libraries/python/api_reference.html#walletmessage">WalletMessage</a>.</p>
<h4 id="promoteaccount_id-message_id-a-hreflibrarieswallet-libdocslibrariespythonapi_referencehtmlwalletmessagewalletmessagea"><a class="header" href="#promoteaccount_id-message_id-a-hreflibrarieswallet-libdocslibrariespythonapi_referencehtmlwalletmessagewalletmessagea">promote(account_id, message_id): <a href="libraries/wallet-lib/docs/libraries/python/api_reference.html#walletmessage">WalletMessage</a></a></h4>
<p>Promote the given message.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td>account_id</td><td><code>str</code></td><td><code>undefined</code></td><td>The account id, alias, index or one of its addresses</td></tr>
<tr><td>message_id</td><td><code>str</code></td><td><code>undefined</code></td><td>The message's identifier</td></tr>
</tbody></table>
<p><strong>Returns</strong> the promoted <a href="libraries/wallet-lib/docs/libraries/python/api_reference.html#walletmessage">WalletMessage</a>.</p>
<h4 id="get_balance_change_eventscount-optional-skip-optional-from_timestamp-optional"><a class="header" href="#get_balance_change_eventscount-optional-skip-optional-from_timestamp-optional">get_balance_change_events(count (optional), skip (optional), from_timestamp (optional))</a></h4>
<p>Gets the persisted balance change events.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td>count</td><td><code>number</code></td><td><code>0</code></td><td>The number of events to return (<code>0</code> to return all)</td></tr>
<tr><td>skip</td><td><code>number</code></td><td><code>0</code></td><td>The number of events to skip</td></tr>
<tr><td>from_timestamp</td><td><code>number</code></td><td><code>null</code></td><td>Filter events that were stored after the given UTC timestamp</td></tr>
</tbody></table>
<p>Event object: { accountId: string, address: string, balanceChange: { spent: number, received: number } }</p>
<h4 id="get_balance_change_event_countfrom_timestamp-optional"><a class="header" href="#get_balance_change_event_countfrom_timestamp-optional">get_balance_change_event_count(from_timestamp (optional))</a></h4>
<p>Gets the number of persisted balance change events.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td>from_timestamp</td><td><code>number</code></td><td><code>null</code></td><td>Filter events that were stored after the given UTC timestamp</td></tr>
</tbody></table>
<h4 id="get_transaction_confirmation_eventscount-optional-skip-optional-from_timestamp-optional"><a class="header" href="#get_transaction_confirmation_eventscount-optional-skip-optional-from_timestamp-optional">get_transaction_confirmation_events(count (optional), skip (optional), from_timestamp (optional))</a></h4>
<p>Gets the persisted transaction confirmation change events.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td>count</td><td><code>number</code></td><td><code>0</code></td><td>The number of events to return (<code>0</code> to return all)</td></tr>
<tr><td>skip</td><td><code>number</code></td><td><code>0</code></td><td>The number of events to skip</td></tr>
<tr><td>from_timestamp</td><td><code>number</code></td><td><code>null</code></td><td>Filter events that were stored after the given UTC timestamp</td></tr>
</tbody></table>
<p>Event object: { accountId: string, message: Message, confirmed: boolean }</p>
<h4 id="get_transaction_confirmation_event_countfrom_timestamp-optional"><a class="header" href="#get_transaction_confirmation_event_countfrom_timestamp-optional">get_transaction_confirmation_event_count(from_timestamp (optional))</a></h4>
<p>Gets the number of persisted transaction confirmation change events.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td>from_timestamp</td><td><code>number</code></td><td><code>null</code></td><td>Filter events that were stored after the given UTC timestamp</td></tr>
</tbody></table>
<h4 id="get_new_transaction_eventscount-optional-skip-optional-from_timestamp-optional"><a class="header" href="#get_new_transaction_eventscount-optional-skip-optional-from_timestamp-optional">get_new_transaction_events(count (optional), skip (optional), from_timestamp (optional))</a></h4>
<p>Gets the persisted new transaction events.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td>count</td><td><code>number</code></td><td><code>0</code></td><td>The number of events to return (<code>0</code> to return all)</td></tr>
<tr><td>skip</td><td><code>number</code></td><td><code>0</code></td><td>The number of events to skip</td></tr>
<tr><td>from_timestamp</td><td><code>number</code></td><td><code>null</code></td><td>Filter events that were stored after the given UTC timestamp</td></tr>
</tbody></table>
<p>Event object: { accountId: string, message: Message }</p>
<h4 id="get_new_transaction_event_countfrom_timestamp-optional"><a class="header" href="#get_new_transaction_event_countfrom_timestamp-optional">get_new_transaction_event_count(from_timestamp (optional))</a></h4>
<p>Gets the number of persisted new transaction events.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td>from_timestamp</td><td><code>number</code></td><td><code>null</code></td><td>Filter events that were stored after the given UTC timestamp</td></tr>
</tbody></table>
<h4 id="get_reattachment_eventscount-optional-skip-optional-from_timestamp-optional"><a class="header" href="#get_reattachment_eventscount-optional-skip-optional-from_timestamp-optional">get_reattachment_events(count (optional), skip (optional), from_timestamp (optional))</a></h4>
<p>Gets the persisted transaction reattachment events.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td>count</td><td><code>number</code></td><td><code>0</code></td><td>The number of events to return (<code>0</code> to return all)</td></tr>
<tr><td>skip</td><td><code>number</code></td><td><code>0</code></td><td>The number of events to skip</td></tr>
<tr><td>from_timestamp</td><td><code>number</code></td><td><code>null</code></td><td>Filter events that were stored after the given UTC timestamp</td></tr>
</tbody></table>
<p>Event object: { accountId: string, message: Message }</p>
<h4 id="get_reattachment_event_countfrom_timestamp-optional"><a class="header" href="#get_reattachment_event_countfrom_timestamp-optional">get_reattachment_event_count(from_timestamp (optional))</a></h4>
<p>Gets the number of persisted transaction reattachment events.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td>from_timestamp</td><td><code>number</code></td><td><code>null</code></td><td>Filter events that were stored after the given UTC timestamp</td></tr>
</tbody></table>
<h4 id="get_broadcast_eventscount-optional-skip-optional-from_timestamp-optional"><a class="header" href="#get_broadcast_eventscount-optional-skip-optional-from_timestamp-optional">get_broadcast_events(count (optional), skip (optional), from_timestamp (optional))</a></h4>
<p>Gets the persisted transaction broadcast events.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td>count</td><td><code>number</code></td><td><code>0</code></td><td>The number of events to return (<code>0</code> to return all)</td></tr>
<tr><td>skip</td><td><code>number</code></td><td><code>0</code></td><td>The number of events to skip</td></tr>
<tr><td>from_timestamp</td><td><code>number</code></td><td><code>null</code></td><td>Filter events that were stored after the given UTC timestamp</td></tr>
</tbody></table>
<p>Event object: { accountId: string, message: Message }</p>
<h4 id="get_broadcast_event_countfrom_timestamp-optional"><a class="header" href="#get_broadcast_event_countfrom_timestamp-optional">get_broadcast_event_count(from_timestamp (optional))</a></h4>
<p>Gets the number of persisted transaction broadcast events.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td>from_timestamp</td><td><code>number</code></td><td><code>null</code></td><td>Filter events that were stored after the given UTC timestamp</td></tr>
</tbody></table>
<h3 id="accountsynchronizer"><a class="header" href="#accountsynchronizer">AccountSynchronizer</a></h3>
<h4 id="gap_limitlimit-void"><a class="header" href="#gap_limitlimit-void">gap_limit(limit): void</a></h4>
<p>Set the number of address indexes that are generated.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td>limit</td><td><code>int</code></td><td><code>undefined</code></td><td>The number of address indexes that are generated</td></tr>
</tbody></table>
<h4 id="skip_persistence-void"><a class="header" href="#skip_persistence-void">skip_persistence(): void</a></h4>
<p>Skip saving new messages and addresses on the account object.
The found <a href="libraries/wallet-lib/docs/libraries/python/api_reference.html#syncedaccount">SyncedAccount</a> is returned on the <code>execute</code> call but won't be persisted on the database.</p>
<h4 id="address_indexaddress_index-void"><a class="header" href="#address_indexaddress_index-void">address_index(address_index): void</a></h4>
<p>Set the initial address index to start syncing.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td>address_index</td><td><code>int</code></td><td><code>undefined</code></td><td>The initial address index to start syncing</td></tr>
</tbody></table>
<h4 id="execute-a-hreflibrarieswallet-libdocslibrariespythonapi_referencehtmlsyncedaccountsyncedaccounta"><a class="header" href="#execute-a-hreflibrarieswallet-libdocslibrariespythonapi_referencehtmlsyncedaccountsyncedaccounta">execute(): <a href="libraries/wallet-lib/docs/libraries/python/api_reference.html#syncedaccount">SyncedAccount</a></a></h4>
<p>Syncs account with the tangle.
The account syncing process ensures that the latest metadata (balance, transactions) associated with an account is fetched from the tangle and is stored locally.</p>
<h3 id="accountssynchronizer"><a class="header" href="#accountssynchronizer">AccountsSynchronizer</a></h3>
<h4 id="gap_limitlimit-void-1"><a class="header" href="#gap_limitlimit-void-1">gap_limit(limit): void</a></h4>
<p>Set the number of address indexes that are generated on each account.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td>limit</td><td><code>int</code></td><td><code>undefined</code></td><td>The number of address indexes that are generated on each account</td></tr>
</tbody></table>
<h4 id="address_indexaddress_index-void-1"><a class="header" href="#address_indexaddress_index-void-1">address_index(address_index): void</a></h4>
<p>Set the initial address index to start syncing on each account.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td>address_index</td><td><code>int</code></td><td><code>undefined</code></td><td>The initial address index to start syncing on each account</td></tr>
</tbody></table>
<h4 id="execute-lista-hreflibrarieswallet-libdocslibrariespythonapi_referencehtmlsyncedaccountsyncedaccounta"><a class="header" href="#execute-lista-hreflibrarieswallet-libdocslibrariespythonapi_referencehtmlsyncedaccountsyncedaccounta">execute(): list<a href="libraries/wallet-lib/docs/libraries/python/api_reference.html#syncedaccount">SyncedAccount</a></a></h4>
<p>Syncs the accounts with the tangle.</p>
<h3 id="transfer"><a class="header" href="#transfer">Transfer</a></h3>
<h4 id="constructoramount-address-indexation-optional-remainder_value_strategy-str-a-hreflibrarieswallet-libdocslibrariespythonapi_referencehtmltransfertransfera"><a class="header" href="#constructoramount-address-indexation-optional-remainder_value_strategy-str-a-hreflibrarieswallet-libdocslibrariespythonapi_referencehtmltransfertransfera">constructor(amount, address, indexation (optional), remainder_value_strategy: str): <a href="libraries/wallet-lib/docs/libraries/python/api_reference.html#transfer">Transfer</a></a></h4>
<p>The <code>Transfer</code> object used in <a href="libraries/wallet-lib/docs/libraries/python/api_reference.html#syncedaccount">SyncedAccount</a></p>
<table><thead><tr><th>Param</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td>amount</td><td><code>int</code></td><td><code>undefined</code></td><td>The amount to transfer</td></tr>
<tr><td>address</td><td><code>str</code></td><td><code>undefined</code></td><td>The addree to send</td></tr>
<tr><td>indexation</td><td><code><a href="libraries/wallet-lib/docs/libraries/python/api_reference.html#indexation">Indexation</a></code></td><td><code>undefined</code></td><td>The indexation payload</td></tr>
<tr><td>remainder_value_strategy</td><td><code>str</code></td><td><code>undefined</code></td><td>Should be <code>ReuseAddress</code> or <code>ChangeAddress</code></td></tr>
</tbody></table>
<h3 id="syncedaccount-1"><a class="header" href="#syncedaccount-1">SyncedAccount</a></h3>
<p>The result of a <code>sync</code> operation on an Account.</p>
<h4 id="account_handle-a-hreflibrarieswallet-libdocslibrariespythonapi_referencehtmlaccounthandleaccounthandlea"><a class="header" href="#account_handle-a-hreflibrarieswallet-libdocslibrariespythonapi_referencehtmlaccounthandleaccounthandlea">account_handle(): <a href="libraries/wallet-lib/docs/libraries/python/api_reference.html#accounthandle">AccountHandle</a></a></h4>
<p>Get the <a href="libraries/wallet-lib/docs/libraries/python/api_reference.html#accounthandle">AccountHandle</a> of this account</p>
<p><strong>Returns</strong> the <a href="libraries/wallet-lib/docs/libraries/python/api_reference.html#accounthandle">AccountHandle</a>.</p>
<h4 id="deposit_address-a-hreflibrarieswallet-libdocslibrariespythonapi_referencehtmladdressaddressa"><a class="header" href="#deposit_address-a-hreflibrarieswallet-libdocslibrariespythonapi_referencehtmladdressaddressa">deposit_address(): <a href="libraries/wallet-lib/docs/libraries/python/api_reference.html#address">Address</a></a></h4>
<p>Get the deposit_address of this account.</p>
<p><strong>Returns</strong> the <a href="libraries/wallet-lib/docs/libraries/python/api_reference.html#address">Address</a>.</p>
<h4 id="messages-a-hreflibrarieswallet-libdocslibrariespythonapi_referencehtmlwalletmessagewalletmessagea"><a class="header" href="#messages-a-hreflibrarieswallet-libdocslibrariespythonapi_referencehtmlwalletmessagewalletmessagea">messages(): <a href="libraries/wallet-lib/docs/libraries/python/api_reference.html#walletmessage">WalletMessage</a></a></h4>
<p>Get the messages of this account.</p>
<p><strong>Returns</strong> the <a href="libraries/wallet-lib/docs/libraries/python/api_reference.html#walletmessage">WalletMessage</a>.</p>
<h4 id="addresses"><a class="header" href="#addresses">addresses()</a></h4>
<p>Get the addresses of this account.</p>
<p><strong>Returns</strong> the list of <a href="libraries/wallet-lib/docs/libraries/python/api_reference.html#walletmessage">WalletMessage</a>.</p>
<h3 id="accounthandle"><a class="header" href="#accounthandle">AccountHandle</a></h3>
<h4 id="id-str"><a class="header" href="#id-str">id(): str</a></h4>
<p><strong>Returns</strong> the account ID.</p>
<h4 id="signer_type-str"><a class="header" href="#signer_type-str">signer_type(): str</a></h4>
<p><strong>Returns</strong> the singer type of this account.</p>
<h4 id="index-int"><a class="header" href="#index-int">index(): int</a></h4>
<p><strong>Returns</strong> the account index.</p>
<h4 id="alias-str"><a class="header" href="#alias-str">alias(): str</a></h4>
<p><strong>Returns</strong> the account alias.</p>
<h4 id="created_at-int"><a class="header" href="#created_at-int">created_at(): int</a></h4>
<p><strong>Returns</strong> the created UNIX timestamp.</p>
<h4 id="last_synced_at-int-or-none-it-did-not-be-synced-before"><a class="header" href="#last_synced_at-int-or-none-it-did-not-be-synced-before">last_synced_at(): int or None (it did not be synced before)</a></h4>
<p><strong>Returns</strong> the last synced UNIX timestamp.</p>
<h4 id="client_options-a-hreflibrarieswallet-libdocslibrariespythonapi_referencehtmlclientoptionsclientoptionsa"><a class="header" href="#client_options-a-hreflibrarieswallet-libdocslibrariespythonapi_referencehtmlclientoptionsclientoptionsa">client_options(): <a href="libraries/wallet-lib/docs/libraries/python/api_reference.html#clientoptions">ClientOptions</a></a></h4>
<p><strong>Returns</strong> the client options of this account.</p>
<h4 id="bech32_hrp-str"><a class="header" href="#bech32_hrp-str">bech32_hrp(): str</a></h4>
<p><strong>Returns</strong> the Bech32 HRP string.</p>
<h4 id="sync-a-hreflibrarieswallet-libdocslibrariespythonapi_referencehtmlaccountsynchronizeraccountsynchronizera"><a class="header" href="#sync-a-hreflibrarieswallet-libdocslibrariespythonapi_referencehtmlaccountsynchronizeraccountsynchronizera">sync(): <a href="libraries/wallet-lib/docs/libraries/python/api_reference.html#accountsynchronizer">AccountSynchronizer</a></a></h4>
<p><strong>Returns</strong> the <a href="libraries/wallet-lib/docs/libraries/python/api_reference.html#accountsynchronizer">AccountSynchronizer</a> to setup the process to synchronize this account with the Tangle.</p>
<h4 id="transfertransfer_obj-a-hreflibrarieswallet-libdocslibrariespythonapi_referencehtmlwalletmessagewalletmessagea"><a class="header" href="#transfertransfer_obj-a-hreflibrarieswallet-libdocslibrariespythonapi_referencehtmlwalletmessagewalletmessagea">transfer(transfer_obj): <a href="libraries/wallet-lib/docs/libraries/python/api_reference.html#walletmessage">WalletMessage</a></a></h4>
<p>Transfer tokens.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td>transfer_obj</td><td><code><a href="libraries/wallet-lib/docs/libraries/python/api_reference.html#transfer">Transfer</a></code></td><td><code>undefined</code></td><td>The transfer we want to make</td></tr>
</tbody></table>
<p><strong>Returns</strong> the <a href="libraries/wallet-lib/docs/libraries/python/api_reference.html#walletmessage">WalletMessage</a> which makes the transfering.</p>
<h4 id="retrymessage_id-a-hreflibrarieswallet-libdocslibrariespythonapi_referencehtmlwalletmessagewalletmessagea"><a class="header" href="#retrymessage_id-a-hreflibrarieswallet-libdocslibrariespythonapi_referencehtmlwalletmessagewalletmessagea">retry(message_id): <a href="libraries/wallet-lib/docs/libraries/python/api_reference.html#walletmessage">WalletMessage</a></a></h4>
<p>Retries (promotes or reattaches) the given message.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td>message_id</td><td><code>str</code></td><td><code>undefined</code></td><td>The message's identifier</td></tr>
</tbody></table>
<p><strong>Returns</strong> the retried <a href="libraries/wallet-lib/docs/libraries/python/api_reference.html#walletmessage">WalletMessage</a>.</p>
<h4 id="reattachmessage_id-a-hreflibrarieswallet-libdocslibrariespythonapi_referencehtmlwalletmessagewalletmessagea"><a class="header" href="#reattachmessage_id-a-hreflibrarieswallet-libdocslibrariespythonapi_referencehtmlwalletmessagewalletmessagea">reattach(message_id): <a href="libraries/wallet-lib/docs/libraries/python/api_reference.html#walletmessage">WalletMessage</a></a></h4>
<p>Reattach the given message.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td>message_id</td><td><code>str</code></td><td><code>undefined</code></td><td>The message's identifier</td></tr>
</tbody></table>
<p><strong>Returns</strong> the reattached <a href="libraries/wallet-lib/docs/libraries/python/api_reference.html#walletmessage">WalletMessage</a>.</p>
<h4 id="promotemessage_id-a-hreflibrarieswallet-libdocslibrariespythonapi_referencehtmlwalletmessagewalletmessagea"><a class="header" href="#promotemessage_id-a-hreflibrarieswallet-libdocslibrariespythonapi_referencehtmlwalletmessagewalletmessagea">promote(message_id): <a href="libraries/wallet-lib/docs/libraries/python/api_reference.html#walletmessage">WalletMessage</a></a></h4>
<p>Promote the given message.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td>message_id</td><td><code>str</code></td><td><code>undefined</code></td><td>The message's identifier</td></tr>
</tbody></table>
<p><strong>Returns</strong> the promoted <a href="libraries/wallet-lib/docs/libraries/python/api_reference.html#walletmessage">WalletMessage</a>.</p>
<h4 id="consolidate_outputs-lista-hreflibrarieswallet-libdocslibrariespythonapi_referencehtmlwalletmessagewalletmessagea"><a class="header" href="#consolidate_outputs-lista-hreflibrarieswallet-libdocslibrariespythonapi_referencehtmlwalletmessagewalletmessagea">consolidate_outputs(): list<a href="libraries/wallet-lib/docs/libraries/python/api_reference.html#walletmessage">WalletMessage</a></a></h4>
<p>Consolidates the account addresses outputs.</p>
<p><strong>Returns</strong> the list of generated <a href="libraries/wallet-lib/docs/libraries/python/api_reference.html#walletmessage">WalletMessage</a>.</p>
<h4 id="generate_address-a-hreflibrarieswallet-libdocslibrariespythonapi_referencehtmladdressaddressa"><a class="header" href="#generate_address-a-hreflibrarieswallet-libdocslibrariespythonapi_referencehtmladdressaddressa">generate_address(): <a href="libraries/wallet-lib/docs/libraries/python/api_reference.html#address">Address</a></a></h4>
<p><strong>Returns</strong> a new unused address and links it to this account.</p>
<h4 id="get_unused_address-a-hreflibrarieswallet-libdocslibrariespythonapi_referencehtmladdressaddressa"><a class="header" href="#get_unused_address-a-hreflibrarieswallet-libdocslibrariespythonapi_referencehtmladdressaddressa">get_unused_address(): <a href="libraries/wallet-lib/docs/libraries/python/api_reference.html#address">Address</a></a></h4>
<p>Synchronizes the account addresses with the Tangle and returns the latest address in the account, which is an address without balance.</p>
<p><strong>Returns</strong> the latest address in the account.</p>
<h4 id="is_latest_address_unused-bool-1"><a class="header" href="#is_latest_address_unused-bool-1">is_latest_address_unused(): bool</a></h4>
<p>Syncs the latest address with the Tangle and determines whether it's unused or not.
An unused address is an address without balance and associated message history.
Note that such address might have been used in the past, because the message history might have been pruned by the node.</p>
<p><strong>Returns</strong> <code>true</code> if the latest address in the account is unused.</p>
<h4 id="latest_address-a-hreflibrarieswallet-libdocslibrariespythonapi_referencehtmladdressaddressa"><a class="header" href="#latest_address-a-hreflibrarieswallet-libdocslibrariespythonapi_referencehtmladdressaddressa">latest_address(): <a href="libraries/wallet-lib/docs/libraries/python/api_reference.html#address">Address</a></a></h4>
<p><strong>Returns</strong> the most recent address of the account.</p>
<h4 id="addresses-lista-hreflibrarieswallet-libdocslibrariespythonapi_referencehtmladdressaddressa"><a class="header" href="#addresses-lista-hreflibrarieswallet-libdocslibrariespythonapi_referencehtmladdressaddressa">addresses(): list[<a href="libraries/wallet-lib/docs/libraries/python/api_reference.html#address">Address</a>]</a></h4>
<p><strong>Returns</strong> a list of <a href="libraries/wallet-lib/docs/libraries/python/api_reference.html#address">Address</a> in the account.</p>
<h4 id="balance-a-hreflibrarieswallet-libdocslibrariespythonapi_referencehtmlaccountbalanceaccountbalancea"><a class="header" href="#balance-a-hreflibrarieswallet-libdocslibrariespythonapi_referencehtmlaccountbalanceaccountbalancea">balance(): <a href="libraries/wallet-lib/docs/libraries/python/api_reference.html#accountbalance">AccountBalance</a></a></h4>
<p>Gets the account balance information.</p>
<p><strong>Returns</strong> the <a href="libraries/wallet-lib/docs/libraries/python/api_reference.html#accountbalance">AccountBalance</a> in this account.</p>
<h4 id="get_node_infourl-optional-nodeinfowrapper"><a class="header" href="#get_node_infourl-optional-nodeinfowrapper">get_node_info(url (optional)): NodeInfoWrapper</a></h4>
<p>Gets information about the node.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td>url</td><td><code>str</code></td><td><code>undefined</code></td><td>The node url</td></tr>
</tbody></table>
<p><strong>Returns</strong> the <a href="libraries/wallet-lib/docs/libraries/python/api_reference.html#nodeinfowrapper">NodeInfoWrapper</a></p>
<h4 id="set_aliasalias-void"><a class="header" href="#set_aliasalias-void">set_alias(alias): void</a></h4>
<p>Updates the account alias.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td>alias</td><td><code>str</code></td><td><code>undefined</code></td><td>The account alias to set</td></tr>
</tbody></table>
<h4 id="set_client_optionsoptions-void"><a class="header" href="#set_client_optionsoptions-void">set_client_options(options): void</a></h4>
<p>Updates the account's client options.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td>options</td><td><code><a href="libraries/wallet-lib/docs/libraries/python/api_reference.html#clientoptions">ClientOptions</a></code></td><td><code>undefined</code></td><td>The client options to set</td></tr>
</tbody></table>
<h4 id="message_countmessage_type-optional-int"><a class="header" href="#message_countmessage_type-optional-int">message_count(message_type (optional)): int</a></h4>
<p>Returns the number of messages associated with the account.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td>message_type</td><td><code>str</code></td><td><code>undefined</code></td><td>Should be <code>Received</code>, <code>Sent</code>, <code>Failed</code>, <code>Unconfirmed</code>, or <code>Value</code></td></tr>
</tbody></table>
<h4 id="list_messagescount-from-message_type-optional-lista-hreflibrarieswallet-libdocslibrariespythonapi_referencehtmlwalletmessagewalletmessagea"><a class="header" href="#list_messagescount-from-message_type-optional-lista-hreflibrarieswallet-libdocslibrariespythonapi_referencehtmlwalletmessagewalletmessagea">list_messages(count, from, message_type (optional)): list(<a href="libraries/wallet-lib/docs/libraries/python/api_reference.html#walletmessage">WalletMessage</a>)</a></h4>
<p>Get the list of messages of this account.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td>count</td><td><code>int</code></td><td><code>undefined</code></td><td>The count of the messages to get</td></tr>
<tr><td>from</td><td><code>int</code></td><td><code>undefined</code></td><td>The iniital address index</td></tr>
<tr><td>message_type</td><td><code>str</code></td><td><code>undefined</code></td><td>Should be <code>Received</code>, <code>Sent</code>, <code>Failed</code>, <code>Unconfirmed</code>, or <code>Value</code></td></tr>
</tbody></table>
<h4 id="list_spent_addresses-lista-hreflibrarieswallet-libdocslibrariespythonapi_referencehtmladdressaddressa"><a class="header" href="#list_spent_addresses-lista-hreflibrarieswallet-libdocslibrariespythonapi_referencehtmladdressaddressa">list_spent_addresses(): list[<a href="libraries/wallet-lib/docs/libraries/python/api_reference.html#address">Address</a>]</a></h4>
<p><strong>Returns</strong> the list of spent <a href="libraries/wallet-lib/docs/libraries/python/api_reference.html#address">Address</a> in the account.</p>
<h4 id="get_messagemessage_id-walletmessagewalletmessage-optional"><a class="header" href="#get_messagemessage_id-walletmessagewalletmessage-optional">get_message(message_id): WalletMessage](#walletmessage) (optional)</a></h4>
<p>Get the <a href="libraries/wallet-lib/docs/libraries/python/api_reference.html#walletmessage">WalletMessage</a> by the message identifier in the account if it exists.</p>
<h3 id="accountinitialiser"><a class="header" href="#accountinitialiser">AccountInitialiser</a></h3>
<h4 id="signer_typesigner_type-void"><a class="header" href="#signer_typesigner_type-void">signer_type(signer_type): void</a></h4>
<p>Sets the account type.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td>signer_type</td><td><code>str</code></td><td><code>signer_type</code></td><td>Should be <code>Stronghold</code>, <code>LedgerNano</code>, or <code>LedgerNanoSimulator</code></td></tr>
</tbody></table>
<h4 id="aliasalias-void"><a class="header" href="#aliasalias-void">alias(alias): void</a></h4>
<p>Defines the account alias. If not defined, we'll generate one.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td>alias</td><td><code>str</code></td><td><code>undefined</code></td><td>The account alias</td></tr>
</tbody></table>
<h4 id="created_atcreated_at-void"><a class="header" href="#created_atcreated_at-void">created_at(created_at): void</a></h4>
<p>Time of account creation.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td>created_at</td><td><code>u64</code></td><td><code>undefined</code></td><td>The account creation time</td></tr>
</tbody></table>
<h4 id="messagesmessages-void"><a class="header" href="#messagesmessages-void">messages(messages): void</a></h4>
<p>Messages associated with the seed.
The account can be initialised with locally stored messages.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td>messages</td><td><code>list(<a href="libraries/wallet-lib/docs/libraries/python/api_reference.html#walletmessage">WalletMessage</a>)</code></td><td><code>undefined</code></td><td>The locally stored messages</td></tr>
</tbody></table>
<h4 id="addressesaddresses-lista-hreflibrarieswallet-libdocslibrariespythonapi_referencehtmlwalletaddresswalletaddressa"><a class="header" href="#addressesaddresses-lista-hreflibrarieswallet-libdocslibrariespythonapi_referencehtmlwalletaddresswalletaddressa">addresses(addresses): list(<a href="libraries/wallet-lib/docs/libraries/python/api_reference.html#walletaddress">WalletAddress</a>)</a></h4>
<p>Address history associated with the seed.
The account can be initialised with locally stored address history.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td>addresses</td><td><code>list(<a href="libraries/wallet-lib/docs/libraries/python/api_reference.html#walletaddress">WalletAddress</a>)</code></td><td><code>undefined</code></td><td>The historical addresses</td></tr>
</tbody></table>
<h4 id="skip_persistence-void-1"><a class="header" href="#skip_persistence-void-1">skip_persistence(): void</a></h4>
<p>Skips storing the account to the database.</p>
<h4 id="initialise-a-hreflibrarieswallet-libdocslibrariespythonapi_referencehtmlaccounthandleaccounthandlea"><a class="header" href="#initialise-a-hreflibrarieswallet-libdocslibrariespythonapi_referencehtmlaccounthandleaccounthandlea">initialise(): <a href="libraries/wallet-lib/docs/libraries/python/api_reference.html#accounthandle">AccountHandle</a></a></h4>
<p>Initialises the account.</p>
<p><strong>Returns</strong> the initilized <a href="libraries/wallet-lib/docs/libraries/python/api_reference.html#accounthandle">AccountHandle</a></p>
<h3 id="event-listeners"><a class="header" href="#event-listeners">Event Listeners</a></h3>
<h4 id="on_balance_changecallback-listint"><a class="header" href="#on_balance_changecallback-listint">on_balance_change(callback): list[int]</a></h4>
<p>Listen to balance changes.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td>[callback]</td><td><code>function</code></td><td><code>undefined</code></td><td>The callback function</td></tr>
</tbody></table>
<p><strong>Returns</strong> the event id as list[int].</p>
<h4 id="remove_balance_change_listenerlistint-void"><a class="header" href="#remove_balance_change_listenerlistint-void">remove_balance_change_listener(list[int]): void</a></h4>
<p>Removes the balance change listener associated with the given identifier.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td>[id]</td><td><code>list[int]</code></td><td><code>undefined</code></td><td>The event id</td></tr>
</tbody></table>
<h4 id="on_new_transactioncallback-listint"><a class="header" href="#on_new_transactioncallback-listint">on_new_transaction(callback): list[int]</a></h4>
<p>Listen to new messages.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td>[callback]</td><td><code>function</code></td><td><code>undefined</code></td><td>The callback function</td></tr>
</tbody></table>
<p><strong>Returns</strong> the event id as list[int].</p>
<h4 id="remove_new_transaction_listenerlistint-void"><a class="header" href="#remove_new_transaction_listenerlistint-void">remove_new_transaction_listener(list[int]): void</a></h4>
<p>Removes the new transaction listener associated with the given identifier.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td>[id]</td><td><code>list[int]</code></td><td><code>undefined</code></td><td>The event id</td></tr>
</tbody></table>
<h4 id="on_confirmation_state_changecallback-listint"><a class="header" href="#on_confirmation_state_changecallback-listint">on_confirmation_state_change(callback): list[int]</a></h4>
<p>Listen to transaction confirmation state change.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td>[callback]</td><td><code>function</code></td><td><code>undefined</code></td><td>The callback function</td></tr>
</tbody></table>
<p><strong>Returns</strong> the event id as list[int].</p>
<h4 id="remove_confirmation_state_change_listenerlistint-void"><a class="header" href="#remove_confirmation_state_change_listenerlistint-void">remove_confirmation_state_change_listener(list[int]): void</a></h4>
<p>Removes the new transaction listener associated with the given identifier.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td>[id]</td><td><code>list[int]</code></td><td><code>undefined</code></td><td>The event id</td></tr>
</tbody></table>
<h4 id="on_reattachmentcallback-listint"><a class="header" href="#on_reattachmentcallback-listint">on_reattachment(callback): list[int]</a></h4>
<p>Listen to transaction reattachment.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td>[callback]</td><td><code>function</code></td><td><code>undefined</code></td><td>The callback function</td></tr>
</tbody></table>
<p><strong>Returns</strong> the event id as list[int].</p>
<h4 id="remove_reattachment_listenerlistint-void"><a class="header" href="#remove_reattachment_listenerlistint-void">remove_reattachment_listener(list[int]): void</a></h4>
<p>Removes the reattachment listener associated with the given identifier.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td>[id]</td><td><code>list[int]</code></td><td><code>undefined</code></td><td>The event id</td></tr>
</tbody></table>
<h4 id="on_broadcastcallback-listint"><a class="header" href="#on_broadcastcallback-listint">on_broadcast(callback): list[int]</a></h4>
<p>Listen to transaction broadcast.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td>[callback]</td><td><code>function</code></td><td><code>undefined</code></td><td>The callback function</td></tr>
</tbody></table>
<p><strong>Returns</strong> the event id as list[int].</p>
<h4 id="remove_broadcast_listenerlistint-void"><a class="header" href="#remove_broadcast_listenerlistint-void">remove_broadcast_listener(list[int]): void</a></h4>
<p>Removes the broadcast listener associated with the given identifier.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td>[id]</td><td><code>list[int]</code></td><td><code>undefined</code></td><td>The event id</td></tr>
</tbody></table>
<h4 id="on_errorcallback-listint"><a class="header" href="#on_errorcallback-listint">on_error(callback): list[int]</a></h4>
<p>Listen to errors.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td>[callback]</td><td><code>function</code></td><td><code>undefined</code></td><td>The callback function</td></tr>
</tbody></table>
<p><strong>Returns</strong> the event id as list[int].</p>
<h4 id="remove_error_listenerlistint-void"><a class="header" href="#remove_error_listenerlistint-void">remove_error_listener(list[int]): void</a></h4>
<p>Removes the error listener associated with the given identifier.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td>[id]</td><td><code>list[int]</code></td><td><code>undefined</code></td><td>The event id</td></tr>
</tbody></table>
<h4 id="on_stronghold_status_changecallback-listint"><a class="header" href="#on_stronghold_status_changecallback-listint">on_stronghold_status_change(callback): list[int]</a></h4>
<p>Listen to stronghold status change events.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td>[callback]</td><td><code>function</code></td><td><code>undefined</code></td><td>The callback function</td></tr>
</tbody></table>
<p><strong>Returns</strong> the event id as list[int].</p>
<h4 id="remove_stronghold_status_change_listenerlistint-void"><a class="header" href="#remove_stronghold_status_change_listenerlistint-void">remove_stronghold_status_change_listener(list[int]): void</a></h4>
<p>Removes the stronghold status change listener associated with the given identifier.</p>
<table><thead><tr><th>Param</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td>[id]</td><td><code>list[int]</code></td><td><code>undefined</code></td><td>The event id</td></tr>
</tbody></table>
<h3 id="walletaddress-1"><a class="header" href="#walletaddress-1">WalletAddress</a></h3>
<p>A dict with the following key/value pairs.</p>
<pre><code class="language-python">wallet_address = {
    'address': str,
    'balance': int,
    'key_index': int,
    'internal': bool,
    'outputs': dict[(string, WalletAddressOutput)],
}
</code></pre>
<p>Please refer to <a href="libraries/wallet-lib/docs/libraries/python/api_reference.html#walletaddressoutput">WalletAddressOutput</a> for the details of this type.</p>
<h3 id="walletaddressoutput"><a class="header" href="#walletaddressoutput">WalletAddressOutput</a></h3>
<p>A dict with the following key/value pairs.</p>
<pre><code class="language-python">wallet_address_output = {
    'transaction_id': str,
    'message_id': str,
    'index': int,
    'amount': int,
    'is_spent': bool,
    'address': str,
    'kind': str,
}
}
</code></pre>
<h3 id="address-2"><a class="header" href="#address-2">Address</a></h3>
<p>A dict with the following key/value pairs.</p>
<pre><code class="language-python">address = {
    'address': AddressWrapper,
    'balance': int,
    'key_index': int,
    'internal': bool,
    'outputs': list[AddressOutput],
}
</code></pre>
<p>Please refer to <a href="libraries/wallet-lib/docs/libraries/python/api_reference.html#addresswrapper">AddressWrapper</a> and <a href="libraries/wallet-lib/docs/libraries/python/api_reference.html#addressoutput">AddressOutput</a> for the details of this type.</p>
<h3 id="addresswrapper"><a class="header" href="#addresswrapper">AddressWrapper</a></h3>
<p>A dict with the following key/value pairs.</p>
<pre><code class="language-python">address_wrapper = {
    'inner': str
}
</code></pre>
<h3 id="addressoutput"><a class="header" href="#addressoutput">AddressOutput</a></h3>
<p>A dict with the following key/value pairs.</p>
<pre><code class="language-python">address_output = {
    'transaction_id': str,
    'message_id': str,
    'index': int,
    'amount': int,
    'is_spent': bool,
    'address': AddressWrapper,
}
</code></pre>
<p>Please refer to <a href="libraries/wallet-lib/docs/libraries/python/api_reference.html#addresswrapper">AddressWrapper</a> for the details of this type.</p>
<h3 id="accountbalance"><a class="header" href="#accountbalance">AccountBalance</a></h3>
<p>A dict with the following key/value pairs.</p>
<pre><code class="language-python">account_balance = {
    'total': int,
    'available': int,
    'incoming': int,
    'outgoing': int,
}
</code></pre>
<h3 id="clientoptions-1"><a class="header" href="#clientoptions-1">ClientOptions</a></h3>
<p>A dict with the following key/value pairs.</p>
<pre><code class="language-python">client_options = {
    'nodes': list[[Node](#node)] (optional),
    'node_pool_urls': list[str] (optional),
    'network': str (optional),
    'mqtt_broker_options': [BrokerOptions](#brokeroptions) (optional),
    'local_pow': bool (optional),
    'node_sync_interval': int (optional), # in milliseconds
    'node_sync_enabled': bool (optional),
    'request_timeout': int (optional), # in milliseconds
    'api_timeout': {
        'GetTips': int (optional) # in milliseconds
        'PostMessage': int (optional) # in milliseconds
        'GetOutput': int (optional) # in milliseconds
    } (optional)
}
</code></pre>
<p>Note that this message object in <code>wallet.rs</code> is not the same as the message object in <code>iota.rs</code>.</p>
<h3 id="node"><a class="header" href="#node">Node</a></h3>
<p>A dict with the following key/value pairs.</p>
<pre><code class="language-python">node = {
    'url': string,
    'auth': [NodeAuth](#nodeauth) (optional),
}
</code></pre>
<h3 id="nodeauth"><a class="header" href="#nodeauth">NodeAuth</a></h3>
<p>A dict with the following key/value pairs.</p>
<pre><code class="language-python">node = {
    'username': string,
    'password': string,
}
</code></pre>
<h3 id="brokeroptions-3"><a class="header" href="#brokeroptions-3">BrokerOptions</a></h3>
<p>A dict with the following key/value pairs.</p>
<pre><code class="language-python">broker_options = {
    'automatic_disconnect': bool (optional),
    'timeout': int (optional)
}
</code></pre>
<h3 id="walletmessage"><a class="header" href="#walletmessage">WalletMessage</a></h3>
<p>A dict with the following key/value pairs.</p>
<pre><code class="language-python">wallet_message = {
    'id': str,
    'version': u64,
    'parents': list[str],
    'payload_length': int,
    'payload': Payload,
    'timestamp': int,
    'nonce': int,
    'confirmed': bool (optional),
    'broadcasted': bool
}
</code></pre>
<p>Please refer to <a href="libraries/wallet-lib/docs/libraries/python/api_reference.html#payload">Payload</a> for the details of this type.</p>
<h3 id="payload-2"><a class="header" href="#payload-2">Payload</a></h3>
<p>A dict with the following key/value pairs.</p>
<pre><code class="language-python">payload = {
    'transaction': list[Transaction] (optional),
    'milestone': list[Milestone] (optional),
    'indexation': list[Indexation] (optional),
}
</code></pre>
<p>Please refer to <a href="libraries/wallet-lib/docs/libraries/python/api_reference.html#transaction">Transaction</a>, <a href="libraries/wallet-lib/docs/libraries/python/api_reference.html#milestone">Milestone</a>, and <a href="libraries/wallet-lib/docs/libraries/python/api_reference.html#indexation">Indexation</a> for the details of these types.</p>
<h3 id="transaction-1"><a class="header" href="#transaction-1">Transaction</a></h3>
<p>A dict with the following key/value pairs.</p>
<pre><code class="language-python">transaction = {
    'essence': {
        regular: RegularEssence
    },
    'unlock_blocks': list[UnlockBlock],
}
</code></pre>
<p>Please refer to <a href="libraries/wallet-lib/docs/libraries/python/api_reference.html#regularessence">RegularEssence</a> and <a href="libraries/wallet-lib/docs/libraries/python/api_reference.html#unlockblock">UnlockBlock</a> for the details of these types.</p>
<h3 id="milestone-2"><a class="header" href="#milestone-2">Milestone</a></h3>
<p>A dict with the following key/value pairs.</p>
<pre><code class="language-python">milestone = {
    'essence': MilestonePayloadEssence,
    'signatures': list[bytes],
}
</code></pre>
<p>Please refer to <a href="libraries/wallet-lib/docs/libraries/python/api_reference.html#milestonepayloadessence">MilestonePayloadEssence</a> for the details of this type.</p>
<h3 id="milestonepayloadessence-1"><a class="header" href="#milestonepayloadessence-1">MilestonePayloadEssence</a></h3>
<p>A dict with the following key/value pairs.</p>
<pre><code class="language-python">milestone_payload_essence = {
    'index': int,
    'timestamp': int,
    'parents': list[str],
    'merkle_proof': bytes,
    'public_keys': bytes
}
</code></pre>
<h3 id="indexation-1"><a class="header" href="#indexation-1">Indexation</a></h3>
<p>A dict with the following key/value pairs.</p>
<pre><code class="language-python">indexation = {
    'index': bytes,
    'data': bytes
}
</code></pre>
<h3 id="regularessenceessence"><a class="header" href="#regularessenceessence">RegularEssenceEssence</a></h3>
<p>A dict with the following key/value pairs.</p>
<pre><code class="language-python">transaction_regular_essence = {
    'inputs': list[Input],
    'outputs': list[Output],
    'payload': Payload (optional),
    'internal': bool,
    'incoming': bool,
    'value': int,
    'remainder_value': int,
}
</code></pre>
<p>Please refer to <a href="libraries/wallet-lib/docs/libraries/python/api_reference.html#input">Input</a>, <a href="libraries/wallet-lib/docs/libraries/python/api_reference.html#output">Output</a>, and <a href="libraries/wallet-lib/docs/libraries/python/api_reference.html#payload">Payload</a> for the details of these types.</p>
<h3 id="output-1"><a class="header" href="#output-1">Output</a></h3>
<p>A dict with the following key/value pairs.</p>
<pre><code class="language-python">output = {
    'address': str,
    'amount': int
}
</code></pre>
<h3 id="input-1"><a class="header" href="#input-1">Input</a></h3>
<p>A dict with the following key/value pairs.</p>
<pre><code class="language-python">input = {
    'transaction_id': str,
    'index': int
}
</code></pre>
<h3 id="unlockblock-1"><a class="header" href="#unlockblock-1">UnlockBlock</a></h3>
<p>A dict with the following key/value pairs.</p>
<pre><code class="language-python">unlock_block = {
    'signature': Ed25519Signature (optional),
    'reference': int (optional)
}
</code></pre>
<p>Please refer to <a href="libraries/wallet-lib/docs/libraries/python/api_reference.html#ed25519signature">Ed25519Signature</a> for the details of this type.</p>
<h3 id="ed25519signature-1"><a class="header" href="#ed25519signature-1">Ed25519Signature</a></h3>
<p>A dict with the following key/value pairs.</p>
<pre><code class="language-python">ed25519_signature = {
    'public_key': bytes,
    'public_key': bytes
}
</code></pre>
<h1 id="troubleshooting-5"><a class="header" href="#troubleshooting-5">Troubleshooting</a></h1>
<h2 id="stackexchange-5"><a class="header" href="#stackexchange-5">StackExchange</a></h2>
<blockquote>
<p><a href="https://iota.stackexchange.com/">https://iota.stackexchange.com</a></p>
</blockquote>
<p>The IOTA StackExchange a a nice Tool for developers to find  Answers for a problem. Just search your problem and find your answer! If there is no one, submit your question and share it in the discussion channel below.</p>
<h2 id="joining-the-discussion-13"><a class="header" href="#joining-the-discussion-13">Joining the discussion</a></h2>
<p>If you want to get involved in discussions about this library, or you're looking for support, go to the #clients-discussion channel on <a href="https://discord.iota.org">Discord</a>.</p>
<h1 id="wallet-library-spec"><a class="header" href="#wallet-library-spec">Wallet Library Spec</a></h1>
<h2 id="table-of-contents----omit-in-toc---"><a class="header" href="#table-of-contents----omit-in-toc---">Table of Contents <!-- omit in toc --></a></h2>
<ul>
<li><a href="libraries/wallet-lib/docs/specs/index.html#wallet-library-spec">Wallet Library Spec</a>
<ul>
<li><a href="libraries/wallet-lib/docs/specs/index.html#introduction">Introduction</a></li>
<li><a href="libraries/wallet-lib/docs/specs/index.html#considerations">Considerations</a></li>
<li><a href="libraries/wallet-lib/docs/specs/index.html#naming-conventions">Naming Conventions</a></li>
<li><a href="libraries/wallet-lib/docs/specs/index.html#interfaces">Interfaces</a>
<ul>
<li><a href="libraries/wallet-lib/docs/specs/index.html#accountconfiguration">AccountConfiguration</a></li>
<li><a href="libraries/wallet-lib/docs/specs/index.html#accountobject">AccountObject</a></li>
<li><a href="libraries/wallet-lib/docs/specs/index.html#syncedaccountobject">SyncedAccountObject</a></li>
<li><a href="libraries/wallet-lib/docs/specs/index.html#accountmanagerobject">AccountManagerObject</a></li>
<li><a href="libraries/wallet-lib/docs/specs/index.html#address">Address</a></li>
<li><a href="libraries/wallet-lib/docs/specs/index.html#node">Node</a></li>
<li><a href="libraries/wallet-lib/docs/specs/index.html#timestamp">Timestamp</a></li>
<li><a href="libraries/wallet-lib/docs/specs/index.html#transfer">Transfer</a></li>
<li><a href="libraries/wallet-lib/docs/specs/index.html#value">Value</a></li>
<li><a href="libraries/wallet-lib/docs/specs/index.html#input">Input</a></li>
<li><a href="libraries/wallet-lib/docs/specs/index.html#outputaddress">OutputAddress</a></li>
<li><a href="libraries/wallet-lib/docs/specs/index.html#output">Output</a></li>
<li><a href="libraries/wallet-lib/docs/specs/index.html#unsigneddatapayload">UnsignedDataPayload</a></li>
<li><a href="libraries/wallet-lib/docs/specs/index.html#signeddatapayload">SignedDataPayload</a></li>
<li><a href="libraries/wallet-lib/docs/specs/index.html#indexationpayload">IndexationPayload</a></li>
<li><a href="libraries/wallet-lib/docs/specs/index.html#unsignedtransaction">UnsignedTransaction</a></li>
<li><a href="libraries/wallet-lib/docs/specs/index.html#ed25519signature">Ed25519Signature</a></li>
<li><a href="libraries/wallet-lib/docs/specs/index.html#signatureunblockblock">SignatureUnblockBlock</a></li>
<li><a href="libraries/wallet-lib/docs/specs/index.html#referenceunblockblock">ReferenceUnblockBlock</a></li>
<li><a href="libraries/wallet-lib/docs/specs/index.html#signedtransactionpayload">SignedTransactionPayload</a></li>
<li><a href="libraries/wallet-lib/docs/specs/index.html#message">Message</a></li>
<li><a href="libraries/wallet-lib/docs/specs/index.html#storageadapter">StorageAdapter</a></li>
</ul>
</li>
<li><a href="libraries/wallet-lib/docs/specs/index.html#storage">Storage</a></li>
<li><a href="libraries/wallet-lib/docs/specs/index.html#storage-adapter">Storage Adapter</a></li>
<li><a href="libraries/wallet-lib/docs/specs/index.html#account">Account</a>
<ul>
<li><a href="libraries/wallet-lib/docs/specs/index.html#api">API</a>
<ul>
<li><a href="libraries/wallet-lib/docs/specs/index.html#initialisation">Initialisation</a></li>
<li><a href="libraries/wallet-lib/docs/specs/index.html#sync_addresses">sync_addresses()</a></li>
<li><a href="libraries/wallet-lib/docs/specs/index.html#sync_messages">sync_messages()</a></li>
<li><a href="libraries/wallet-lib/docs/specs/index.html#select_inputs">select_inputs()</a></li>
<li><a href="libraries/wallet-lib/docs/specs/index.html#send">send()</a></li>
<li><a href="libraries/wallet-lib/docs/specs/index.html#retry">retry()</a></li>
<li><a href="libraries/wallet-lib/docs/specs/index.html#sync">sync()</a></li>
<li><a href="libraries/wallet-lib/docs/specs/index.html#reattach">reattach()</a></li>
<li><a href="libraries/wallet-lib/docs/specs/index.html#total_balance">total_balance()</a></li>
<li><a href="libraries/wallet-lib/docs/specs/index.html#available_balance">available_balance()</a></li>
<li><a href="libraries/wallet-lib/docs/specs/index.html#set_alias">set_alias()</a></li>
<li><a href="libraries/wallet-lib/docs/specs/index.html#list_messages">list_messages()</a></li>
<li><a href="libraries/wallet-lib/docs/specs/index.html#list_received_messages">list_received_messages()</a></li>
<li><a href="libraries/wallet-lib/docs/specs/index.html#list_sent_messages">list_sent_messages()</a></li>
<li><a href="libraries/wallet-lib/docs/specs/index.html#list_failed_messages">list_failed_messages()</a></li>
<li><a href="libraries/wallet-lib/docs/specs/index.html#list_unconfirmed_messages">list_unconfirmed_messages()</a></li>
<li><a href="libraries/wallet-lib/docs/specs/index.html#get_message">get_message()</a></li>
<li><a href="libraries/wallet-lib/docs/specs/index.html#list_addresses">list_addresses()</a></li>
<li><a href="libraries/wallet-lib/docs/specs/index.html#list_unspent_addresses">list_unspent_addresses()</a></li>
<li><a href="libraries/wallet-lib/docs/specs/index.html#generate_address">generate_address()</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="libraries/wallet-lib/docs/specs/index.html#account-manager">Account Manager</a>
<ul>
<li><a href="libraries/wallet-lib/docs/specs/index.html#api-1">API</a>
<ul>
<li><a href="libraries/wallet-lib/docs/specs/index.html#initialisation-1">Initialisation</a></li>
<li><a href="libraries/wallet-lib/docs/specs/index.html#add_account">add_account()</a></li>
<li><a href="libraries/wallet-lib/docs/specs/index.html#remove_account">remove_account()</a></li>
<li><a href="libraries/wallet-lib/docs/specs/index.html#sync_accounts">sync_accounts()</a></li>
<li><a href="libraries/wallet-lib/docs/specs/index.html#move">move()</a></li>
<li><a href="libraries/wallet-lib/docs/specs/index.html#backup">backup()</a></li>
<li><a href="libraries/wallet-lib/docs/specs/index.html#import_accounts">import_accounts</a></li>
<li><a href="libraries/wallet-lib/docs/specs/index.html#get_account">get_account()</a></li>
<li><a href="libraries/wallet-lib/docs/specs/index.html#reattach-1">reattach()</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="libraries/wallet-lib/docs/specs/index.html#events">Events</a>
<ul>
<li><a href="libraries/wallet-lib/docs/specs/index.html#category-1-events">Category 1 events</a>
<ul>
<li><a href="libraries/wallet-lib/docs/specs/index.html#monitor-address-for-balance-changes">Monitor address for balance changes</a></li>
<li><a href="libraries/wallet-lib/docs/specs/index.html#monitor-address-for-new-messages">Monitor address for new messages</a></li>
<li><a href="libraries/wallet-lib/docs/specs/index.html#monitor-message-for-confirmation-state">Monitor message for confirmation state</a></li>
</ul>
</li>
<li><a href="libraries/wallet-lib/docs/specs/index.html#category-2-events">Category 2 events</a>
<ul>
<li><a href="libraries/wallet-lib/docs/specs/index.html#monitor-for-balance-changes">Monitor for balance changes</a></li>
<li><a href="libraries/wallet-lib/docs/specs/index.html#monitor-for-new-messages">Monitor for new messages</a></li>
<li><a href="libraries/wallet-lib/docs/specs/index.html#monitor-for-confirmation-state">Monitor for confirmation state</a></li>
<li><a href="libraries/wallet-lib/docs/specs/index.html#monitor-for-reattachments">Monitor for reattachments</a></li>
<li><a href="libraries/wallet-lib/docs/specs/index.html#monitor-for-broadcasts">Monitor for broadcasts</a></li>
<li><a href="libraries/wallet-lib/docs/specs/index.html#monitor-for-errors">Monitor for errors</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="libraries/wallet-lib/docs/specs/index.html#privacy">Privacy</a></li>
<li><a href="libraries/wallet-lib/docs/specs/index.html#input-selection">Input Selection</a></li>
<li><a href="libraries/wallet-lib/docs/specs/index.html#account-syncing-process">Account Syncing Process</a></li>
<li><a href="libraries/wallet-lib/docs/specs/index.html#polling">Polling</a></li>
</ul>
</li>
</ul>
<h2 id="introduction-1"><a class="header" href="#introduction-1">Introduction</a></h2>
<p>The wallet library is a stateful package with a standardised interface to build applications with IOTA value transactions. The package will be compatible with different platforms such as web, desktop and mobile. </p>
<p>The package introduces the concept of an <em>account</em>. An account is a reference or a label to a <a href="https://docs.iota.org/docs/getting-started/0.1/clients/seeds">seed</a>. An account has certain properties such as <a href="https://github.com/Wollac/protocol-rfcs/blob/bech32-address-format/text/0020-bech32-address-format/0020-bech32-address-format.md">addresses</a> and <a href="https://github.com/GalRogozinski/protocol-rfcs/blob/message/text/0017-message/0017-message.md">messages</a>. An account has various possible behaviours, including moving funds, looking for new messages, and making copies of message histories. An account should also be able to provide a degree of financial privacy and this should not incur any overhead. </p>
<p>A similar <a href="https://docs.iota.org/docs/client-libraries/0.1/account-module/introduction/overview">package</a> was previously developed but this becomes obsolete with the introduction of Ed25519 signatures. The previous account package was limited to a single account. As an improvement, the (new) package will be able to manage multiple accounts. </p>
<p>To summarize, the main motivation behind this package is to offer a simplified (stateful) approach to handle IOTA payments.</p>
<h2 id="considerations"><a class="header" href="#considerations">Considerations</a></h2>
<ul>
<li>Seeds should be stored and managed separately in a secure enclave and should never leave the secure environment. Secure enclaves include software enclaves such as IOTA’s Rust-based Stronghold library or hardware enclaves such as a Ledger Nano;</li>
<li>The secure enclave should have the ability to generate addresses and sign messages upon receipt of a message, and return the output in a message. If the secure enclave is initialised with a pre-generated seed, the sender process should immediately remove the seed traces from memory. </li>
</ul>
<h2 id="naming-conventions"><a class="header" href="#naming-conventions">Naming Conventions</a></h2>
<p>The primary language is <a href="https://github.com/rust-lang/rust">Rust</a>. Therefore, standard Rust naming <a href="https://doc.rust-lang.org/1.0.0/style/style/naming/README.html">conventions</a> are followed. All interfaces (types) use <em>CamelCase</em> while all function and variable names use <em>snake_case</em>.</p>
<h2 id="interfaces"><a class="header" href="#interfaces">Interfaces</a></h2>
<h4 id="accountconfiguration"><a class="header" href="#accountconfiguration">AccountConfiguration</a></h4>
<p>Account configuration or initialization object. It should support parameters accepted by high level <a href="https://github.com/iotaledger/iota.rs">client</a> libraries.</p>
<table>
  <tr>
    <td>
      <strong>Property</strong>
    </td>
    <td>
      <strong>Required</strong>
    </td>
    <td>
      <strong>Type</strong>
    </td>
    <td>
      <strong>Description</strong>
    </td>
  </tr>
  <tr>
    <td>seed</td>
    <td>&#10008;</td>
    <td>string</td>
    <td>BIP-39 mnemonic. When importing an account from Stronghold backup, the seed will not be required.</td>
  </tr>
  <tr>
    <td>id</td>
    <td>&#10008;</td>
    <td>string</td>
    <td>SHA-256 hash of the first address on the seed (m/44'/0'/0'/0'/0'). Required for referencing a seed in Stronghold. The id should be provided by Stronghold.</td>
  </tr>
  <tr>
    <td>index</td>
    <td>&#10004;</td>
    <td>number</td>
    <td>Account index in <a href="https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki">BIP-44</a> derivation path.</td>
  </tr>
  <tr>
    <td>alias</td>
    <td>&#10008;</td>
    <td>string</td>
    <td>Account name. If not provided, <code>Account + ${index}</code> should be used. When importing an account from Stronghold backup, the alias will be required from Stronghold.</td>
  </tr>
  <tr>
    <td>pow</td>
    <td>&#10008;</td>
    <td>‘local’ | ‘remote’</td>
    <td>
    Proof of work settings. Defaults to ‘local’. 
      <ul>
        <li>‘local’: Should be performed on device;</li>
        <li>‘remote’: Should be performed on the node.</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>nodes</td>
    <td>&#10004;</td>
    <td><a href="libraries/wallet-lib/docs/specs/index.html#node">node</a>[]</td>
    <td>A list of nodes to connect to.</td>
  </tr>
  <tr>
    <td>quorum_size</td>
    <td>&#10008;</td>
    <td>number</td>
    <td>If multiple nodes are provided, quorum size determines the number of nodes to query to check for quorum.</td>
  </tr>
  <tr>
    <td>quorum_threshold</td>
    <td>&#10008;</td>
    <td>number</td>
    <td>Minimum number of nodes from the quorum pool that need to agree to consider a result true.</td>
  </tr>
  <tr>
    <td>network</td>
    <td>&#10008;</td>
    <td>‘mainnet’ | ‘devnet’ | ‘comnet’</td>
    <td>IOTA public network.</td>
  </tr>
  <tr>
    <td>type</td>
    <td>&#10008;</td>
    <td>‘default’ | ‘ledger’</td>
    <td>Account type. Required for differentiating ledger vs non-ledger accounts.</td>
  </tr>
  <tr>
    <td>provider</td>
    <td>&#10008;</td>
    <td>string</td>
    <td>Node URL.</td>
  </tr>
  <tr>
    <td>created_at</td>
    <td>&#10008;</td>
    <td>Date</td>
    <td>Time of account creation.</td>
  </tr>
  <tr>
    <td>messages</td>
    <td>&#10008;</td>
    <td><a href="libraries/wallet-lib/docs/specs/index.html#message">Message</a>[]</td>
    <td>Messages associated with account. Accounts can be initialised with locally stored messages.</td>
  </tr>
  <tr>
    <td>addresses</td>
    <td>&#10008;</td>
    <td><a href="libraries/wallet-lib/docs/specs/index.html#address">Address</a>[]</td>
    <td>Address history associated with the account. Accounts can be initialised with locally stored address history.</td>
  </tr>
</table>
<h4 id="accountobject"><a class="header" href="#accountobject">AccountObject</a></h4>
<table>
  <tr>
    <td><strong>Property</strong></td>
    <td><strong>Required</strong></td>
    <td><strong>Type</strong></td>
    <td><strong>Description</strong></td>
  </tr>
  <tr>
    <td>id</td>
    <td>&#10004;</td>
    <td>string</td>
    <td>SHA-256 hash of the first address on the seed (m/44'/0'/0'/0/0). Required for referencing a seed in Stronghold.</td>
  </tr>
  <tr>
    <td>alias</td>
    <td>&#10004;</td>
    <td>string</td>
    <td>Account name.</td>
  </tr>
  <tr>
    <td>created_at</td>
    <td>&#10004;</td>
    <td>number</td>
    <td>Account creation time.</td>
  </tr>
  <tr>
    <td>last_synced_at</td>
    <td>&#10004;</td>
    <td>string</td>
    <td>Time the account was last synced with the Tangle.</td>
  </tr>
  <tr>
    <td><a href="libraries/wallet-lib/docs/specs/index.html#sync">sync()</a></td>
    <td>&#10004;</td>
    <td>function</td>
    <td>Syncs account with the Tangle.</td>
  </tr>
  <tr>
    <td><a href="libraries/wallet-lib/docs/specs/index.html#reattach">reattach()</a></td>
    <td>&#10004;</td>
    <td>function</td>
    <td>Reattaches unconfirmed transaction to the Tangle.</td>
  </tr>
  <tr>
    <td><a href="libraries/wallet-lib/docs/specs/index.html#totalbalance">total_balance()</a></td>
    <td>&#10004;</td>
    <td>function</td>
    <td>Gets total account balance.</td>
  </tr>
  <tr>
    <td><a href="libraries/wallet-lib/docs/specs/index.html#availablebalance">available_balance()</a></td>
    <td>&#10004;</td>
    <td>function</td>
    <td>Gets available account balance.</td>
  </tr>
  <tr>
    <td><a href="libraries/wallet-lib/docs/specs/index.html#setalias">set_alias()</a></td>
    <td>&#10004;</td>
    <td>function</td>
    <td>Updates account name.</td>
  </tr>
  <tr>
    <td><a href="libraries/wallet-lib/docs/specs/index.html#listmessages">list_messages()</a></td>
    <td>&#10004;</td>
    <td>function</td>
    <td>Gets messages.</td>
  </tr>
  <tr>
    <td><a href="libraries/wallet-lib/docs/specs/index.html#listreceivedmessages">list_received_messages()</a></td>
    <td>&#10004;</td>
    <td>function</td>
    <td>Gets all received messages.</td>
  </tr>
  <tr>
    <td><a href="libraries/wallet-lib/docs/specs/index.html#listsentmessages">list_sent_messages()</a></td>
    <td>&#10004;</td>
    <td>function</td>
    <td>Gets all sent messages.</td>
  </tr>
  <tr>
    <td><a href="libraries/wallet-lib/docs/specs/index.html#listfailedmessages">list_failed_messages()</a></td>
    <td>&#10004;</td>
    <td>function</td>
    <td>Gets all failed messages.</td>
  </tr>
  <tr>
    <td><a href="libraries/wallet-lib/docs/specs/index.html#listunconfirmedmessages">list_unconfirmed_messages()</a></td>
    <td>&#10004;</td>
    <td>function</td>
    <td>Gets all unconfirmed messages.</td>
  </tr>
  <tr>
    <td><a href="libraries/wallet-lib/docs/specs/index.html#getmessage">get_message()</a></td>
    <td>&#10004;</td>
    <td>function</td>
    <td>Gets message for provided id.</td>
  </tr>
  <tr>
    <td><a href="libraries/wallet-lib/docs/specs/index.html#listaddresses">list_addresses()</a></td>
    <td>&#10004;</td>
    <td>function</td>
    <td>Gets all addresses.</td>
  </tr>
  <tr>
    <td><a href="libraries/wallet-lib/docs/specs/index.html#listunspent">list_unspent_addresses()</a></td>
    <td>&#10004;</td>
    <td>function</td>
    <td>Gets all unspent input addresses.</td>
  </tr>
  <tr>
    <td><a href="libraries/wallet-lib/docs/specs/index.html#generateaddress">generate_address()</a></td>
    <td>&#10004;</td>
    <td>function</td>
    <td>Gets the latest unused address.</td>
  </tr>
</table>
<h4 id="syncedaccountobject"><a class="header" href="#syncedaccountobject">SyncedAccountObject</a></h4>
<table>
  <tr>
    <td><strong>Property</strong></td>
    <td><strong>Required</strong></td>
    <td><strong>Type</strong></td>
    <td><strong>Description</strong></td>
  </tr>
  <tr>
    <td>deposit_address</td>
    <td>&#10004;</td>
    <td><a href="libraries/wallet-lib/docs/specs/index.html#address">Address</a></td>
    <td>Deposit address. Only exposed on successful completion of account syncing process.</td>
  </tr>
  <tr>
    <td><a href="libraries/wallet-lib/docs/specs/index.html#send">send()</a></td>
    <td>&#10004;</td>
    <td>function</td>
    <td>Send transaction method. Only exposed on successful completion of account syncing process.</td>
  </tr>
  <tr>
    <td><a href="libraries/wallet-lib/docs/specs/index.html#retry">retry()</a></td>
    <td>&#10004;</td>
    <td>function</td>
    <td>Rebroadcasts failed transaction. Only exposed on successful completion of account syncing process.</td>
  </tr>
</table>
<h4 id="accountmanagerobject"><a class="header" href="#accountmanagerobject">AccountManagerObject</a></h4>
<table>
  <tr>
    <td><strong>Property</strong></td>
    <td><strong>Required</strong></td>
    <td><strong>Type</strong></td>
    <td><strong>Description</strong></td>
  </tr>
  <tr>
    <td>accounts</td>
    <td>&#10004;</td>
    <td><a href="libraries/wallet-lib/docs/specs/index.html#account">Account</a>[]</td>
    <td>Account objects.</td>
  </tr>
  <tr>
    <td><a href="libraries/wallet-lib/docs/specs/index.html#addaccount">add_account()</a></td>
    <td>&#10004;</td>
    <td>function</td>
    <td>Adds a new account.</td>
  </tr>
  <tr>
    <td><a href="libraries/wallet-lib/docs/specs/index.html#removeaccount">remove_account()</a></td>
    <td>&#10004;</td>
    <td>function</td>
    <td>Removes an account.</td>
  </tr>
  <tr>
    <td><a href="libraries/wallet-lib/docs/specs/index.html#syncaccounts">sync_accounts()</a></td>
    <td>&#10004;</td>
    <td>function</td>
    <td>Syncs all stored accounts with the Tangle.</td>
  </tr>
  <tr>
    <td><a href="libraries/wallet-lib/docs/specs/index.html#move">move()</a></td>
    <td>&#10004;</td>
    <td>function</td>
    <td>Inititates an internal transaction between accounts.</td>
  </tr>
  <tr>
    <td><a href="libraries/wallet-lib/docs/specs/index.html#backup">backup()</a></td>
    <td>&#10004;</td>
    <td>function</td>
    <td>Creates a backup to a provided destination.</td>
  </tr>
  <tr>
    <td><a href="libraries/wallet-lib/docs/specs/index.html#importaccounts">import_accounts()</a></td>
    <td>&#10004;</td>
    <td>function</td>
    <td>Imports backed up accounts.</td>
  </tr>
  <tr>
    <td><a href="libraries/wallet-lib/docs/specs/index.html#getaccount">get_account()</a></td>
    <td>&#10004;</td>
    <td>function</td>
    <td>Returns the account associated with the provided address.</td>
  </tr>
  <tr>
    <td><a href="libraries/wallet-lib/docs/specs/index.html#reattach">reattach()</a></td>
    <td>&#10004;</td>
    <td>function</td>
    <td>Reattaches an unconfirmed transaction.</td>
  </tr>
</table>
<h4 id="address-3"><a class="header" href="#address-3">Address</a></h4>
<p>Useful <a href="https://medium.com/@harshagoli/hd-wallets-explained-from-high-level-to-nuts-and-bolts-9a41545f5b0">reference</a> for address management in Hierarchical Deterministic (HD) wallets.</p>
<table>
  <tr>
    <td><strong>Property</strong></td>
    <td><strong>Required</strong></td>
    <td><strong>Type</strong></td>
    <td><strong>Description</strong></td>
  </tr>
  <tr>
    <td>address</td>
    <td>&#10004;</td>
    <td>string</td>
    <td>Address <a href="https://github.com/Wollac/protocol-rfcs/blob/bech32-address-format/text/0020-bech32-address-format/0020-bech32-address-format.md">(Bech32)</a> string.</td>
  </tr>
  <tr>
    <td>balance</td>
    <td>&#10004;</td>
    <td>number</td>
    <td>Address balance.</td>
  </tr>
  <tr>
    <td>index</td>
    <td>&#10004;</td>
    <td>number</td>
    <td>Address index.</td>
  </tr>
  <tr>
    <td>internal</td>
    <td>&#10004;</td>
    <td>boolean</td>
    <td>Determines if an address is a public or an internal (change) address. See the concept of <a href="https://medium.com/@harshagoli/hd-wallets-explained-from-high-level-to-nuts-and-bolts-9a41545f5b0">chain node</a> for more details.</td>
  </tr>
  <tr>
    <td>checksum</td>
    <td>&#10004;</td>
    <td>string</td>
    <td>Address checksum.</td>
  </tr>
</table>
<h4 id="node-1"><a class="header" href="#node-1">Node</a></h4>
<table>
  <tr>
    <td><strong>Property</strong></td>
    <td><strong>Required</strong></td>
    <td><strong>Type</strong></td>
    <td><strong>Description</strong></td>
  </tr>
  <tr>
    <td>url</td>
    <td>&#10004;</td>
    <td>string</td>
    <td>Node URL.</td>
  </tr>
  <tr>
    <td>pow</td>
    <td>&#10004;</td>
    <td>boolean</td>
    <td>Determines if the node accepts proof of work.</td>
  </tr>
  <tr>
    <td>username</td>
    <td>&#10008;</td>
    <td>string</td>
    <td>Node username. Only required if node requires authorisation.</td>
  </tr>
  <tr>
    <td>password</td>
    <td>&#10008;</td>
    <td>string</td>
    <td>Node password. Only required if node requires authorisation.</td>
  </tr>
  <tr>
    <td>network</td>
    <td>&#10004;</td>
    <td>‘mainnet’ | ‘devnet’ | ‘comnet’</td>
    <td>IOTA public network name.</td>
  </tr>
</table>
<h4 id="timestamp"><a class="header" href="#timestamp">Timestamp</a></h4>
<table>
  <tr>
    <td><strong>Property</strong></td>
    <td><strong>Required</strong></td>
    <td><strong>Type</strong></td>
    <td><strong>Description</strong></td>
  </tr>
  <tr>
    <td>format(type: string):string</td>
    <td>&#10004;</td>
    <td>function</td>
    <td>Transaction timestamp in various formats. For example: MM-DD-YYYY, DD MM YYYY hh:mm:ss.</td>
  </tr>
</table>
<h4 id="transfer-1"><a class="header" href="#transfer-1">Transfer</a></h4>
<p>Transfer object required for creating a transaction. It allows end-users to specify the transaction amount and recipient address.</p>
<p>Note: Currently, it is not possible to send multiple payloads as part of the message. That is why tag property is omitted from this interface. See <a href="https://github.com/iotaledger/protocol-rfcs/pull/18#discussion_r468432794">this</a> for details.</p>
<table>
  <tr>
    <td><strong>Property</strong></td>
    <td><strong>Required</strong></td>
    <td><strong>Type</strong></td>
    <td><strong>Description</strong></td>
  </tr>
  <tr>
    <td>amount</td>
    <td>&#10004;</td>
    <td>number</td>
    <td>Transfer amount.</td>
  </tr>
  <tr>
    <td>address</td>
    <td>&#10004;</td>
    <td>string</td>
    <td>Transfer address.</td>
  </tr>
  <tr>
    <td>indexation_key</td>
    <td>&#10008;</td>
    <td><a href="libraries/wallet-lib/docs/specs/index.html#indexationpayload">Indexation Payload</a></td>
    <td>(Optional) Indexation payload.</td>
  </tr>
</table>
<h4 id="value"><a class="header" href="#value">Value</a></h4>
<table>
  <tr>
    <td><strong>Property</strong></td>
    <td><strong>Required</strong></td>
    <td><strong>Type</strong></td>
    <td><strong>Description</strong></td>
  </tr>
  <tr>
    <td>with_denomination():string</td>
    <td>&#10004;</td>
    <td>function</td>
    <td>Transaction amount with unit.</td>
  </tr>
  <tr>
    <td>without_denomination():number</td>
    <td>&#10004;</td>
    <td>function</td>
    <td>Transaction amount without unit.</td>
  </tr>
</table>
<h4 id="input-2"><a class="header" href="#input-2">Input</a></h4>
<table>
  <tr>
    <td><strong>Property</strong></td>
    <td><strong>Required</strong></td>
    <td><strong>Type</strong></td>
    <td><strong>Description</strong></td>
  </tr>
  <tr>
    <td>type</td>
    <td>&#10004;</td>
    <td>number</td>
    <td>Input type. Defaults to <code>0</code>.</td>
  </tr>
  <tr>
    <td>id</td>
    <td>&#10004;</td>
    <td>string</td>
    <td>BLAKE2b-256 hash of the transaction.</td>
  </tr>
  <tr>
    <td>output_index</td>
    <td>&#10004;</td>
    <td>number</td>
    <td>Index of the output on the referenced transaction.</td>
  </tr>
</table>
<h4 id="outputaddress"><a class="header" href="#outputaddress">OutputAddress</a></h4>
<table>
  <tr>
    <td><strong>Property</strong></td>
    <td><strong>Required</strong></td>
    <td><strong>Type</strong></td>
    <td><strong>Description</strong></td>
  </tr>
  <tr>
    <td>type</td>
    <td>&#10004;</td>
    <td>number</td>
    <td>Set to value <code>0</code> to denote an Ed25519 address.</td>
  </tr>
  <tr>
    <td>address</td>
    <td>&#10004;</td>
    <td>string</td>
    <td>If type is set to <code>0</code>, it should contain an Ed25519 address.</td>
  </tr>
</table>
<h4 id="output-2"><a class="header" href="#output-2">Output</a></h4>
<table>
  <tr>
    <td><strong>Property</strong></td>
    <td><strong>Required</strong></td>
    <td><strong>Type</strong></td>
    <td><strong>Description</strong></td>
  </tr>
  <tr>
    <td>type</td>
    <td>&#10004;</td>
    <td>number</td>
    <td>Output type. Defaults to <code>0</code>.</td>
  </tr>
  <tr>
    <td>address</td>
    <td>&#10004;</td>
    <td><a href="libraries/wallet-lib/docs/specs/index.html#outputaddress">OutputAddress</a></td>
    <td>Output address.</td>
  </tr>
  <tr>
    <td>amount</td>
    <td>&#10004;</td>
    <td>number</td>
    <td>Amount of tokens to deposit.</td>
  </tr>
</table>
<h4 id="unsigneddatapayload"><a class="header" href="#unsigneddatapayload">UnsignedDataPayload</a></h4>
<table>
  <tr>
    <td><strong>Property</strong></td>
    <td><strong>Required</strong></td>
    <td><strong>Type</strong></td>
    <td><strong>Description</strong></td>
  </tr>
  <tr>
    <td>type</td>
    <td>&#10004;</td>
    <td>number</td>
    <td>Set to <code>2</code> to denote a unsigned data payload.</td>
  </tr>
  <tr>
    <td>data</td>
    <td>&#10004;</td>
    <td>string</td>
    <td>Data of unsigned payload.</td>
  </tr>
</table>
<h4 id="signeddatapayload"><a class="header" href="#signeddatapayload">SignedDataPayload</a></h4>
<table>
  <tr>
    <td><strong>Property</strong></td>
    <td><strong>Required</strong></td>
    <td><strong>Type</strong></td>
    <td><strong>Description</strong></td>
  </tr>
  <tr>
    <td>type</td>
    <td>&#10004;</td>
    <td>number</td>
    <td>Set to <code>3</code> to denote a signed data payload.</td>
  </tr>
  <tr>
    <td>data</td>
    <td>&#10004;</td>
    <td>string</td>
    <td>Data of signed data payload.</td>
  </tr>
  <tr>
    <td>public_key</td>
    <td>&#10004;</td>
    <td>string</td>
    <td>Ed25519 public key used to verify the signature.</td>
  </tr>
  <tr>
    <td>signature</td>
    <td>&#10004;</td>
    <td>string</td>
    <td>Signature of signing data.</td>
  </tr>
</table>
<h4 id="indexationpayload-3"><a class="header" href="#indexationpayload-3">IndexationPayload</a></h4>
<table>
  <tr>
    <td><strong>Property</strong></td>
    <td><strong>Required</strong></td>
    <td><strong>Type</strong></td>
    <td><strong>Description</strong></td>
  </tr>
  <tr>
    <td>index</td>
    <td>&#10004;</td>
    <td>string</td>
    <td>Indexation key.</td>
  </tr>
  <tr>
    <td>data</td>
    <td>&#10004;</td>
    <td>string</td>
    <td>Indexation data.</td>
  </tr>
</table>
<h4 id="unsignedtransaction"><a class="header" href="#unsignedtransaction">UnsignedTransaction</a></h4>
<table>
  <tr>
    <td><strong>Property</strong></td>
    <td><strong>Required</strong></td>
    <td><strong>Type</strong></td>
    <td><strong>Description</strong></td>
  </tr>
  <tr>
    <td>type</td>
    <td>&#10004;</td>
    <td>number</td>
    <td>Transaction type. Defaults to <code>0</code>.</td>
  </tr>
  <tr>
    <td>inputs_count</td>
    <td>&#10004;</td>
    <td>number</td>
    <td>Amount of inputs proceeding.</td>
  </tr>
  <tr>
    <td>inputs</td>
    <td>&#10004;</td>
    <td><a href="libraries/wallet-lib/docs/specs/index.html#input">Input</a>[]</td>
    <td>Transaction inputs.</td>
  </tr>
  <tr>
    <td>outputs_count</td>
    <td>&#10004;</td>
    <td>number</td>
    <td>Amount of outputs proceeding.</td>
  </tr>
  <tr>
    <td>outputs</td>
    <td>&#10004;</td>
    <td><a href="libraries/wallet-lib/docs/specs/index.html#outputs">Output</a>[]</td>
    <td>Output address.</td>
  </tr>
  <tr>
    <td>payload_length</td>
    <td>&#10004;</td>
    <td>number</td>
    <td>Length of optional payload.</td>
  </tr>
  <tr>
    <td>payload</td>
    <td>&#10004;</td>
    <td>
    <a href="libraries/wallet-lib/docs/specs/index.html#unsigneddatapayload">UnsignedDataPayload</a> | 
    <a href="libraries/wallet-lib/docs/specs/index.html#signeddatapayload">SignedDataPayload</a> |
    <a href="libraries/wallet-lib/docs/specs/index.html#indexationpayload">IndexationPayload</a>
    </td>
    <td>Payload containing data. As multiple payloads are not yet supported, only <a href="libraries/wallet-lib/docs/specs/index.html#unsigneddatapayload">unsigned data payload</a> should be used.</td>
  </tr>
</table>
<h4 id="ed25519signature-2"><a class="header" href="#ed25519signature-2">Ed25519Signature</a></h4>
<table>
  <tr>
    <td><strong>Property</strong></td>
    <td><strong>Required</strong></td>
    <td><strong>Type</strong></td>
    <td><strong>Description</strong></td>
  </tr>
  <tr>
    <td>type</td>
    <td>&#10004;</td>
    <td>number</td>
    <td>Set to value <code>1</code> to denote an Ed25519 signature.</td>
  </tr>
  <tr>
    <td>public_key</td>
    <td>&#10004;</td>
    <td>number</td>
    <td>Public key of the Ed25519 keypair which is used to verify the signature.</td>
  </tr>
  <tr>
    <td>signature</td>
    <td>&#10004;</td>
    <td>string</td>
    <td>Signature signing the serialized unsigned transaction.</td>
  </tr>
</table>
<h4 id="signatureunblockblock"><a class="header" href="#signatureunblockblock">SignatureUnblockBlock</a></h4>
<table>
  <tr>
    <td><strong>Property</strong></td>
    <td><strong>Required</strong></td>
    <td><strong>Type</strong></td>
    <td><strong>Description</strong></td>
  </tr>
  <tr>
    <td>type</td>
    <td>&#10004;</td>
    <td>number</td>
    <td>Set to value <code>0</code> to denote a signature unlock block.</td>
  </tr>
  <tr>
    <td>signature</td>
    <td>&#10004;</td>
    <td>
        <a href="libraries/wallet-lib/docs/specs/index.html#ed25519signature">Ed25519Signature</a>
    </td>
    <td>An unlock block containing signature(s) unlocking input(s).</td>
  </tr>
</table>
<h4 id="referenceunblockblock"><a class="header" href="#referenceunblockblock">ReferenceUnblockBlock</a></h4>
<table>
  <tr>
    <td><strong>Property</strong></td>
    <td><strong>Required</strong></td>
    <td><strong>Type</strong></td>
    <td><strong>Description</strong></td>
  </tr>
  <tr>
    <td>type</td>
    <td>&#10004;</td>
    <td>number</td>
    <td>Set to value <code>1</code> to denote a reference unlock block.</td>
  </tr>
  <tr>
    <td>reference</td>
    <td>&#10004;</td>
    <td>number</td>
    <td>Index of a previous unlock block.</td>
  </tr>
</table>
<h4 id="signedtransactionpayload"><a class="header" href="#signedtransactionpayload">SignedTransactionPayload</a></h4>
<table>
  <tr>
    <td><strong>Property</strong></td>
    <td><strong>Required</strong></td>
    <td><strong>Type</strong></td>
    <td><strong>Description</strong></td>
  </tr>
  <tr>
    <td>type</td>
    <td>&#10004;</td>
    <td>number</td>
    <td>Payload type. Defaults to `0`.</td>
  </tr>
  <tr>
    <td>transaction</td>
    <td>&#10004;</td>
    <td><a href="libraries/wallet-lib/docs/specs/index.html#unsignedtransaction">UnsignedTransaction</a></td>
    <td>Essence data making up a transaction by defining its inputs and outputs and an optional payload.</td>
  </tr>
  <tr>
    <td>unblock_blocks_count</td>
    <td>&#10004;</td>
    <td>number</td>
    <td>Number of inputs specifed.</td>
  </tr>
  <tr>
    <td>unblock_blocks</td>
    <td>&#10004;</td>
    <td>
        <a href="libraries/wallet-lib/docs/specs/index.html#signatureunblockblock">SignatureUnblockBlock</a> |
        <a href="libraries/wallet-lib/docs/specs/index.html#referenceunblockblock">ReferenceUnblockBlock</a>
    </td>
    <td>Holds the unlock blocks unlocking inputs within an Unsigned Transaction</td>
  </tr>
</table>
<h4 id="message-4"><a class="header" href="#message-4">Message</a></h4>
<table>
  <tr>
    <td><strong>Property</strong></td>
    <td><strong>Required</strong></td>
    <td><strong>Type</strong></td>
    <td><strong>Description</strong></td>
  </tr>
  <tr>
    <td>version</td>
    <td>&#10004;</td>
    <td>number</td>
    <td>Message version. Defaults to `1`.</td>
  </tr>
  <tr>
    <td>parents</td>
    <td>&#10004;</td>
    <td>string[]</td>
    <td>Message ids this message references.</td>
  </tr>
  <tr>
    <td>payload_length</td>
    <td>&#10004;</td>
    <td>number</td>
    <td>Length of the payload.</td>
  </tr>
  <tr>
    <td>payload</td>
    <td>&#10004;</td>
    <td>
        <a href="libraries/wallet-lib/docs/specs/index.html#signedtransactionpayload">SignedTransactionPayload</a> |
        <a href="libraries/wallet-lib/docs/specs/index.html#unsigneddatapayload">UnsignedDataPayload</a> |
        <a href="libraries/wallet-lib/docs/specs/index.html#signeddatapayload">SignedDataPayload</a>
    </td>
    <td>Transaction amount (exposed as a custom type with additional methods).</td>
  </tr>
  <tr>
    <td>timestamp</td>
    <td>&#10004;</td>
    <td><a href="libraries/wallet-lib/docs/specs/index.html#timestamp">Timestamp</a></td>
    <td>Transaction timestamp (exposed as a custom type with additional methods).</td>
  </tr>
  <tr>
    <td>nonce</td>
    <td>&#10004;</td>
    <td>string</td>
    <td>Transaction nonce.</td>
  </tr>
  <tr>
    <td>confirmed</td>
    <td>&#10004;</td>
    <td>boolean</td>
    <td>Determines if the transaction is confirmed.</td>
  </tr>
  <tr>
    <td>broadcasted</td>
    <td>&#10004;</td>
    <td>boolean</td>
    <td>
      Determines if the transaction was broadcasted to the network. Will be true in the following scenarios:
      <ul>
        <li>If the transaction was fetched from the network;</li>
        <li>If the transaction was successfully broadcasted from the client itself.</li>
      </ul>
      Note: This property may only be required for clients with persistent storage.
    </td>
  </tr>
  <tr>
    <td>incoming</td>
    <td>&#10004;</td>
    <td>boolean</td>
    <td>Determines if the message is an incoming transaction or not.</td>
  </tr>
  <tr>
    <td>value</td>
    <td>&#10004;</td>
    <td>number</td>
    <td>Message transfer value.</td>
  </tr>
</table>
<h4 id="storageadapter"><a class="header" href="#storageadapter">StorageAdapter</a></h4>
<table>
  <tr>
    <td><strong>Property</strong></td>
    <td><strong>Required</strong></td>
    <td><strong>Type</strong></td>
    <td><strong>Description</strong></td>
  </tr>
  <tr>
    <td>get(key: string):<a href="libraries/wallet-lib/docs/specs/index.html#account">Account</a></td>
    <td>&#10004;</td>
    <td>function</td>
    <td>Gets the account object for provided account name or id.</td>
  </tr>
  <tr>
    <td>getAll(): <a href="libraries/wallet-lib/docs/specs/index.html#account">Account</a>[]</td>
    <td>&#10004;</td>
    <td>function</td>
    <td>Gets all account objects from storage.</td>
  </tr>
  <tr>
    <td>set(key: string, payload: string):void</td>
    <td>&#10004;</td>
    <td>function</td>
    <td>Stores account in storage.</td>
  </tr>
  <tr>
    <td>remove(key: string): void</td>
    <td>&#10004;</td>
    <td>function</td>
    <td>Removes account from storage.</td>
  </tr>
</table>
<h2 id="storage"><a class="header" href="#storage">Storage</a></h2>
<p><em>Note: Using Stronghold for storage is currently under research/development.</em></p>
<p>Multiple storage options should be considered for managing data that requires persistence. For wallet basic metadata, such as user settings or theming options, a simple key-value <a href="https://capacitor.ionicframework.com/docs/apis/storage/">storage</a> could be leveraged. For transactions and address data management a relational database such as <a href="https://github.com/jepiqueau/capacitor-sqlite">SQLite</a> can be used. What follows is an Entity Relationship (ERD) diagram that shows the logical representation of the data. An <em>account</em> is the basic entity in this database design. It has a one-to-many relationship with <em>addresses</em> i.e. an account could have multiple <em>addresses</em> but also an <em>address</em> can only belong to a single <em>account</em>. An <em>account</em> has a many-to-many relationship with <em>transactions</em> i.e. an <em>account</em> could have multiple <em>transactions</em> but it’s possible that a <em>transaction</em> belongs to multiple <em>accounts</em>. To accommodate for that, an additional table is added that stores account ids against transaction ids (hashes).</p>
<p>A storage adapter is required by the Rust layer because the storage operations (read/write) will be (mostly) done from that layer. A generic storage adapter is defined <a href="libraries/wallet-lib/docs/specs/index.html#storageadapter">here</a>.</p>
<p><img src="libraries/wallet-lib/docs/specs/erd.jpg" alt="Entity Relationship Diagram" /></p>
<h2 id="storage-adapter"><a class="header" href="#storage-adapter">Storage Adapter</a></h2>
<p>The package should have a default opinionated storage mechanism but should also provide the ability for users to override the storage by specifying an adapter. As a default option, a relational database such as <a href="https://www.sqlite.org/index.html">SQLite</a> can be used.</p>
<p>See <a href="libraries/wallet-lib/docs/specs/index.html#storageAdapter">storage adapter</a> for adapter interface.</p>
<h2 id="account-1"><a class="header" href="#account-1">Account</a></h2>
<h3 id="api-1"><a class="header" href="#api-1">API</a></h3>
<h4 id="initialisation-2"><a class="header" href="#initialisation-2">Initialisation</a></h4>
<p>Initialises account
There are several scenarios in which an account can be initialised:</p>
<ul>
<li><em>Seed generated outside the Stronghold</em>:  In this case, the account should be initialised with a seed. It should communicate with the Stronghold using its “importAccount” method and should expect an “id” as a response; </li>
<li><em>Seed generated inside the Stronghold</em>: In this case, the account should be initialised without a seed. It should communicate with the Stronghold using its “createAccount” method and should expect an “id” in response;</li>
<li><em>Importing accounts from Stronghold backup</em>: In this case, the account should receive all initialisation properties from the Stronghold. Note that during backup, these configuration settings should be passed to the Stronghold. See <a href="libraries/wallet-lib/docs/specs/index.html#import_accounts">import_accounts()</a>.</li>
</ul>
<p>The following should be considered when initialising an account:</p>
<ul>
<li>An account should never be initialised directly. The only way an account can be initialized is through the <a href="libraries/wallet-lib/docs/specs/index.html#add_account">add_account()</a> method;</li>
<li>An account should always be initialised after a successful response from the Stronghold. If the Stronghold fails to create an account, the account initialisation should error out. If the Stronghold successfully creates an account, the account should be stored in the persistent storage. Upon a successful store operation, the user should be returned an account object;</li>
<li>If a <code>provider</code> property is not passed, a random node should be selected from the <code>nodes</code> property;</li>
<li>If a <code>type</code> property is not passed, <code>&quot;default”</code> should be used as an account type;</li>
<li><code>quorum_size</code> and <code>quorum_threshold</code> should be validated. For example, <code>quorum_size</code> should not be greater than the number of nodes provided by the user.</li>
<li>The <code>nodes</code> property should validate and remove duplicate node URLs;</li>
<li>All the properties of the returned account object should be read-only. It should not be possible to manipulate them directly.</li>
</ul>
<table>
  <tr>
    <td colspan="4"><strong>Parameters</strong></td>
  </tr>
  <tr>
    <td><strong>Name</strong></td>
    <td><strong>Required</strong></td>
    <td><strong>Type</strong></td>
    <td><strong>Description</strong></td>
  </tr>
  <tr>
    <td>config</td>
    <td>&#10004;</td>
    <td><a href="libraries/wallet-lib/docs/specs/index.html#accountconfiguration">AccountConfig</a></td>
    <td>Initialisation method receives a configuration object.</td>
  </tr>
  <tr>
    <td colspan="4"><strong>Returns</strong></td>
  </tr>
  <tr>
    <td><strong>Name</strong></td>
    <td><strong>Type</strong></td>
    <td colspan="3"><strong>Description</strong></td>
  </tr>
  <tr>
    <td>account</td>
    <td><a href="libraries/wallet-lib/docs/specs/index.html#accountobject">Account</a></td>
    <td colspan="3">Account instance.</td>
  </tr>
  <tr>
    <td colspan="4"><strong>Additional Information</strong></td>
  </tr>
  <tr>
    <td><strong>Name</strong></td>
    <td colspan="3"><strong>Description</strong></td>
  </tr>
  <tr>
    <td>Access modifiers</td>
    <td colspan="3">Public</td>
  </tr>
  <tr>
    <td>Errors</td>
    <td colspan="3">List of error messages [TBD]</td>
  </tr>
  <tr>
    <td>Required client library methods</td>
    <td colspan="3">None</td>
  </tr>
</table>
<h4 id="sync_addresses"><a class="header" href="#sync_addresses">sync_addresses()</a></h4>
<p>Syncs addresses with the Tangle. The method should ensure that the wallet's local state contains all used addresses and an unused address. </p>
<p>The following should be considered when implementing this method:</p>
<ul>
<li>The updated address history should not be written down in the database/persistent storage. Instead the method should only return the updated address history (with transaction hashes).  This will ensure that there are no partial writes to the database;</li>
<li>To sync addresses for an account from scratch, index = 0 and gap_limit = 10 should be provided;</li>
<li>To sync addresses from the latest address, index = latest address index and gap_limit = 1 should be provided. </li>
</ul>
<table>
  <tr>
    <td colspan="4"><strong>Parameters</strong></td>
  </tr>
  <tr>
    <td><strong>Name</strong></td>
    <td><strong>Required</strong></td>
    <td><strong>Type</strong></td>
    <td><strong>Description</strong></td>
  </tr>
  <tr>
    <td>index</td>
    <td>&#10004;</td>
    <td>number</td>
    <td>Address index. By default the length of addresses stored for this account should be used as an index.</td>
  </tr>
  <tr>
    <td>gap_limit</td>
    <td>&#10004;</td>
    <td>number</td>
    <td>Number of address indexes that are generated.</td>
  </tr>
  <tr>
    <td colspan="4"><strong>Returns</strong></td>
  </tr>
  <tr>
    <td><strong>Name</strong></td>
    <td><strong>Type</strong></td>
    <td colspan="3"><strong>Description</strong></td>
  </tr>
  <tr>
    <td>addresses</td>
    <td><a href="libraries/wallet-lib/docs/specs/index.html#address">Address</a>[]</td>
    <td colspan="3">Address history upto latest unused address.</td>
  </tr>
  <tr>
    <td>ids</td>
    <td>string[]</td>
    <td colspan="3">Message ids associated with the addresses.</td>
  </tr>
  <tr>
    <td colspan="4"><strong>Additional Information</strong></td>
  </tr>
  <tr>
    <td><strong>Name</strong></td>
    <td colspan="3"><strong>Description</strong></td>
  </tr>
  <tr>
    <td>Access modifiers</td>
    <td colspan="3">Private</td>
  </tr>
  <tr>
    <td>Errors</td>
    <td colspan="3">List of error messages [TBD]</td>
  </tr>
  <tr>
    <td>Required client library methods</td>
    <td colspan="3">
      <ul>
        <li><a href="https://github.com/iotaledger/iota.rs/blob/dev/specs/iota-rs-ENGINEERING-SPEC-0000.md#get_address_balances">get_address_balances()</a></li>
        <li><a href="https://github.com/iotaledger/iota.rs/blob/dev/specs/iota-rs-ENGINEERING-SPEC-0000.md#find_messages">find_messages()</a></li>
        <li><a href="https://github.com/iotaledger/iota.rs/blob/dev/specs/iota-rs-ENGINEERING-SPEC-0000.md#find_outputs">find_outputs()</a></li>
      </ul>
    </td>
  </tr>
</table>
<h4 id="sync_messages"><a class="header" href="#sync_messages">sync_messages()</a></h4>
<p>Syncs messages with the Tangle. The method should ensure that the wallet's local state has all messages associated with the address history. </p>
<p>The following should be considered when implementing this method:</p>
<ul>
<li>The updated message history should not be written down in the database/persistent storage. Instead the method should only return the updated message history (with message ids);</li>
<li>This method should check if there are any local messages (with “broadcasted: false”) matching the messages fetched from the network. If there are such messages, their “broadcasted” property should be set to true;</li>
<li>For newly-confirmed messages, the method should ensure that it updates the “confirmed” property of all its reattachments.</li>
</ul>
<table>
  <tr>
    <td colspan="4"><strong>Parameters</strong></td>
  </tr>
  <tr>
    <td><strong>Name</strong></td>
    <td><strong>Required</strong></td>
    <td><strong>Type</strong></td>
    <td><strong>Description</strong></td>
  </tr>
  <tr>
    <td>ids</td>
    <td>&#10004;</td>
    <td>string[]</td>
    <td>Message ids. New message ids should be calculated by running a difference of local message ids with latest message ids on the Tangle.</td>
  </tr>
  <tr>
    <td colspan="4"><strong>Returns</strong></td>
  </tr>
  <tr>
    <td><strong>Name</strong></td>
    <td><strong>Type</strong></td>
    <td colspan="3"><strong>Description</strong></td>
  </tr>
  <tr>
    <td>messages</td>
    <td><a href="libraries/wallet-lib/docs/specs/index.html#message">Message</a>[]</td>
    <td colspan="3">Message history</td>
  </tr>
  <tr>
    <td colspan="4"><strong>Additional Information</strong></td>
  </tr>
  <tr>
    <td><strong>Name</strong></td>
    <td colspan="3"><strong>Description</strong></td>
  </tr>
  <tr>
    <td>Access modifiers</td>
    <td colspan="3">Private</td>
  </tr>
  <tr>
    <td>Errors</td>
    <td colspan="3">List of error messages [TBD]</td>
  </tr>
  <tr>
    <td>Required client library methods</td>
    <td colspan="3">
      <ul>
        <li><a href="https://github.com/iotaledger/iota.rs/blob/dev/specs/iota-rs-ENGINEERING-SPEC-0000.md#find_messages">find_messages()</a></li>
      </ul>
    </td>
  </tr>
</table>
<h4 id="select_inputs"><a class="header" href="#select_inputs">select_inputs()</a></h4>
<p>Selects input addresses for funds transfer.</p>
<p>Note: This method should only be used internally by <a href="libraries/wallet-lib/docs/specs/index.html#send">send()</a>. Also, the input selection method should ensure that the recipient address doesn’t match any of the selected inputs or the remainder address. </p>
<p>See <a href="libraries/wallet-lib/docs/specs/index.html#input-selection">Input Selection Process</a> for implementation details.</p>
<table>
  <tr>
    <td colspan="4"><strong>Parameters</strong></td>
  </tr>
  <tr>
    <td><strong>Name</strong></td>
    <td><strong>Required</strong></td>
    <td><strong>Type</strong></td>
    <td><strong>Description</strong></td>
  </tr>
  <tr>
    <td>threshold</td>
    <td>&#10004;</td>
    <td>number</td>
    <td>Amount user wants to spend.</td>
  </tr>
  <tr>
    <td>address</td>
    <td>&#10004;</td>
    <td>string</td>
    <td>Recipient address.</td>
  </tr>
  <tr>
    <td colspan="4"><strong>Returns</strong></td>
  </tr>
  <tr>
    <td><strong>Name</strong></td>
    <td><strong>Type</strong></td>
    <td colspan="3"><strong>Description</strong></td>
  </tr>
  <tr>
    <td>inputs</td>
    <td><a href="libraries/wallet-lib/docs/specs/index.html#address">Address</a>[]</td>
    <td colspan="3">Selected Inputs</td>
  </tr>
  <tr>
    <td>remainder</td>
    <td><a href="libraries/wallet-lib/docs/specs/index.html#address">Address</a></td>
    <td colspan="3">Remainder address object. Empty or null if there’s no need for a remainder</td>
  </tr>
  <tr>
    <td colspan="4"><strong>Additional Information</strong></td>
  </tr>
  <tr>
    <td><strong>Name</strong></td>
    <td colspan="3"><strong>Description</strong></td>
  </tr>
  <tr>
    <td>Access modifiers</td>
    <td colspan="3">Private</td>
  </tr>
  <tr>
    <td>Errors</td>
    <td colspan="3">List of error messages [TBD]</td>
  </tr>
  <tr>
    <td>Required client library methods</td>
    <td colspan="3">None</td>
  </tr>
</table>
<h4 id="send"><a class="header" href="#send">send()</a></h4>
<p>Sends a message to the Tangle.</p>
<p>Note: This method should only be exposed as a successful response from <a href="libraries/wallet-lib/docs/specs/index.html#sync">sync()</a>. </p>
<p>Currently, it is not possible to send multiple payloads. </p>
<p>The process for sending a value transaction:</p>
<ul>
<li>Ensure <code>amount</code> is not set to zero;</li>
<li>Ensure <code>amount</code> does not exceed the total balance;</li>
<li>Ensure recipient address has correct checksum;</li>
<li>Validate <code>data</code> property semantics and size;</li>
<li>Select inputs by using <a href="libraries/wallet-lib/docs/specs/index.html#selectinputs">select_inputs()</a>;</li>
<li>Pass the seralized <a href="libraries/wallet-lib/docs/specs/index.html#unsignedtransaction">unsigned transaction</a> to the Stronghold for signing with its “signTransaction” method;</li>
<li>Perform proof-of-work. <code>pow</code> property in the account object should determine if the proof of work should be offloaded;</li>
<li>Once proof-of-work is successfully performed, the message should be validated and stored in the persistent storage;</li>
<li>After persisting the transaction, it should be broadcasted to the network;</li>
<li>In the event of a broadcast error, there should be (three) attempts for automatic rebroadcasting. If all attempts fail, the send process should terminate and it should be left to the user to retry the failed message. For failed messages, the “broadcasted” property in the transaction objects should be set to false. </li>
</ul>
<table>
  <tr>
    <td colspan="4"><strong>Parameters</strong></td>
  </tr>
  <tr>
    <td><strong>Name</strong></td>
    <td><strong>Required</strong></td>
    <td><strong>Type</strong></td>
    <td><strong>Description</strong></td>
  </tr>
  <tr>
    <td>transfer</td>
    <td>&#10004;</td>
    <td><a href="libraries/wallet-lib/docs/specs/index.html#transfer">Transfer</a></td>
    <td>Transfer object.</td>
  </tr>
  <tr>
    <td colspan="4"><strong>Returns</strong></td>
  </tr>
  <tr>
    <td><strong>Name</strong></td>
    <td><strong>Type</strong></td>
    <td colspan="3"><strong>Description</strong></td>
  </tr>
  <tr>
    <td>message</td>
    <td><a href="libraries/wallet-lib/docs/specs/index.html#message">Message</a></td>
    <td colspan="3">Newly made message.</td>
  </tr>
  <tr>
    <td colspan="4"><strong>Additional Information</strong></td>
  </tr>
  <tr>
    <td><strong>Name</strong></td>
    <td colspan="3"><strong>Description</strong></td>
  </tr>
  <tr>
    <td>Access modifiers</td>
    <td colspan="3">Private</td>
  </tr>
  <tr>
    <td>Errors</td>
    <td colspan="3">List of error messages [TBD]</td>
  </tr>
  <tr>
    <td>Required client library methods</td>
    <td colspan="3">
      <ul>
        <li><a href="https://github.com/iotaledger/iota.rs/blob/dev/specs/iota-rs-ENGINEERING-SPEC-0000.md#find_messages">find_messages()</a></li>
        <li><a href="https://github.com/iotaledger/iota.rs/blob/dev/specs/iota-rs-ENGINEERING-SPEC-0000.md#send">send()</a></li>
      </ul>
    </td>
  </tr>
</table>
<h4 id="retry-1"><a class="header" href="#retry-1">retry()</a></h4>
<p>Rebroadcasts failed message.</p>
<p>Note: This method should only be exposed as a successful response from <a href="libraries/wallet-lib/docs/specs/index.html#sync">sync()</a>. </p>
<p>The process for retrying a failed message:</p>
<ul>
<li>Get message by using <a href="libraries/wallet-lib/docs/specs/index.html#getmessage">get_message()</a>;</li>
<li>Rebroadcast message;</li>
<li>Update account in persistent storage.</li>
</ul>
<table>
  <tr>
    <td colspan="4"><strong>Parameters</strong></td>
  </tr>
  <tr>
    <td><strong>Name</strong></td>
    <td><strong>Required</strong></td>
    <td><strong>Type</strong></td>
    <td><strong>Description</strong></td>
  </tr>
  <tr>
    <td>id</td>
    <td>&#10004;</td>
    <td>string</td>
    <td>Message id</td>
  </tr>
  <tr>
    <td colspan="4"><strong>Returns</strong></td>
  </tr>
  <tr>
    <td><strong>Name</strong></td>
    <td><strong>Type</strong></td>
    <td colspan="3"><strong>Description</strong></td>
  </tr>
  <tr>
    <td>message</td>
    <td><a href="libraries/wallet-lib/docs/specs/index.html#message">Message</a></td>
    <td colspan="3">Newly made message.</td>
  </tr>
  <tr>
    <td colspan="4"><strong>Additional Information</strong></td>
  </tr>
  <tr>
    <td><strong>Name</strong></td>
    <td colspan="3"><strong>Description</strong></td>
  </tr>
  <tr>
    <td>Access modifiers</td>
    <td colspan="3">Private</td>
  </tr>
  <tr>
    <td>Errors</td>
    <td colspan="3">List of error messages [TBD]</td>
  </tr>
  <tr>
    <td>Required client library methods</td>
    <td colspan="3">
      <ul>
        <li><a href="https://github.com/iotaledger/iota.rs/blob/dev/specs/iota-rs-ENGINEERING-SPEC-0000.md#post_message">post_message()</a></li>
      </ul>
    </td>
  </tr>
</table>
<h4 id="sync"><a class="header" href="#sync">sync()</a></h4>
<p>Syncs account with the Tangle. The account syncing process should ensure that the latest metadata (balance, messages) associated with an account is fetched from the Tangle and stored locally.<br />
Note that it is a proposed design decision to enforce account syncing before every send. An alternative way would be to have the <em>send</em> method always exposed and internally ensuring that the account is synced before every message. </p>
<p>The process for account syncing:_</p>
<ul>
<li>Sync addresses using <a href="libraries/wallet-lib/docs/specs/index.html#syncaddresses">sync_addresses()</a>;</li>
<li>Sync messages using <a href="libraries/wallet-lib/docs/specs/index.html#syncmessages">sync_messages()</a>;</li>
<li>Store updated addresses and messages information in persistent storage (if not explicitly set otherwise by the user). </li>
</ul>
<table>
  <tr>
    <td colspan="4"><strong>Parameters</strong></td>
  </tr>
  <tr>
    <td><strong>Name</strong></td>
    <td><strong>Required</strong></td>
    <td><strong>Type</strong></td>
    <td><strong>Description</strong></td>
  </tr>
  <tr>
    <td>index</td>
    <td>&#10008;</td>
    <td>number</td>
    <td>Address index. By default the number of addresses stored for this account should be used as an index.</td>
  </tr>
  <tr>
    <td>gap_limit</td>
    <td>&#10008;</td>
    <td>number</td>
    <td>Number of address indexes that are generated.</td>
  </tr>
  <tr>
    <td>skip_persistence</td>
    <td>&#10008;</td>
    <td>boolean</td>
    <td>
      Skips write to the database. This will be useful if a user wants to scan the Tangle for further addresses to find balance. See the
      <a href="https://docs.iota.org/docs/wallets/0.1/trinity/how-to-guides/perform-a-snapshot-transition">snapshot transition</a> feature provided by Trinity.
    </td>
  </tr>
  <tr>
    <td colspan="4"><strong>Returns</strong></td>
  </tr>
  <tr>
    <td><strong>Name</strong></td>
    <td><strong>Type</strong></td>
    <td colspan="3"><strong>Description</strong></td>
  </tr>
  <tr>
    <td>account</td>
    <td><a href="libraries/wallet-lib/docs/specs/index.html#syncedaccountobject">SyncedAccount</a></td>
    <td colspan="3">Synced account object.</td>
  </tr>
  <tr>
    <td colspan="4"><strong>Additional Information</strong></td>
  </tr>
  <tr>
    <td><strong>Name</strong></td>
    <td colspan="3"><strong>Description</strong></td>
  </tr>
  <tr>
    <td>Access modifiers</td>
    <td colspan="3">Public</td>
  </tr>
  <tr>
    <td>Errors</td>
    <td colspan="3">List of error messages [TBD]</td>
  </tr>
  <tr>
    <td>Required client library methods</td>
    <td colspan="3">
      <ul>
        <li><a href="https://github.com/iotaledger/iota.rs/blob/dev/specs/iota-rs-ENGINEERING-SPEC-0000.md#find_messages">find_messages()</a></li>
        <li><a href="https://github.com/iotaledger/iota.rs/blob/dev/specs/iota-rs-ENGINEERING-SPEC-0000.md#get_address_balances">get_address_balances()</a></li>
      </ul>
    </td>
  </tr>
</table>
<h4 id="reattach-1"><a class="header" href="#reattach-1">reattach()</a></h4>
<p>Reattaches unconfirmed message to the Tangle. 
The following should be considered when implementing this method:</p>
<ul>
<li>Only an unconfirmed message can be reattached. The method should validate the confirmation state of the provided transaction. If a confirmed message id is provided, the method should error out;</li>
<li>The method should also validate if reattachment is necessary, by checking if the message falls below max depth. The criteria for whether the message has fallen below max depth is determined through its timestamp. If 11 minutes have passed since the timestamp of the most recent (reattachment), the message can be be reattached. See <a href="https://github.com/iotaledger/trinity-wallet/blob/3fab4f671c97e805a2b0ade99b4abb8b508c2842/src/shared/libs/iota/transfers.js#L141">this</a> implementation for reference;</li>
<li>Once reattached, the message should be stored in the persistent storage;</li>
<li>If the message was reattached via polling, a <a href="libraries/wallet-lib/docs/specs/index.html#monitor-for-reattachments">reattachment</a> event should be emitted to notify all subscribers. </li>
</ul>
<table>
  <tr>
    <td colspan="4"><strong>Parameters</strong></td>
  </tr>
  <tr>
    <td><strong>Name</strong></td>
    <td><strong>Required</strong></td>
    <td><strong>Type</strong></td>
    <td><strong>Description</strong></td>
  </tr>
  <tr>
    <td>id</td>
    <td>&#10004;</td>
    <td>string</td>
    <td>Message id.</td>
  </tr>
  <tr>
    <td colspan="4"><strong>Returns</strong></td>
  </tr>
  <tr>
    <td><strong>Name</strong></td>
    <td><strong>Type</strong></td>
    <td colspan="3"><strong>Description</strong></td>
  </tr>
  <tr>
    <td>message</td>
    <td><a href="libraries/wallet-lib/docs/specs/index.html#message">Message</a></td>
    <td colspan="3">Newly reattached message.</td>
  </tr>
  <tr>
    <td colspan="4"><strong>Additional Information</strong></td>
  </tr>
  <tr>
    <td><strong>Name</strong></td>
    <td colspan="3"><strong>Description</strong></td>
  </tr>
  <tr>
    <td>Access modifiers</td>
    <td colspan="3">Public</td>
  </tr>
  <tr>
    <td>Errors</td>
    <td colspan="3">List of error messages [TBD]</td>
  </tr>
  <tr>
    <td>Required client library methods</td>
    <td colspan="3">
      <ul>
        <li><a href="https://github.com/iotaledger/iota.rs/blob/dev/specs/iota-rs-ENGINEERING-SPEC-0000.md#reattach">reattach()</a></li>
      </ul>
    </td>
  </tr>
</table>
<h4 id="total_balance"><a class="header" href="#total_balance">total_balance()</a></h4>
<p>Gets total account balance.</p>
<p>Total balance should be read directly from the local storage. To read the latest account balance from the network, <a href="libraries/wallet-lib/docs/specs/index.html#sync">sync()</a> should be used first. </p>
<table>
  <tr>
    <td colspan="4"><strong>Returns</strong></td>
  </tr>
  <tr>
    <td><strong>Type</strong></td>
    <td><strong>Description</strong></td>
  </tr>
  <tr>
    <td><a href="libraries/wallet-lib/docs/specs/index.html#value">Value</a></td>
    <td>Account total balance.</td>
  </tr>
  <tr>
    <td colspan="3"><strong>Additional Information</strong></td>
  </tr>
  <tr>
    <td><strong>Name</strong></td>
    <td colspan="3"><strong>Description</strong></td>
  </tr>
  <tr>
    <td>Access modifiers</td>
    <td colspan="3">Public</td>
  </tr>
  <tr>
    <td>Errors</td>
    <td colspan="3">List of error messages [TBD]</td>
  </tr>
  <tr>
    <td>Required client library methods</td>
    <td colspan="3">None</td>
  </tr>
</table>
<h4 id="available_balance"><a class="header" href="#available_balance">available_balance()</a></h4>
<p>Gets available account balance. Available account balance is the amount users are allowed to spend. It should subtract the pending balance from the total balance. </p>
<p>For example, if a user with <em>50i</em> total account balance has made a transaction spending <em>30i</em>, the available balance should be <em>20i</em> (i.e. 50i - 30i).</p>
<p>Available balance should be read directly from the local storage. To read the latest account balance from the network, <a href="libraries/wallet-lib/docs/specs/index.html#sync">sync()</a> should be used first.</p>
<table>
  <tr>
    <td colspan="4"><strong>Returns</strong></td>
  </tr>
  <tr>
    <td><strong>Type</strong></td>
    <td colspan="3"><strong>Description</strong></td>
  </tr>
  <tr>
    <td><a href="libraries/wallet-lib/docs/specs/index.html#value">Value</a></td>
    <td>Account available balance.</td>
  </tr>
  <tr>
    <td colspan="3"><strong>Additional Information</strong></td>
  </tr>
  <tr>
    <td><strong>Name</strong></td>
    <td colspan="3"><strong>Description</strong></td>
  </tr>
  <tr>
    <td>Access modifiers</td>
    <td colspan="3">Public</td>
  </tr>
  <tr>
    <td>Errors</td>
    <td colspan="3">List of error messages [TBD]</td>
  </tr>
  <tr>
    <td>Required client library methods</td>
    <td colspan="3">None</td>
  </tr>
</table>
<h4 id="set_alias"><a class="header" href="#set_alias">set_alias()</a></h4>
<p>Updates account name</p>
<table>
  <tr>
    <td colspan="4"><strong>Parameters</strong></td>
  </tr>
  <tr>
    <td><strong>Name</strong></td>
    <td><strong>Required</strong></td>
    <td><strong>Type</strong></td>
    <td><strong>Description</strong></td>
  </tr>
  <tr>
    <td>alias</td>
    <td>&#10004;</td>
    <td>string</td>
    <td>New account name.</td>
  </tr>
  <tr>
    <td colspan="4"><strong>Additional Information</strong></td>
  </tr>
  <tr>
    <td><strong>Name</strong></td>
    <td colspan="3"><strong>Description</strong></td>
  </tr>
  <tr>
    <td>Access modifiers</td>
    <td colspan="3">Public</td>
  </tr>
  <tr>
    <td>Errors</td>
    <td colspan="3">List of error messages [TBD]</td>
  </tr>
  <tr>
    <td>Required client library methods</td>
    <td colspan="3">None</td>
  </tr>
</table>
<h4 id="list_messages"><a class="header" href="#list_messages">list_messages()</a></h4>
<p>Gets messages. Messages should be read directly from the local storage. To ensure the local database is updated with the latest messages, <a href="libraries/wallet-lib/docs/specs/index.html#sync">sync()</a> should be used first.</p>
<table>
  <tr>
    <td colspan="4"><strong>Parameters</strong></td>
  </tr>
  <tr>
    <td><strong>Name</strong></td>
    <td><strong>Required</strong></td>
    <td><strong>Type</strong></td>
    <td><strong>Description</strong></td>
  </tr>
  <tr>
    <td>count</td>
    <td>&#10004;</td>
    <td>number</td>
    <td>Number of (most recent) messages.</td>
  </tr>
  <tr>
    <td>from</td>
    <td>&#10004;</td>
    <td>number</td>
    <td>Subset of messages. For example: count = 10, from = 5, it should return ten messages skipping the most recent five messages.</td>
  </tr>
  <tr>
    <td colspan="4"><strong>Returns</strong></td>
  </tr>
  <tr>
    <td><strong>Name</strong></td>
    <td><strong>Type</strong></td>
    <td colspan="3"><strong>Description</strong></td>
  </tr>
  <tr>
    <td>messages</td>
    <td><a href="libraries/wallet-lib/docs/specs/index.html#message">Message</a>[]</td>
    <td colspan="3">All messages.</td>
  </tr>
  <tr>
    <td colspan="4"><strong>Additional Information</strong></td>
  </tr>
  <tr>
    <td><strong>Name</strong></td>
    <td colspan="3"><strong>Description</strong></td>
  </tr>
  <tr>
    <td>Access modifiers</td>
    <td colspan="3">Public</td>
  </tr>
  <tr>
    <td>Errors</td>
    <td colspan="3">List of error messages [TBD]</td>
  </tr>
  <tr>
    <td>Required client library methods</td>
    <td colspan="3">None</td>
  </tr>
</table>
<h4 id="list_received_messages"><a class="header" href="#list_received_messages">list_received_messages()</a></h4>
<p>Gets all received messages.</p>
<p>Messages should be read directly from the local storage. To ensure the local database is updated with the latest messages, <a href="libraries/wallet-lib/docs/specs/index.html#sync">sync()</a> should be used first. </p>
<table>
  <tr>
    <td colspan="4"><strong>Parameters</strong></td>
  </tr>
  <tr>
    <td><strong>Name</strong></td>
    <td><strong>Required</strong></td>
    <td><strong>Type</strong></td>
    <td><strong>Description</strong></td>
  </tr>
  <tr>
    <td>count</td>
    <td>&#10004;</td>
    <td>number</td>
    <td>Number of (most recent) received messages.</td>
  </tr>
  <tr>
    <td>from</td>
    <td>&#10004;</td>
    <td>number</td>
    <td>Subset of received messages.</td>
  </tr>
  <tr>
    <td colspan="4"><strong>Returns</strong></td>
  </tr>
  <tr>
    <td><strong>Name</strong></td>
    <td><strong>Type</strong></td>
    <td colspan="3"><strong>Description</strong></td>
  </tr>
  <tr>
    <td>messages</td>
    <td><a href="libraries/wallet-lib/docs/specs/index.html#message">Message</a>[]</td>
    <td colspan="3">All received messages.</td>
  </tr>
  <tr>
    <td colspan="4"><strong>Additional Information</strong></td>
  </tr>
  <tr>
    <td><strong>Name</strong></td>
    <td colspan="3"><strong>Description</strong></td>
  </tr>
  <tr>
    <td>Access modifiers</td>
    <td colspan="3">Public</td>
  </tr>
  <tr>
    <td>Errors</td>
    <td colspan="3">List of error messages [TBD]</td>
  </tr>
  <tr>
    <td>Required client library methods</td>
    <td colspan="3">None</td>
  </tr>
</table>
<h4 id="list_sent_messages"><a class="header" href="#list_sent_messages">list_sent_messages()</a></h4>
<p>Gets all sent messages.</p>
<p>Messages should be directly read from the local storage. To ensure the local database is updated with the latest messages, <a href="libraries/wallet-lib/docs/specs/index.html#sync">sync()</a> should be used first.</p>
<table>
  <tr>
    <td colspan="4"><strong>Parameters</strong></td>
  </tr>
  <tr>
    <td><strong>Name</strong></td>
    <td><strong>Required</strong></td>
    <td><strong>Type</strong></td>
    <td><strong>Description</strong></td>
  </tr>
  <tr>
    <td>count</td>
    <td>&#10004;</td>
    <td>number</td>
    <td>Number of (most recent) sent messages.</td>
  </tr>
  <tr>
    <td>from</td>
    <td>&#10004;</td>
    <td>number</td>
    <td>Subset of sent messages.</td>
  </tr>
  <tr>
    <td colspan="4"><strong>Returns</strong></td>
  </tr>
  <tr>
    <td><strong>Name</strong></td>
    <td><strong>Type</strong></td>
    <td colspan="3"><strong>Description</strong></td>
  </tr>
  <tr>
    <td>messages</td>
    <td><a href="libraries/wallet-lib/docs/specs/index.html#message">Message</a>[]</td>
    <td colspan="3">All sent messages.</td>
  </tr>
  <tr>
    <td colspan="4"><strong>Additional Information</strong></td>
  </tr>
  <tr>
    <td><strong>Name</strong></td>
    <td colspan="3"><strong>Description</strong></td>
  </tr>
  <tr>
    <td>Access modifiers</td>
    <td colspan="3">Public</td>
  </tr>
  <tr>
    <td>Errors</td>
    <td colspan="3">List of error messages [TBD]</td>
  </tr>
  <tr>
    <td>Required client library methods</td>
    <td colspan="3">None</td>
  </tr>
</table>
<h4 id="list_failed_messages"><a class="header" href="#list_failed_messages">list_failed_messages()</a></h4>
<p>Gets all failed (broadcasted = false) messages. Messages should be read directly from the local storage.</p>
<table>
  <tr>
    <td colspan="4"><strong>Returns</strong></td>
  </tr>
  <tr>
    <td><strong>Name</strong></td>
    <td><strong>Type</strong></td>
    <td colspan="3"><strong>Description</strong></td>
  </tr>
  <tr>
    <td><strong>Name</strong></td>
    <td><strong>Required</strong></td>
    <td><strong>Type</strong></td>
    <td><strong>Description</strong></td>
  </tr>
  <tr>
    <td>count</td>
    <td>&#10004;</td>
    <td>number</td>
    <td>Number of (most recent) failed messages.</td>
  </tr>
  <tr>
    <td>from</td>
    <td>&#10004;</td>
    <td>number</td>
    <td>Subset of failed messages.</td>
  </tr>
  <tr>
    <td colspan="4"><strong>Returns</strong></td>
  </tr>
  <tr>
    <td>messages</td>
    <td><a href="libraries/wallet-lib/docs/specs/index.html#message">Message</a>[]</td>
    <td colspan="3">All failed messages.</td>
  </tr>
  <tr>
    <td colspan="4"><strong>Additional Information</strong></td>
  </tr>
  <tr>
    <td><strong>Name</strong></td>
    <td colspan="3"><strong>Description</strong></td>
  </tr>
  <tr>
    <td>Access modifiers</td>
    <td colspan="3">Public</td>
  </tr>
  <tr>
    <td>Errors</td>
    <td colspan="3">List of error messages [TBD]</td>
  </tr>
  <tr>
    <td>Required client library methods</td>
    <td colspan="3">None</td>
  </tr>
</table>
<h4 id="list_unconfirmed_messages"><a class="header" href="#list_unconfirmed_messages">list_unconfirmed_messages()</a></h4>
<p>Gets all unconfirmed (confirmed = false) messages. Messages should be read directly from the local storage.</p>
<table>
  <tr>
    <td colspan="4"><strong>Returns</strong></td>
  </tr>
  <tr>
    <td><strong>Name</strong></td>
    <td><strong>Required</strong></td>
    <td><strong>Type</strong></td>
    <td><strong>Description</strong></td>
  </tr>
  <tr>
    <td>count</td>
    <td>&#10004;</td>
    <td>number</td>
    <td>Number of (most recent) unconfirmed messages.</td>
  </tr>
  <tr>
    <td>from</td>
    <td>&#10004;</td>
    <td>number</td>
    <td>Subset of unconfirmed messages.</td>
  </tr>
  <tr>
    <td colspan="4"><strong>Returns</strong></td>
  </tr>
  <tr>
    <td><strong>Name</strong></td>
    <td><strong>Type</strong></td>
    <td colspan="3"><strong>Description</strong></td>
  </tr>
  <tr>
    <td>messages</td>
    <td><a href="libraries/wallet-lib/docs/specs/index.html#message">Message</a>[]</td>
    <td colspan="3">All unconfirmed messages.</td>
  </tr>
  <tr>
    <td colspan="4"><strong>Additional Information</strong></td>
  </tr>
  <tr>
    <td><strong>Name</strong></td>
    <td colspan="3"><strong>Description</strong></td>
  </tr>
  <tr>
    <td>Access modifiers</td>
    <td colspan="3">Public</td>
  </tr>
  <tr>
    <td>Errors</td>
    <td colspan="3">List of error messages [TBD]</td>
  </tr>
  <tr>
    <td>Required client library methods</td>
    <td colspan="3">None</td>
  </tr>
</table>
<h4 id="get_message-1"><a class="header" href="#get_message-1">get_message()</a></h4>
<p>Gets message for provided id.</p>
<p>Messages should be read directly from the local storage. To ensure the local database is updated with the latest messages, <a href="libraries/wallet-lib/docs/specs/index.html#sync">sync()</a> should be used first. </p>
<table>
  <tr>
    <td colspan="4"><strong>Parameters</strong></td>
  </tr>
  <tr>
    <td><strong>Name</strong></td>
    <td><strong>Required</strong></td>
    <td><strong>Type</strong></td>
    <td><strong>Description</strong></td>
  </tr>
  <tr>
    <td>id</td>
    <td>&#10004;</td>
    <td>string</td>
    <td>Message id.</td>
  </tr>
  <tr>
    <td colspan="4"><strong>Returns</strong></td>
  </tr>
  <tr>
    <td><strong>Name</strong></td>
    <td><strong>Type</strong></td>
    <td colspan="3"><strong>Description</strong></td>
  </tr>
  <tr>
    <td>message</td>
    <td><a href="libraries/wallet-lib/docs/specs/index.html#message">Message</a></td>
    <td colspan="3">Message object.</td>
  </tr>
  <tr>
    <td colspan="4"><strong>Additional Information</strong></td>
  </tr>
  <tr>
    <td><strong>Name</strong></td>
    <td colspan="3"><strong>Description</strong></td>
  </tr>
  <tr>
    <td>Access modifiers</td>
    <td colspan="3">Public</td>
  </tr>
  <tr>
    <td>Errors</td>
    <td colspan="3">List of error messages [TBD]</td>
  </tr>
  <tr>
    <td>Required client library methods</td>
    <td colspan="3">None</td>
  </tr>
</table>
<h4 id="list_addresses"><a class="header" href="#list_addresses">list_addresses()</a></h4>
<p>Gets all addresses.</p>
<table>
  <tr>
    <td colspan="4"><strong>Returns</strong></td>
  </tr>
  <tr>
    <td><strong>Name</strong></td>
    <td><strong>Type</strong></td>
    <td colspan="3"><strong>Description</strong></td>
  </tr>
  <tr>
    <td>addresses</td>
    <td><a href="libraries/wallet-lib/docs/specs/index.html#address">Address</a>[]</td>
    <td>All addresses.</td>
  </tr>
  <tr>
    <td colspan="3"><strong>Additional Information</strong></td>
  </tr>
  <tr>
    <td><strong>Name</strong></td>
    <td colspan="3"><strong>Description</strong></td>
  </tr>
  <tr>
    <td>Access modifiers</td>
    <td colspan="3">Public</td>
  </tr>
  <tr>
    <td>Errors</td>
    <td colspan="3">List of error messages [TBD]</td>
  </tr>
  <tr>
    <td>Required client library methods</td>
    <td colspan="3">None</td>
  </tr>
</table>
<h4 id="list_unspent_addresses"><a class="header" href="#list_unspent_addresses">list_unspent_addresses()</a></h4>
<p>Gets all unspent input addresses</p>
<table>
  <tr>
    <td colspan="4"><strong>Returns</strong></td>
  </tr>
  <tr>
    <td>Name</td>
    <td><strong>Type</strong></td>
    <td><strong>Description</strong></td>
  </tr>
  <tr>
    <td>addresses</td>
    <td><a href="libraries/wallet-lib/docs/specs/index.html#address">Address</a>[]</td>
    <td>All unspent input addresses.</td>
  </tr>
  <tr>
    <td colspan="3"><strong>Additional Information</strong></td>
  </tr>
  <tr>
    <td><strong>Name</strong></td>
    <td colspan="3"><strong>Description</strong></td>
  </tr>
  <tr>
    <td>Access modifiers</td>
    <td colspan="3">Public</td>
  </tr>
  <tr>
    <td>Errors</td>
    <td colspan="3">List of error messages [TBD]</td>
  </tr>
  <tr>
    <td>Required client library methods</td>
    <td colspan="3">None</td>
  </tr>
</table>
<h4 id="generate_address"><a class="header" href="#generate_address">generate_address()</a></h4>
<p>Gets the latest unused address.</p>
<table>
  <tr>
    <td colspan="4"><strong>Returns</strong></td>
  </tr>
  <tr>
    <td><strong>Name</strong></td>
    <td><strong>Type</strong></td>
    <td colspan="3"><strong>Description</strong></td>
  </tr>
  <tr>
    <td>address</td>
    <td><a href="libraries/wallet-lib/docs/specs/index.html#address">Address</a></td>
    <td>A new address object.</td>
  </tr>
  <tr>
    <td colspan="3"><strong>Additional Information</strong></td>
  </tr>
  <tr>
    <td><strong>Name</strong></td>
    <td colspan="3"><strong>Description</strong></td>
  </tr>
  <tr>
    <td>Access modifiers</td>
    <td colspan="3">Public</td>
  </tr>
  <tr>
    <td>Errors</td>
    <td colspan="3">List of error messages [TBD]</td>
  </tr>
  <tr>
    <td>Required client library methods</td>
    <td colspan="3">None</td>
  </tr>
</table>
<h2 id="account-manager"><a class="header" href="#account-manager">Account Manager</a></h2>
<p>An account manager class should be publicly available for users. With the account manager, the user can create, update, delete or manage multiple accounts. The implementation details of a specific account should be abstracted away using this account manager wrapper. </p>
<h3 id="api-2"><a class="header" href="#api-2">API</a></h3>
<h4 id="initialisation-3"><a class="header" href="#initialisation-3">Initialisation</a></h4>
<p>Initialises the account manager. Account manager initialisation should validate the adapter object semantics and should return an instance of the account manager.</p>
<table>
  <tr>
    <td colspan="4"><strong>Parameters</strong></td>
  </tr>
  <tr>
    <td><strong>Name</strong></td>
    <td><strong>Required</strong></td>
    <td><strong>Type</strong></td>
    <td><strong>Description</strong></td>
  </tr>
  <tr>
    <td>adapter</td>
    <td>&#10008;</td>
    <td><a href="libraries/wallet-lib/docs/specs/index.html#storageadapter">Adapter</a></td>
    <td>Initialisation method receives an optional storage adapter.</td>
  </tr>
  <tr>
    <td colspan="4"><strong>Returns</strong></td>
  </tr>
  <tr>
    <td><strong>Name</strong></td>
    <td><strong>Type</strong></td>
    <td colspan="3"><strong>Description</strong></td>
  </tr>
  <tr>
    <td>manager</td>
    <td><a href="libraries/wallet-lib/docs/specs/index.html#accountsmanagerobject">AccountManager</a></td>
    <td colspan="3">Account manager instance.</td>
  </tr>
  <tr>
    <td colspan="4"><strong>Additional Information</strong></td>
  </tr>
  <tr>
    <td><strong>Name</strong></td>
    <td colspan="3"><strong>Description</strong></td>
  </tr>
  <tr>
    <td>Access modifiers</td>
    <td colspan="3">Public</td>
  </tr>
  <tr>
    <td>Errors</td>
    <td colspan="3">List of error messages [TBD]</td>
  </tr>
  <tr>
    <td>Required client library methods</td>
    <td colspan="3">None</td>
  </tr>
</table>
<h4 id="add_account"><a class="header" href="#add_account">add_account()</a></h4>
<p>Adds new account</p>
<p>See account <a href="libraries/wallet-lib/docs/specs/index.html#initialisation">initialisation</a> for detailed implementation guidelines.</p>
<table>
  <tr>
    <td colspan="4"><strong>Parameters</strong></td>
  </tr>
  <tr>
    <td><strong>Name</strong></td>
    <td><strong>Required</strong></td>
    <td><strong>Type</strong></td>
    <td><strong>Description</strong></td>
  </tr>
  <tr>
    <td>config</td>
    <td>&#10004;</td>
    <td>
      <a href="libraries/wallet-lib/docs/specs/index.html#accountconfiguration">AccountConfig</a>
    </td>
    <td>Account configuration object.</td>
  </tr>
  <tr>
    <td colspan="4"><strong>Returns</strong></td>
  </tr>
  <tr>
    <td><strong>Name</strong></td>
    <td><strong>Type</strong></td>
    <td colspan="3"><strong>Description</strong></td>
  </tr>
  <tr>
    <td>accounts</td>
    <td>
      <a href="libraries/wallet-lib/docs/specs/index.html#account">Account</a>
    </td>
    <td colspan="3">Newly created account.</td>
  </tr>
  <tr>
    <td colspan="4"><strong>Additional Information</strong></td>
  </tr>
  <tr>
    <td><strong>Name</strong></td>
    <td colspan="3"><strong>Description</strong></td>
  </tr>
  <tr>
    <td>Access modifiers</td>
    <td colspan="3">Public</td>
  </tr>
  <tr>
    <td>Errors</td>
    <td colspan="3">List of error messages [TBD]</td>
  </tr>
  <tr>
    <td>Required client library methods</td>
    <td colspan="3">None</td>
  </tr>
</table>
<h4 id="remove_account"><a class="header" href="#remove_account">remove_account()</a></h4>
<p>Removes an account.</p>
<p>The following should be considered when removing an account:</p>
<ul>
<li>An account should first be removed from the Stronghold using its “removeAccount” method;</li>
<li>Once the account references have been removed from the Stronghold, the account should be deleted from the persistent storage.</li>
</ul>
<table>
  <tr>
    <td colspan="4"><strong>Parameters</strong></td>
  </tr>
  <tr>
    <td><strong>Name</strong></td>
    <td><strong>Required</strong></td>
    <td><strong>Type</strong></td>
    <td><strong>Description</strong></td>
  </tr>
  <tr>
    <td>identifier</td>
    <td>&#10004;</td>
    <td>
      { address: &lt;string> } | { alias: &lt;string> } |
      <p>
        { id: &lt;number> } |
      </p>
      <p>
        { index: &lt;number }
      </p>
    </td>
    <td>Identifier. Could be one of address, alias, id or index.</td>
  </tr>
  <tr>
    <td colspan="4"><strong>Additional Information</strong></td>
  </tr>
  <tr>
    <td><strong>Name</strong></td>
    <td colspan="3"><strong>Description</strong></td>
  </tr>
  <tr>
    <td>Access modifiers</td>
    <td colspan="3">Public</td>
  </tr>
  <tr>
    <td>Errors</td>
    <td colspan="3">List of error messages [TBD]</td>
  </tr>
  <tr>
    <td>Required client library methods</td>
    <td colspan="3">None</td>
  </tr>
</table>
<h4 id="sync_accounts"><a class="header" href="#sync_accounts">sync_accounts()</a></h4>
<p>Syncs all stored accounts with the Tangle. Syncing should get the latest balance for all accounts and should find any new messages associated with the stored account.</p>
<p>See <a href="libraries/wallet-lib/docs/specs/index.html#accounts-syncing-process">Accounts Syncing Process</a>.</p>
<table>
  <tr>
    <td colspan="3"><strong>Returns</strong></td>
  </tr>
  <tr>
    <td><strong>Name</strong></td>
    <td><strong>Type</strong></td>
    <td><strong>Description</strong></td>
  </tr>
  <tr>
    <td>account</td>
    <td><a href="libraries/wallet-lib/docs/specs/index.html#syncedaccountobject">SyncedAccount</a>[]</td>
    <td>Synced accounts.</td>
  </tr>
  <tr>
    <td colspan="4"><strong>Additional Information</strong></td>
  </tr>
  <tr>
    <td><strong>Name</strong></td>
    <td colspan="3"><strong>Description</strong></td>
  </tr>
  <tr>
    <td>Access modifiers</td>
    <td colspan="3">Public</td>
  </tr>
  <tr>
    <td>Errors</td>
    <td colspan="3">List of error messages [TBD]</td>
  </tr>
  <tr>
    <td>Required client library methods</td>
    <td colspan="3">
    <ul>
      <li><a href="libraries/wallet-lib/docs/specs/sync">sync()</a></li>
    </ul>
    </td>
  </tr>
</table>
<h4 id="move"><a class="header" href="#move">move()</a></h4>
<p>Moves funds from one account to another. This method should leverage the <a href="libraries/wallet-lib/docs/specs/index.html#send">send()</a> method from the sender account and should initiate a message to the receiver account.</p>
<table>
  <tr>
    <td colspan="4"><strong>Parameters</strong></td>
  </tr>
  <tr>
    <td><strong>Name</strong></td>
    <td><strong>Required</strong></td>
    <td><strong>Type</strong></td>
    <td><strong>Description</strong></td>
  </tr>
  <tr>
    <td>from</td>
    <td>&#10004;</td>
    <td>
      { address: &lt;string> } | \ { alias: &lt;string> } |
      <p>
        { id: &lt;number> } |
      </p>
      <p>
        { index: &lt;number }
      </p>
    </td>
    <td>Identifier. Could be one of address, alias, id or index.</td>
  </tr>
  <tr>
    <td>to</td>
    <td>&#10004;</td>
    <td>
      { address: &lt;string> } | \ { alias: &lt;string> } |
      <p>
        { id: &lt;number> } |
      </p>
      <p>
        { index: &lt;number }
      </p>
    </td>
    <td>Identifier. Could be one of address, alias, id or index.</td>
  </tr>
  <tr>
    <td>amount</td>
    <td>&#10004;</td>
    <td>number</td>
    <td>Transaction amount.</td>
  </tr>
  <tr>
    <td colspan="4"><strong>Additional Information</strong></td>
  </tr>
  <tr>
    <td><strong>Name</strong></td>
    <td colspan="3"><strong>Description</strong></td>
  </tr>
  <tr>
    <td>Access modifiers</td>
    <td colspan="3">Public</td>
  </tr>
  <tr>
    <td>Errors</td>
    <td colspan="3">List of error messages [TBD]</td>
  </tr>
  <tr>
    <td>Required client library methods</td>
    <td colspan="3">None</td>
  </tr>
</table>
<h4 id="backup"><a class="header" href="#backup">backup()</a></h4>
<p>Safely creates a backup of the accounts to a destination. The file could simply be JSON containing the address &amp; transaction histories for accounts.</p>
<p>This method should provide the Stronghold instance with the metadata of all accounts. </p>
<table>
  <tr>
    <td colspan="4"><strong>Parameters</strong></td>
  </tr>
  <tr>
    <td><strong>Name</strong></td>
    <td><strong>Required</strong></td>
    <td><strong>Type</strong></td>
    <td><strong>Description</strong></td>
  </tr>
  <tr>
    <td>destination</td>
    <td>&#10004;</td>
    <td>string</td>
    <td>Path where the backup should be stored.</td>
  </tr>
  <tr>
    <td colspan="4"><strong>Additional Information</strong></td>
  </tr>
  <tr>
    <td><strong>Name</strong></td>
    <td colspan="3"><strong>Description</strong></td>
  </tr>
  <tr>
    <td>Access modifiers</td>
    <td colspan="3">Public</td>
  </tr>
  <tr>
    <td>Errors</td>
    <td colspan="3">List of error messages [TBD]</td>
  </tr>
  <tr>
    <td>Required client library methods</td>
    <td colspan="3">None</td>
  </tr>
</table>
<h4 id="import_accounts"><a class="header" href="#import_accounts">import_accounts</a></h4>
<p>Import (backed up) accounts.</p>
<p><strong>Implementation details are not finalised.</strong></p>
<table>
  <tr>
   <td colspan="4"><strong>Parameters</strong></td>
  </tr>
  <tr>
   <td><strong>Name</strong></td>
   <td><strong>Required</strong></td>
   <td><strong>Type</strong></td>
   <td><strong>Description</strong></td>
  </tr>
  <tr>
   <td>accounts</td>
   <td>&#10004;</td>
<td><a href="libraries/wallet-lib/docs/specs/index.html#account">Account</a>[]
   </td>
   <td>Account object.</td>
  </tr>
  <tr>
<td colspan="4"><strong>Additional Information</strong></td>
</tr>
<tr>
<td><strong>Name</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>Access modifiers</td>
<td colspan="3">Public</td>
</tr>
<tr>
<td>Errors</td>
<td colspan="3">List of error messages [TBD]</td>
</tr>
<tr>
<td>Required client library methods</td>
<td colspan="3">None</td>
</tr>
</table>
<h4 id="get_account"><a class="header" href="#get_account">get_account()</a></h4>
<p>Returns the account associated with the provided identifier.</p>
<table>
  <tr>
   <td colspan="4"><strong>Parameters</strong>
   </td>
  </tr>
  <tr>
   <td><strong>Name</strong></td>
   <td><strong>Required</strong></td>
   <td><strong>Type</strong></td>
   <td><strong>Description</strong></td>
  </tr>
  <tr>
   <td>identifier</td>
   <td>&#10004;</td>
   <td>{ address: &lt;string> } |  \
{ alias: &lt;string>  } |
<p>
{ id: &lt;number> } |
<p>
{ index: &lt;number }
   </td>
   <td>Identifier. Could be one of address, alias, id or index. 
   </td>
  </tr>
  <tr>
   <td colspan="4"><strong>Returns</strong>
   </td>
  </tr>
  <tr>
   <td><strong>Name</strong>
   </td>
   <td><strong>Type</strong>
   </td>
   <td colspan="3"><strong>Description</strong>
   </td>
  </tr>
  <tr>
   <td>account</td>
   <td>
<a href="libraries/wallet-lib/docs/specs/index.html#account">Account</a>
   </td>
   <td colspan="3">Account associated with identifier.</td>
  </tr>
  <tr>
<td colspan="4"><strong>Additional Information</strong></td>
</tr>
<tr>
<td><strong>Name</strong></td>
<td colspan="3"><strong>Description</strong></td>
</tr>
<tr>
<td>Access modifiers</td>
<td colspan="3">Public</td>
</tr>
<tr>
<td>Errors</td>
<td colspan="3">List of error messages [TBD]</td>
</tr>
<tr>
<td>Required client library methods</td>
<td colspan="3">None</td>
</tr>
</table>
<h4 id="reattach-2"><a class="header" href="#reattach-2">reattach()</a></h4>
<p>Reattaches an unconfirmed message.</p>
<p>See <a href="libraries/wallet-lib/docs/specs/index.html#reattach">reattach()</a> method for implementation details. This method is a wrapper method provided for convenience. A user could directly access the <a href="libraries/wallet-lib/docs/specs/index.html#reattach">reattach()</a> method on an account object. </p>
<table>
  <tr>
    <td colspan="4"><strong>Parameters</strong></td>
  </tr>
  <tr>
    <td><strong>Name</strong></td>
    <td><strong>Required</strong></td>
    <td><strong>Type</strong></td>
    <td><strong>Description</strong></td>
  </tr>
  <tr>
    <td>identifier</td>
    <td>&#10004;</td>
    <td>
      { address: &lt;string> } | \ { alias: &lt;string> } |
      <p>
        { id: &lt;number> } |
      </p>
      <p>
        { index: &lt;number }
      </p>
    </td>
    <td>Identifier. Could be one of address, alias, id or index.</td>
  </tr>
  <tr>
    <td>id</td>
    <td>&#10004;</td>
    <td>string</td>
    <td>Message id.</td>
  </tr>
  <tr>
    <td colspan="4"><strong>Returns</strong></td>
  </tr>
  <tr>
    <td><strong>Name</strong></td>
    <td><strong>Type</strong></td>
    <td colspan="3"><strong>Description</strong></td>
  </tr>
  <tr>
    <td>message</td>
    <td><a href="libraries/wallet-lib/docs/specs/index.html#message">Message</a></td>
    <td colspan="3">Newly reattached message.</td>
  </tr>
  <tr>
    <td colspan="4"><strong>Additional Information</strong></td>
  </tr>
  <tr>
    <td><strong>Name</strong></td>
    <td colspan="3"><strong>Description</strong></td>
  </tr>
  <tr>
    <td>Access modifiers</td>
    <td colspan="3">Public</td>
  </tr>
  <tr>
    <td>Errors</td>
    <td colspan="3">List of error messages [TBD]</td>
  </tr>
  <tr>
    <td>Required client library methods</td>
    <td colspan="3">None</td>
  </tr>
</table>
<h2 id="events"><a class="header" href="#events">Events</a></h2>
<p>Events are categorised as the following:</p>
<ol>
<li>
<p>Reactive messages emitted from the node software whenever the state on the node changes. For example, emitting new messages received by the node. Clients (Wallet) can subscribe to these events to get notified if any relevant change occurs on the node. See <a href="https://github.com/iotaledger/wallet-spec/tree/events">example</a>.</p>
</li>
<li>
<p>Messages emitted from the wallet library whenever there are any important state changes. Note that in cases where a user triggered action leads to a state change, the messages would not be emitted. For example, if a user explicitly triggers a <a href="libraries/wallet-lib/docs/specs/index.html#sync">sync()</a> action leading to a state change, an explicit event is not necessary.</p>
</li>
</ol>
<h3 id="category-1-events"><a class="header" href="#category-1-events">Category 1 events</a></h3>
<p>On every update sent from the node software via an event, the wallet library should update internal (persistent) storage and should also emit events via <strong>category 2</strong>. </p>
<h4 id="monitor-address-for-balance-changes"><a class="header" href="#monitor-address-for-balance-changes">Monitor address for balance changes</a></h4>
<table>
  <tr>
   <td colspan="3"><strong>Event</strong>
   </td>
   <td><strong>Returned Data</strong></td>
  </tr>
  <tr>
   <td colspan="3" >&lt;Address : Balance></td>
   <td>
    <ul>
      <li>Index 1: Address</li>
      <li>Index 2: New balance on the address</li>
    </ul>
   </td>
  </tr>
</table>
<h4 id="monitor-address-for-new-messages"><a class="header" href="#monitor-address-for-new-messages">Monitor address for new messages</a></h4>
<table>
  <tr>
   <td colspan="3"><strong>Event</strong>
   </td>
   <td><strong>Returned Data</strong></td>
  </tr>
  <tr>
   <td colspan="3">&lt;Address : Message></td>
   <td>
   <ul>
      <li>Index 1: Address</li>
      <li>Index 2: Id of the new message</li>
    </ul>
   </td>
  </tr>
</table>
<h4 id="monitor-message-for-confirmation-state"><a class="header" href="#monitor-message-for-confirmation-state">Monitor message for confirmation state</a></h4>
<table>
  <tr>
   <td colspan="3" ><strong>Event</strong>
   </td>
   <td><strong>Returned Data</strong>
   </td>
  </tr>
  <tr>
   <td colspan="3">&lt;MessageId>
   </td>
   <td>
    <ul>
      <li>Index 1: Message Id</li>
      <li>Index 2: Confirmation state</li>
    </ul>
   </td>
  </tr>
</table>
<h3 id="category-2-events"><a class="header" href="#category-2-events">Category 2 events</a></h3>
<p>They could be triggered via events from <strong>category 1</strong> or through <a href="libraries/wallet-lib/docs/specs/index.html#polling">polling</a>. </p>
<h4 id="monitor-for-balance-changes"><a class="header" href="#monitor-for-balance-changes">Monitor for balance changes</a></h4>
<table>
  <tr>
   <td colspan="3"><strong>Event</strong>
   </td>
   <td><strong>Returned Data</strong></td>
  </tr>
  <tr>
   <td colspan="3">balances
   </td>
   <td>[{ accountId, address, balance }]</td>
  </tr>
</table>
<h4 id="monitor-for-new-messages"><a class="header" href="#monitor-for-new-messages">Monitor for new messages</a></h4>
<table>
  <tr>
   <td colspan="3"><strong>Event</strong>
   </td>
   <td><strong>Returned Data</strong></td>
  </tr>
  <tr>
   <td colspan="3">messages</td>
   <td>[{ accountId, messages }]</td>
  </tr>
</table>
<h4 id="monitor-for-confirmation-state"><a class="header" href="#monitor-for-confirmation-state">Monitor for confirmation state</a></h4>
<table>
  <tr>
   <td colspan="3"><strong>Event</strong></td>
   <td><strong>Returned Data</strong></td>
  </tr>
  <tr>
   <td colspan="3">confirmations</td>
   <td>[{ accountId, messages  }]</td>
  </tr>
</table>
<h4 id="monitor-for-reattachments"><a class="header" href="#monitor-for-reattachments">Monitor for reattachments</a></h4>
<table>
  <tr>
   <td colspan="3"><strong>Event</strong></td>
   <td><strong>Returned Data</strong></td>
  </tr>
  <tr>
   <td colspan="3">reattachments</td>
   <td>[{ accountId, messages  }]</td>
  </tr>
</table>
<h4 id="monitor-for-broadcasts"><a class="header" href="#monitor-for-broadcasts">Monitor for broadcasts</a></h4>
<table>
  <tr>
   <td colspan="3" ><strong>Event</strong>
   </td>
   <td><strong>Returned Data</strong></td>
  </tr>
  <tr>
   <td colspan="3">broadcasts</td>
   <td>[{ accountId, messages  }]</td>
  </tr>
</table>
<h4 id="monitor-for-errors"><a class="header" href="#monitor-for-errors">Monitor for errors</a></h4>
<table>
  <tr>
   <td colspan="3" ><strong>Event</strong></td>
   <td><strong>Returned Data</strong></td>
  </tr>
  <tr>
   <td colspan="3">error</td>
   <td>{ type, error  }</td>
  </tr>
</table>
<h2 id="privacy"><a class="header" href="#privacy">Privacy</a></h2>
<p>To maintain the financial privacy of wallet users, the application/wallet should enforce strategies that will guarantee a certain level of anonymity. These strategies should be followed:</p>
<ul>
  <li>The wallet should only use a single address per message i.e. if an address is already used in a message, it should not be used as a deposit address and instead a new address should be generated;</li>
  <li>The input selection strategy should expose as little information as possible. See input selection for details.</li>
</ul>
<p>Some other privacy enhancing techniques can be found <a href="https://docs.google.com/document/d/1frk4r1Eq4hnGGOiKWkDiGTK5QQxKbfrvl7Iol7OZ-dc/edit#">here</a>. </p>
<h2 id="input-selection"><a class="header" href="#input-selection">Input Selection</a></h2>
<p>The goal of input selection is to avoid remainder addresses. The remainder output leaves a clue to the user's future spends. There should be a standardised input selection strategy used by the wallet. The steps for input selection are as follows:</p>
<ol>
<li>Try to select an input with an exact match. For example, if a user intends to spend <em>X</em> iotas, the wallet should try to find an address that has <em>X</em> iotas as available balance;</li>
<li>If the previous step fails, try to select a combination of inputs that satisfy the amount leaving no change. For example, consider a scenario where the wallet with account name <em>Foo</em> has three addresses <em>A</em>, <em>B</em> and <em>C</em> with <em>10</em>, <em>20</em> and <em>50</em> IOTA respectively. If a user intends to spend <em>X = 30</em> IOTA, the application should search for an exact match (step no. 1). Clearly, in this case, no address balance matches <em>X</em>, therefore, the wallet should search for a subset of addresses with an accumulated balance of <em>X</em>. In this scenario, <em>A</em> and <em>B</em>;</li>
<li>If both the previous steps fail, the wallet should select a combination of inputs that produce the minimum remainder. </li>
</ol>
<p>A reference implementation of different input selection algorithms for Bitcoin can be found <a href="https://github.com/bitcoinjs/coinselect">here</a>.</p>
<p>Also, the implementation of step no. 2 is quite similar to the <a href="https://en.wikipedia.org/wiki/Subset_sum_problem">subset sum problem</a>. Given a <em>total</em> and a set of non-negative numbers (<em>inputs</em>), we need to determine if there is a subset which adds up to the <em>total</em>.</p>
<h2 id="account-syncing-process"><a class="header" href="#account-syncing-process">Account Syncing Process</a></h2>
<p>The account syncing process should detect all (used) accounts on a seed with their corresponding address and message history. Once, all accounts and histories are detected, the wallet should accumulate total balance. The syncing process should work as follows: </p>
<ol>
<li>Start with the account at index 0, generate <a href="https://blog.blockonomics.co/bitcoin-what-is-this-gap-limit-4f098e52d7e1">gap limit</a> number of addresses, default to 20;</li>
<li>Check for messages and balances on the generated addresses;</li>
<li>If there are no messages and balances of 0 on all addresses, the process for generating addresses and finding messages and balances should be stopped; </li>
<li>If any address has balance or associated messages, generate gap limit number of addresses from the index of the last address with messages or balance; </li>
<li>Steps (1-4) should also be peformed for account at index 1. The general idea is that <em>n + 1</em> accounts should be checked if account <em>n</em> has any messages or balance.</li>
</ol>
<p>Treat accounts like addresses. Only allow 1 latest unused account.</p>
<p><em>Scenario 1</em>: Wallet message and address history stored in Stronghold backup</p>
<ul>
<li>Start syncing from the latest address index stored in the Stronghold backup</li>
<li>Also provide a “Full sync” function to resync from index 0 across all accounts</li>
<li>Also provide “Find more history” function to sync a further 50 addresses</li>
</ul>
<p><em>Scenario 2</em>: User has no backup file</p>
<ul>
<li>Start syncing from account 0 address 0</li>
</ul>
<h2 id="polling"><a class="header" href="#polling">Polling</a></h2>
<p>A background process that automatically performs several tasks periodically should be part of the wallet library. The goal of the background process is to perform the following tasks:</p>
<ul>
<li><em>Sync accounts</em>: The background process should sync all accounts with the network. This should be done using the <a href="libraries/wallet-lib/docs/specs/index.html#syncaccounts">sync_accounts()</a> method. If new messages are detected, a <a href="libraries/wallet-lib/docs/specs/index.html#monitor-for-new-messages">messages</a> event should be used to notify all subscribers. If new balances are detected, a <a href="libraries/wallet-lib/docs/specs/index.html#monitor-for-balance-changes">balances</a> event should be used to notify all subscribers. If new confirmations are detected, a <a href="libraries/wallet-lib/docs/specs/index.html#monitor-for-confirmation-state">confirmations</a> event should be used to notify all subscribers; </li>
</ul>
<p>Note that if there are multiple failed messages, priority should be given to the old ones. </p>
<ul>
<li><em>Reattach</em>: The background process should check if there are any (unconfirmed) messages that require reattachments. The detailed implementation flow for reattachment can be found <a href="libraries/wallet-lib/docs/specs/index.html#reattach">here</a>. </li>
</ul>
<p>The following should be considered for implementation:</p>
<ul>
<li>Invoking a task explicitly that is already being performed through polling should lead to an error. For example, if the polling process is already syncing accounts and a user explicitly calls <a href="libraries/wallet-lib/docs/specs/index.html#sync">sync()</a>, it should throw an error;</li>
<li>Errors during the polling process should be communicated to subscribers via error events.</li>
</ul>
<p>The background process should have a recurring checker that sequentially performs all the above tasks. The implementation should ensure that future tasks can easily be added to the background process. For reference, see Trinity’s <a href="https://github.com/iotaledger/trinity-wallet/blob/develop/src/mobile/src/ui/components/Poll.js">implementation</a> of the poll component. </p>
<h1 id="contribute-to-the-project-1"><a class="header" href="#contribute-to-the-project-1">Contribute to the project</a></h1>
<p><strong>Thanks for thinking about contributing to the project! We have the following ways that you can contribute.</strong></p>
<h2 id="join-the-iota-libraries-initiative-1"><a class="header" href="#join-the-iota-libraries-initiative-1">Join the IOTA Libraries Initiative</a></h2>
<p>The <a href="https://github.com/iota-community/X-Team_IOTA_Libraries">IOTA Libraries Initiative</a> is a collaborative effort to help improve the developer experience.</p>
<ul>
<li>Quality assurance and review</li>
<li>Documentation</li>
<li>Code samples</li>
</ul>
<p>If you'd like to get involved, join the #experience channel on <a href="https://discord.iota.org">Discord</a>.</p>
<h2 id="contribute-to-the-projects-github-repository-1"><a class="header" href="#contribute-to-the-projects-github-repository-1">Contribute to the project's GitHub repository</a></h2>
<p>All the code is open source and hosted on <a href="https://github.com/iotaledger/wallet.rs">GitHub</a> where you can do the following:</p>
<ul>
<li>Report a bug</li>
<li>Suggest a new feature</li>
<li>Contribute to the documentation</li>
</ul>
<h2 id="contribute-to-the-documentation-1"><a class="header" href="#contribute-to-the-documentation-1">Contribute to the documentation</a></h2>
<p>This documentation is also open source and hosted on GitHub.</p>
<p>If you want to contribute new documentation or fix an error, see the <a href="https://github.com/iotaledger/documentation/blob/develop/.github/CONTRIBUTING.md">contribution guidelines</a>.</p>
<h2 id="share-your-knowledge-1"><a class="header" href="#share-your-knowledge-1">Share your knowledge</a></h2>
<p>Helping others is an important part of any open source ecosystem.</p>
<p>By sharing your knowledge with others, you can provide a lot of value to the community and maybe inspire someone else to learn and contribute.</p>
<p>Take a look at what discussions are going on in the #clients-discussion channel on <a href="https://discord.iota.org">Discord</a>.</p>
<p>Thanks :heart:</p>
<h1 id="iota-node-software"><a class="header" href="#iota-node-software">IOTA Node Software</a></h1>
<ul>
<li><a href="node-software/./hornet/docs/welcome.html">HORNET</a></li>
<li><a href="node-software/./bee/docs/welcome.html">Bee</a></li>
</ul>
<h1 id="welcome-to-hornet"><a class="header" href="#welcome-to-hornet">Welcome to HORNET</a></h1>
<blockquote>
<p>The IOTA community node</p>
</blockquote>
<p><img src="node-software/hornet/docs/./assets/HORNET_logo.svg" alt="" /></p>
<p>HORNET is a powerful, community driven IOTA fullnode software written in Go.
It is easy to install and runs on low-end devices like the Raspberry Pi 4.</p>
<hr />
<h2 id="notes"><a class="header" href="#notes">Notes</a></h2>
<ul>
<li><strong>Please open a <a href="https://github.com/gohornet/hornet/issues/new">new issue</a> if you detect an error or crash (or submit a PR if you have already fixed it).</strong></li>
<li><strong>The issue section is not a support section, if you have questions about HORNET please post them in the <code>#hornet</code> channel (<a href="https://discord.iota.org/">official iota discord server</a>).</strong></li>
</ul>
<hr />
<p><em>Table of contents</em></p>
<!--ts-->
<ul>
<li><a href="node-software/hornet/docs/welcome.html#documentation">Documentation</a></li>
<li><a href="node-software/hornet/docs/welcome.html#autopeering">Autopeering</a></li>
<li><a href="node-software/hornet/docs/welcome.html#contributing">Contributing</a></li>
<li><a href="node-software/hornet/docs/welcome.html#installation">Installation</a></li>
<li><a href="node-software/hornet/docs/welcome.html#plugins">Plugins</a></li>
<li><a href="node-software/hornet/docs/welcome.html#docker">Docker</a></li>
</ul>
<!--te-->
<h2 id="documentation"><a class="header" href="#documentation">Documentation</a></h2>
<p>Please have a look into our <a href="https://github.com/gohornet/hornet/wiki">HORNET wiki</a></p>
<h2 id="autopeering"><a class="header" href="#autopeering">Autopeering</a></h2>
<p><strong>WARNING: The autopeering plugin will disclose your public IP address to possibly all nodes and entry points. Please disable the plugin if you do not want this to happen!</strong></p>
<p>The autopeering plugin is still in an early state. We recommend to add 1-2 static peers as well.
If you want to disable autopeering, you can do so by adding it to the <code>disablePlugins</code> in your <code>config.json</code>:</p>
<pre><code class="language-json">&quot;node&quot;: {
    &quot;disablePlugins&quot;: [&quot;Autopeering&quot;],
    &quot;enablePlugins&quot;: []
  },
</code></pre>
<h2 id="contributing"><a class="header" href="#contributing">Contributing</a></h2>
<ul>
<li>See <a href="node-software/hornet/docs//CONTRIBUTING.html">CONTRIBUTING</a></li>
</ul>
<h2 id="installation-4"><a class="header" href="#installation-4">Installation</a></h2>
<h3 id="binary"><a class="header" href="#binary">Binary</a></h3>
<ul>
<li>Download the <a href="https://github.com/gohornet/hornet/releases/latest">latest release</a> for your system (e.g. <code>HORNET-x.x.x_Linux_ARM64.tar.gz</code> for the Raspberry Pi 4)</li>
<li>Extract the files in a folder of your choice</li>
<li>Add neighbors to the <code>peering.json</code> file (optional)</li>
<li>Run HORNET: <code>./hornet -c config</code></li>
</ul>
<h3 id="apt"><a class="header" href="#apt">APT</a></h3>
<pre><code>wget -qO - https://ppa.hornet.zone/pubkey.txt | sudo apt-key add -
sudo sh -c 'echo &quot;deb http://ppa.hornet.zone stable main&quot; &gt;&gt; /etc/apt/sources.list.d/hornet.list'
sudo apt update
sudo apt install hornet
</code></pre>
<p><a href="https://github.com/gohornet/hornet/wiki/Tutorials%3A-Linux%3A-Install-HORNET">Tutorial: Install HORNET with APT</a></p>
<hr />
<h2 id="plugins"><a class="header" href="#plugins">Plugins</a></h2>
<p>HORNETs functionality is extended by plugins. Available plugins are listed <a href="https://github.com/gohornet/hornet/wiki/Plugins">here</a>.</p>
<hr />
<h2 id="docker"><a class="header" href="#docker">Docker</a></h2>
<p><img src="https://img.shields.io/docker/pulls/gohornet/hornet?style=for-the-badge" alt="Docker Pulls" /></p>
<p>Pull HORNET from <a href="https://hub.docker.com/r/gohornet/hornet">Docker Hub</a></p>
<p><strong>Build a Docker image</strong></p>
<ul>
<li>See <a href="node-software/hornet/docs/docker/README.html">Docker</a></li>
</ul>
<h1 id="tutorials"><a class="header" href="#tutorials">Tutorials</a></h1>
<ul>
<li><a href="node-software/hornet/docs/tutorials/./1.0/index.html">IOTA 1.0</a>
<ul>
<li><a href="node-software/hornet/docs/tutorials/./1.0/setup.html">Setup HORNET</a></li>
<li><a href="node-software/hornet/docs/tutorials/./1.0/private_tangle.html">Run a private Tangle</a></li>
<li><a href="node-software/hornet/docs/tutorials/./1.0/entry_node.html">Hosting An Entry Node</a></li>
</ul>
</li>
<li><a href="node-software/hornet/docs/tutorials/./1.5/index.html">Chrysalis IOTA 1.5</a>
<ul>
<li><a href="node-software/hornet/docs/tutorials/./1.5/build.html">Build HORNET</a></li>
<li><a href="node-software/hornet/docs/tutorials/./1.5/run.html">Run HORNET</a></li>
<li><a href="node-software/hornet/docs/tutorials/./1.5/private_tangle.html">Run a private tangle</a></li>
</ul>
</li>
</ul>
<h2 id="community-tutorials"><a class="header" href="#community-tutorials">Community Tutorials</a></h2>
<ul>
<li><a href="node-software/hornet/docs/tutorials/./1.5/index.html">Chrysalis IOTA 1.5</a>
<ul>
<li><a href="https://github.com/svenger87/hornet-alphanet-tutorial">hornet-testnet-tutorial by svenger87</a></li>
<li><a href="https://tanglebay.com/article/3-hornet-node-chrysalis/">(DE) Hornet Node (Chrysalis) by Tanglebay.com</a></li>
</ul>
</li>
</ul>
<h1 id="iota-10"><a class="header" href="#iota-10">IOTA 1.0</a></h1>
<p>The current network is IOTA 1.0 and will be migrated to Chrysalis (IOTA 1.5) in Q1 2021.</p>
<p>We recommend you to follow the <a href="node-software/hornet/docs/tutorials/1.0/../1.5/index.html">Tutorials for Chrysalis</a>.</p>
<h1 id="setup-a-hornet-node"><a class="header" href="#setup-a-hornet-node">Setup a HORNET Node</a></h1>
<p>This is a small tutorial on how to install HORNET using our apt repository or using the RPM package.</p>
<h3 id="preparations"><a class="header" href="#preparations">Preparations</a></h3>
<ul>
<li>Setup an e.g. Ubuntu (&gt;= 16.04) or CentOS (&gt;= 7) server with at least 1GB RAM</li>
<li>Optional but recommended: Add a ssh key, activate a firewall ...</li>
<li>Update your system (Ubuntu) with:<br>
<pre><code class="language-bash">sudo apt update
sudo apt upgrade
</code></pre>
</li>
<li>Allow basic ports in your firewall settings (and your router if you run HORNET behind one).<br>
The following ports are important for a flawless node operation.<br>
Please note that these ports can be customized in your <code>config.json</code>:<br>
<pre><code>14626 UDP - Autopeering port
15600 TCP - Gossip (neighbors) port
14265 TCP - API port (optional if you don't want to access your node's API from external)
</code></pre>
Please also have a look at the <a href="https://github.com/gohornet/hornet/wiki/Configuration">configuration documentation</a></li>
</ul>
<h3 id="installation-ubuntu"><a class="header" href="#installation-ubuntu">Installation (Ubuntu)</a></h3>
<ul>
<li>
<p>Import the key that is used to sign the release</p>
<pre><code class="language-bash">wget -qO - https://ppa.hornet.zone/pubkey.txt | sudo apt-key add -
</code></pre>
</li>
<li>
<p>Add the HORNET repository to your APT sources<br>
<strong>Stable:</strong></p>
<pre><code class="language-bash">sudo sh -c 'echo &quot;deb http://ppa.hornet.zone stable main&quot; &gt;&gt; /etc/apt/sources.list.d/hornet.list'
</code></pre>
<p><strong>Testing (pre-releases):</strong><br>
:warning: <strong>Do not use in production, bugs are likely</strong> :warning:</p>
<pre><code class="language-bash">sudo sh -c 'echo &quot;deb http://ppa.hornet.zone testing main&quot; &gt;&gt; /etc/apt/sources.list.d/hornet.list'
</code></pre>
<p><strong>Alpha (pre-releases):</strong><br>
:warning: <strong>Only for Comnet, do not use in production, bugs are likely</strong> :warning:</p>
<p>Follow the updates in the #comnet channel if you want to run this version!</p>
<pre><code class="language-bash">sudo sh -c 'echo &quot;deb http://ppa.hornet.zone alpha main&quot; &gt;&gt; /etc/apt/sources.list.d/hornet.list'
</code></pre>
</li>
<li>
<p>Install HORNET:</p>
<pre><code class="language-bash">sudo apt update
sudo apt install hornet
</code></pre>
</li>
</ul>
<h3 id="installation-centos"><a class="header" href="#installation-centos">Installation (CentOS)</a></h3>
<ul>
<li>
<p>Open <a href="https://github.com/gohornet/hornet/releases/latest">HORNET latest release page</a></p>
</li>
<li>
<p>Copy the link to the RPM package (e.g. <code>hornet-0.4.0-x86_64.rpm</code>)</p>
</li>
<li>
<p>Consider validating the RPM package checksum against the corresponding one from the <code>checksums.txt</code></p>
</li>
<li>
<p>Install the HORNET RPM package from the releases page, e.g. version v0.4.0:</p>
<pre><code class="language-bash">sudo yum install https://github.com/gohornet/hornet/releases/download/v0.4.0/hornet-0.4.0-x86_64.rpm
</code></pre>
<p>or from a file:</p>
<pre><code class="language-bash">sudo yum install hornet-0.4.0-x86_64.rpm
</code></pre>
</li>
<li>
<p>Note: Checksum can be verified if the RPM package and checksum file are present in the same directory, should return a value and the file name:</p>
<pre><code class="language-bash">grep &quot;^$(sha256sum hornet-0.4.0-x86_64.rpm)$&quot; checksums.txt
</code></pre>
</li>
</ul>
<h3 id="setup-1"><a class="header" href="#setup-1">Setup</a></h3>
<ul>
<li>Adapt the settings to your needs (e.g. <a href="node-software/hornet/docs/tutorials/1.0/setup.html#comnet-community-network-setup">setup for comnet</a>)</li>
<li>Enable the HORNET service:
<pre><code class="language-bash">sudo systemctl enable hornet.service
</code></pre>
</li>
<li>Start HORNET:
<pre><code class="language-bash">sudo service hornet start
</code></pre>
</li>
<li>Watch the logs with:
<pre><code class="language-bash">sudo journalctl -u hornet -f
</code></pre>
</li>
<li>Done</li>
</ul>
<h3 id="operation"><a class="header" href="#operation">Operation</a></h3>
<ul>
<li>Stop HORNET
<ul>
<li><code>sudo service hornet stop</code></li>
</ul>
</li>
<li>Start HORNET
<ul>
<li><code>sudo service hornet start</code></li>
</ul>
</li>
<li>Restart HORNET
<ul>
<li><code>sudo service hornet restart</code></li>
</ul>
</li>
<li>Check HORNET status
<ul>
<li><code>sudo service hornet status</code></li>
</ul>
</li>
<li>Watch the logs
<ul>
<li><code>sudo journalctl -u hornet -f</code></li>
</ul>
</li>
<li>Remove the mainnetdb (e.g. in case of a failure):
<ol>
<li>Stop HORNET</li>
<li><code>sudo rm -r /var/lib/hornet/mainnetdb</code></li>
<li>Start HORNET</li>
</ol>
</li>
</ul>
<h3 id="configuration"><a class="header" href="#configuration">Configuration</a></h3>
<p>You can find HORNET's configuration files in:<br>
<code>/var/lib/hornet/</code><br></p>
<p>Additional cli arguments can be set in:<br>
<code>/etc/default/hornet</code><br><br></p>
<p>If you have modified the <code>config.json</code>, you have to restart HORNET:<br>
<code>sudo service hornet stop &amp;&amp; sudo service hornet start</code><br>
or<br>
<code>sudo service hornet restart</code></p>
<h3 id="comnet-community-network-setup"><a class="header" href="#comnet-community-network-setup">Comnet (community network) setup</a></h3>
<ol>
<li>Edit <code>/etc/default/hornet</code>:
<pre><code class="language-bash">sudo nano /etc/default/hornet
</code></pre>
<code>/etc/default/hornet</code>:
<pre><code># Add cli arguments to hornet, e.g.:
# (For the full list of cli options run 'hornet -h')
OPTIONS=&quot;--config config_comnet&quot;
</code></pre>
</li>
<li>Start HORNET</li>
</ol>
<p>This is a small tutorial on how to run your own private Tangle.</p>
<p><strong>Note: This tutorial assumes that you are using Ubuntu. The setup process may differ on other OS.</strong></p>
<h3 id="preparations-1"><a class="header" href="#preparations-1">Preparations</a></h3>
<ul>
<li>Set up your server and install HORNET (<a href="node-software/hornet/docs/tutorials/1.0/./setup.html">APT install</a>) - <strong>Do not start it yet</strong></li>
<li>Generate a secure Seed. Even if it's a private Tangle without real value you should use a random Seed.</li>
</ul>
<h3 id="configuration-1"><a class="header" href="#configuration-1">Configuration</a></h3>
<p>Adapt the configuration to your needs<br>
<br></p>
<p><strong>Enable the coordinator plugin:</strong></p>
<pre><code class="language-json">&quot;node&quot;:{
    &quot;alias&quot;: &quot;Coordinator&quot;,
    &quot;showAliasInGetNodeInfo&quot;: false,
    &quot;disablePlugins&quot;: [],
    &quot;enablePlugins&quot;: [&quot;Coordinator&quot;]
},
</code></pre>
<p><strong>Coordinator settings:</strong>
<br>
<a href="https://github.com/gohornet/hornet/wiki/Configuration#Coordinator">Coordinator configuration</a>
<br><br>
Some hints:</p>
<ul>
<li>Set a low MWM. If you are the only one using this Tangle, you need no (high) spam protection</li>
<li>The higher the merkle tree depth, the longer it will take to compute the merkle tree. Calculate how many milestones you really need:<br>Number of possible milestones: 2<sup>merkleTreeDepth</sup></li>
</ul>
<br>
Example:
<pre><code class="language-json">  &quot;coordinator&quot;: {
    &quot;address&quot;: &quot;&quot;,
    &quot;securityLevel&quot;: 2,
    &quot;merkleTreeDepth&quot;: 18,
    &quot;mwm&quot;: 5,
    &quot;stateFilePath&quot;: &quot;coordinator.state&quot;,
    &quot;merkleTreeFilePath&quot;: &quot;coordinator.tree&quot;,
    &quot;intervalSeconds&quot;: 60,
    &quot;checkpoints&quot;: {
      &quot;maxTrackedTails&quot;: 10000
    }
  },
</code></pre>
<p><strong>Global snapshot settings:</strong>
<br>
<a href="https://github.com/gohornet/hornet/wiki/Configuration#Snapshots">Snapshot configuration docu</a>
<br><br></p>
<pre><code class="language-json">  &quot;snapshots&quot;: {
    &quot;loadType&quot;: &quot;global&quot;,
    &quot;global&quot;: {
      &quot;path&quot;: &quot;snapshot.csv&quot;,
      &quot;spentAddressesPaths&quot;: [],
      &quot;index&quot;: 0
    }
  },
</code></pre>
<h3 id="generate-the-merkle-tree"><a class="header" href="#generate-the-merkle-tree">Generate the merkle tree</a></h3>
<p><strong>Note: This may take some time (depending on the merkle tree depth and your hardware)</strong></p>
<ol>
<li>
<pre><code class="language-bash">cd /var/lib/hornet
sudo -u hornet COO_SEED=&quot;YOUR9COO9SEED9HERE...&quot; hornet tool merkle
</code></pre>
<p>The output will look like this:</p>
<pre><code>calculating 1024 addresses...
calculated 1024/1024 (100.00%) addresses (took 1s).
calculating nodes for layer 9
calculating nodes for layer 8
calculating nodes for layer 7
calculating nodes for layer 6
calculating nodes for layer 5
calculating nodes for layer 4
calculating nodes for layer 3
calculating nodes for layer 2
calculating nodes for layer 1
calculating nodes for layer 0
merkle tree root: BHKJSBMRSZLFMXJFYE9NHYTZCRAZQHLZTIBTKVNZLVWAXKESPOANYARWQYOYYHONDJYEAMMSOQEGGEPKB
successfully created merkle tree (took 1s).
</code></pre>
</li>
<li>
<p>Add the <code>merkle tree root</code> address to your config<br><br>
Example:</p>
</li>
</ol>
<pre><code class="language-json">  &quot;coordinator&quot;: {
    &quot;address&quot;: &quot;BHKJSBMRSZLFMXJFYE9NHYTZCRAZQHLZTIBTKVNZLVWAXKESPOANYARWQYOYYHONDJYEAMMSOQEGGEPKB&quot;,
    &quot;securityLevel&quot;: 2,
    &quot;merkleTreeDepth&quot;: 18,
    &quot;mwm&quot;: 5,
    &quot;stateFilePath&quot;: &quot;coordinator.state&quot;,
    &quot;merkleTreeFilePath&quot;: &quot;coordinator.tree&quot;,
    &quot;intervalSeconds&quot;: 60,
    &quot;checkpoints&quot;: {
      &quot;maxTrackedTails&quot;: 10000
    }
  },
</code></pre>
<h3 id="initial-iota-distribution"><a class="header" href="#initial-iota-distribution">Initial IOTA Distribution</a></h3>
<p>If you set up a new tangle you initially need to distribute the IOTA to at least one address.</p>
<ol>
<li>
<p>Generate a secure (random) Seed and generate an address with this Seed</p>
</li>
<li>
<p>Backup this Seed</p>
</li>
<li>
<p>Create a new file called <code>snapshot.csv</code> and add this contend:</p>
<pre><code>YOUR9GENERATED9ADDRESS9FROM9YOUR9SEED;2779530283277761
</code></pre>
</li>
<li>
<p>Save this file to the HORNET dir (<code>/var/lib/hornet</code>)</p>
</li>
</ol>
<h3 id="bootstrap-the-coordinator"><a class="header" href="#bootstrap-the-coordinator">Bootstrap the Coordinator</a></h3>
<ol>
<li>Change to the HORNET dir:
<pre><code>cd /var/lib/hornet
</code></pre>
</li>
<li>Run HORNET the first time:
<pre><code>sudo -u hornet COO_SEED=&quot;YOUR9COO9SEED9HERE...&quot; hornet --cooBootstrap
</code></pre>
</li>
<li>Once the bootstrap process is done you can stop HORNET (CTRL+C) and let it run as a service:
<pre><code>sudo sh -c 'echo &quot;COO_SEED=YOUR9COO9SEED9HERE...&quot; &gt;&gt; /etc/default/hornet'
sudo systemctl enable --now hornet.service
</code></pre>
</li>
<li>Congrats, your HORNET Coordinator is up and running!</li>
</ol>
<h3 id="add-additional-hornet-nodes-to-your-private-tangle"><a class="header" href="#add-additional-hornet-nodes-to-your-private-tangle">Add additional HORNET nodes to your private tangle</a></h3>
<ol>
<li>Install an additional HORNET</li>
<li>Copy over the config.json from your HORNET Coordinator (<strong>make sure you removed <code>Coordinator</code> from the <code>&quot;enablePlugins&quot;</code></strong>)</li>
<li>Copy over the <code>snapshot.csv</code> from your HORNET Coordinator</li>
<li>Start HORNET</li>
</ol>
<p>Note: Once your HORNET Coordinator node created the first local snapshot, you can use this local snapshot to add new HORNET nodes to your private tangle.</p>
<h3 id="use-a-new-merkle-tree"><a class="header" href="#use-a-new-merkle-tree">Use a new merkle tree</a></h3>
<p>In case you run out of new milestones, you can replace the old merkle tree with a new one.</p>
<ol>
<li>Stop the HORNET Coordinator</li>
<li>Generate a new merkle tree</li>
<li>Replace the <code>coordinator.address</code> in your <code>config.json</code> with the new <code>merkle tree root</code> address</li>
<li>Migrate your HORNET Coordinator to this merkle tree:
<pre><code>cd /var/lib/hornet
sudo rm coordinator.state
sudo -u hornet hornet --overwriteCooAddress --cooBootstrap --cooStartIndex xxxx
</code></pre>
Note: Replace <code>xxxx</code> with the start index (e.g. last issued milestone index + 1)</li>
</ol>
<p>This is a tutorial on how to host an autopeering entry node.</p>
<p><strong>Note: This tutorial assumes that you are using Ubuntu and our <a href="node-software/hornet/docs/tutorials/1.0/./setup.html">APT install</a>. The setup process may differ on other OS or install methods.</strong></p>
<h3 id="preparations-2"><a class="header" href="#preparations-2">Preparations</a></h3>
<ul>
<li>Setup and secure your server (Firewall, SSH-Key,...)</li>
<li>Install HORNET (don't start it yet!)</li>
<li>It is recommended to use a domain name for your entry node (you'll need a proxy setup, e.g. nginx). However an IP address will work too.</li>
</ul>
<h3 id="configuration-2"><a class="header" href="#configuration-2">Configuration</a></h3>
<ul>
<li>Randomly generate a Base58 encoded 256-bit string (seed):
<ul>
<li>Option 1: Generate your seed with a true random number generator (recommended for production usage).</li>
<li>Option 2: Use the build in HORNET seed generator: <code>hornet tool seedgen</code>.</li>
</ul>
</li>
<li>Switch on the autopeering mode in your <code>config.json</code>:<br>
<code>/var/lib/hornet/config.json</code>
<pre><code class="language-json">...
&quot;network&quot;: {
    ...
    &quot;autopeering&quot;: {
        &quot;bindAddress&quot;: &quot;0.0.0.0:14626&quot;,
        &quot;runAsEntryNode&quot;: true,
        &quot;seed&quot;: &quot;7xFNTP5Fc3wnD78LarNTrvRoKiLESA9qecn3eR5HSVBj&quot;
    }
}
...
</code></pre>
</li>
<li>Start HORNET with <code>sudo service start hornet &amp;&amp; sudo journalctl -n hornet -f</code>. HORNET will start in an autopeering entry node only mode. Other functions are disabled in this mode.</li>
<li>In the HORNET logs, you will see something like this:
<pre><code>INFO    Autopeering     Autopeering started: ID=a0ba6bf62d6fe911 Address=0.0.0.0:14626/udp PublicKey=9CT42uZC6GetwoT2Jz7Lc5t6LGvXphp9gLvEsdoXEizV
</code></pre>
Note down your PublicKey.<br>
<strong>Your entry node address is <code>&lt;PublicKey&gt;@&lt;your-domain.tld&gt;:&lt;autopeering-port&gt;</code></strong></li>
<li>Add your entry node address to the <code>network.autopeering.entryNodes</code> in your nodes <code>config.json</code></li>
<li>Done, your nodes should now autopeer with the help of your entry node.</li>
</ul>
<h3 id="monitoring"><a class="header" href="#monitoring">Monitoring</a></h3>
<p>You can monitor your entry node with the <code>healthz</code> API route.<br>
<code>&lt;your-domain.tld&gt;:&lt;api-port&gt;/healthz</code><br>
It will return an http status code 200 if everything is OK.</p>
<h3 id="hosting-a-public-entry-node"><a class="header" href="#hosting-a-public-entry-node">Hosting a public entry node</a></h3>
<p>If you want to host an entry node for a public network such as the mainnet, there are a few things to consider:</p>
<ul>
<li>You should be experienced in working with servers and server security.</li>
<li>A domain name is a must have.</li>
<li>Your domain name should have both, an A (IPv4) and AAAA (IPv6) record.</li>
<li>Your entry node gets monitored (e.g. with the <code>healthz</code> API and an uptime monitor).</li>
<li>You are able to update your entry node shortly after a new HORNET version gets released.</li>
</ul>
<p>If these points are not a problem for you, feel free to contact us (e.g. in the <a href="https://discord.iota.org/">official IOTA Discord <code>#hornet</code> channel</a>) to have your entry node added to the official entry nodes!</p>
<h1 id="chrysalis-iota-15"><a class="header" href="#chrysalis-iota-15">Chrysalis IOTA 1.5</a></h1>
<p>Chrysalis is currently in a test stage. The release is planned for Q1 2021.</p>
<p>You can read more about Chrysalis, please visit the <a href="https://chrysalis.iota.org/">Chrysalis Update Page</a> and the <a href="https://chrysalis.docs.iota.org/">Chrysalis Documentation</a>.</p>
<p>Here we cover the following steps:</p>
<ul>
<li><a href="node-software/hornet/docs/tutorials/1.5/./build.html">Build HORNET</a></li>
<li><a href="node-software/hornet/docs/tutorials/1.5/./run.html">Run HORNET</a></li>
<li><a href="node-software/hornet/docs/tutorials/1.5/./private_tangle.html">Run a private tangle</a></li>
</ul>
<p>This is a small tutorial on how to build HORNET.</p>
<p><strong>Note: This tutorial assumes that you are using Ubuntu. The setup and build process may differ on other OS.</strong></p>
<h3 id="preparations-3"><a class="header" href="#preparations-3">Preparations</a></h3>
<ul>
<li>Install go1.16: See <a href="https://golang.org/doc/install">golang.org</a> for more information.
<pre><code class="language-bash">  wget https://golang.org/dl/go1.16.linux-amd64.tar.gz
  tar -C /usr/local -xzf go1.16.linux-amd64.tar.gz
</code></pre>
</li>
<li>Put this line to modify PATH in ~/.profile
<pre><code class="language-bash">  export PATH=$PATH:/usr/local/go/bin
</code></pre>
</li>
<li>Check if Go is installed correctly:
<pre><code class="language-bash">go version
</code></pre>
The output should be something like this:
<pre><code class="language-bash">go version go1.16 linux/amd64
</code></pre>
</li>
<li>Install git (if not already done):
<pre><code class="language-bash">sudo apt install git
</code></pre>
</li>
</ul>
<h3 id="build-hornet"><a class="header" href="#build-hornet">Build HORNET</a></h3>
<ul>
<li>
<p>Clone HORNET with:</p>
<pre><code class="language-bash">git clone https://github.com/gohornet/hornet.git
</code></pre>
</li>
<li>
<p>Change to the cloned <code>hornet</code> directory</p>
<pre><code class="language-bash">cd hornet
</code></pre>
</li>
<li>
<p>Checkout the develop branch to build HORNET for Chrysalis (IOTA 1.5) (optional if you want to build the latest HORNET release for the current Network (IOTA 1.0), please use the <code>master</code> branch):</p>
<pre><code class="language-bash">git checkout develop
</code></pre>
</li>
<li>
<p>Build HORNET</p>
<pre><code class="language-bash">go build
</code></pre>
</li>
<li>
<p>Done, now you should be able to start HORNET.
Test, if the build was successful:</p>
<pre><code class="language-bash">./hornet --version
</code></pre>
<p>If HORNET prints out its version, the build was successful.</p>
</li>
</ul>
<p>This is a small tutorial on how to run a HORNET node.</p>
<p><strong>Note: This tutorial assumes that you have prebuilt HORNET. Learn <a href="node-software/hornet/docs/tutorials/1.5/./build.html">how to build HORNET here</a></strong></p>
<p>The HORNET binaries for Chrysalis are not released yet.</p>
<p>In the meantime, check the <a href="node-software/hornet/docs/tutorials/1.5/../index.html#community-tutorials">Community Tutorials</a> for running a Hornet node.</p>
<pre><code class="language-bash">
              ██╗  ██╗ ██████╗ ██████╗ ███╗   ██╗███████╗████████╗
              ██║  ██║██╔═══██╗██╔══██╗████╗  ██║██╔════╝╚══██╔══╝
              ███████║██║   ██║██████╔╝██╔██╗ ██║█████╗     ██║
              ██╔══██║██║   ██║██╔══██╗██║╚██╗██║██╔══╝     ██║
              ██║  ██║╚██████╔╝██║  ██║██║ ╚████║███████╗   ██║
              ╚═╝  ╚═╝ ╚═════╝ ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝   ╚═╝
</code></pre>
<p>This is a small tutorial on how to run your own private <a href="https://chrysalis.iota.org/">Chrysalis</a> tangle.</p>
<p>We will need to set up <a href="https://docs.iota.org/docs/getting-started/1.1/the-tangle/the-coordinator">a coordinator</a> and at least one additional <a href="https://docs.iota.org/docs/getting-started/1.1/running-nodes/overview">node</a> and distribute some tokens to an address that we can manage using a wallet. We will do this by running some scripts from the <em>alphanet</em> folder that you will find in the HORNET respository.</p>
<h3 id="preparations-4"><a class="header" href="#preparations-4">Preparations</a></h3>
<ul>
<li><a href="node-software/hornet/docs/tutorials/1.5/./build.html">Build HORNET</a></li>
<li>Get a wallet built for Chrysalis (for example <a href="https://github.com/iotaledger/cli-wallet">the cli-wallet</a>)</li>
</ul>
<h3 id="configuration-3"><a class="header" href="#configuration-3">Configuration</a></h3>
<p>The scripts in the <em>alphanet</em> folder of the HORNET repository, which we will use to run the coordinator and the nodes, are preconfigured. By default they will distribute the tokens to the following address:</p>
<pre><code>atoi1qpszqzadsym6wpppd6z037dvlejmjuke7s24hm95s9fg9vpua7vluehe53e
</code></pre>
<p>If you want to use an existing address, search for your address in <a href="https://explorer.iota.org/chrysalis">the Chrysalis explorer</a> and look for the corresponding ED25519 address. Find the <em>create_snapshot_alphanet</em> script in the <em>alphanet</em> directory and change the following line to use your ED25519 address:</p>
<pre><code class="language-bash">...
go run &quot;..\main.go&quot; tool snapgen alphanet1 [ADDRESS] 1000000000 &quot;snapshots\alphanet1\full_export.bin&quot;
...
</code></pre>
<h3 id="start-the-coordinator"><a class="header" href="#start-the-coordinator">Start the coordinator</a></h3>
<p>In the HORNET repository, change to the <em>alphanet</em> directory and run the <em>run_coo_bootstrap</em> script. This will create all files needed to run the network and distribute the tokens to the address we configured. It will also start the coordinator.</p>
<p>In subsequent starts we can use the <em>run_coo</em> script, to skip the bootstrap step.</p>
<h3 id="start-additional-nodes"><a class="header" href="#start-additional-nodes">Start additional nodes</a></h3>
<p>To start additional nodes we simply use the additional <em>run</em> scripts provided in the <em>alphanet</em> folder. We can run them on the same device, as they are preconfigured to listen on different ports.</p>
<p>Congratulations, you are now running a private network! To monitor your coordinator, you can find the dashboard at <a href="http://localhost:8081">http://localhost:8081</a>.</p>
<h3 id="use-a-wallet-to-manage-the-tokens"><a class="header" href="#use-a-wallet-to-manage-the-tokens">Use a wallet to manage the tokens</a></h3>
<p>To easily access the tokens on the network, we need to take one more step. If you used the default configuration, use the following mnemonic to set up a wallet:</p>
<pre><code>giant dynamic museum toddler six deny defense ostrich bomb access mercy blood explain muscle shoot shallow glad autumn author calm heavy hawk abuse rally
</code></pre>
<p>Now connect your wallet to one of the nodes that are running and you should be able to find the tokens distributed to your wallet.</p>
<p>Using <a href="https://github.com/iotaledger/cli-wallet">the cli-wallet</a>, the commands would be:</p>
<pre><code class="language-bash">&gt; wallet mnemonic &quot;giant dynamic museum toddler six deny defense ostrich bomb access mercy blood explain muscle shoot shallow glad autumn author calm heavy hawk abuse rally&quot;
&gt; wallet new --node &quot;http://localhost:14266&quot; --alias EXAMPLE
</code></pre>
<p>You are now all set to start using your own private tangle!</p>
<h1 id="configuration-4"><a class="header" href="#configuration-4">Configuration</a></h1>
<ul>
<li><a href="node-software/hornet/docs/configuration/./config.html">config.json</a></li>
<li><a href="node-software/hornet/docs/configuration/./peering.html">peering.json</a></li>
</ul>
<h1 id="configjson"><a class="header" href="#configjson">config.json</a></h1>
<p>Hornet uses the JSON standard as config file. If you are unsure about some syntax have a look at the official specs <a href="https://www.json.org">here</a>.
The default config file is <code>config.json</code>. You can change the path or name of the config file by using the <code>-c</code> or <code>--config</code> flag.
For Example: <code>hornet -c config_example.json</code>.<br />
You can always get the most up-to-date description of the config parameters by running <code>hornet -h --full</code>.</p>
<h2 id="table-of-content"><a class="header" href="#table-of-content">Table of content</a></h2>
<ul>
<li><a href="node-software/hornet/docs/configuration/config.html#1-rest-api">1. REST API</a>
<ul>
<li><a href="node-software/hornet/docs/configuration/config.html#basic-auth">Basic auth</a></li>
<li><a href="node-software/hornet/docs/configuration/config.html#limits">Limits</a></li>
</ul>
</li>
<li><a href="node-software/hornet/docs/configuration/config.html#2-dashboard">2. Dashboard</a>
<ul>
<li><a href="node-software/hornet/docs/configuration/config.html#auth">Auth</a></li>
</ul>
</li>
<li><a href="node-software/hornet/docs/configuration/config.html#3-db">3. DB</a></li>
<li><a href="node-software/hornet/docs/configuration/config.html#4-snapshots">4. Snapshots</a>
<ul>
<li><a href="node-software/hornet/docs/configuration/config.html#downloadurls">DownloadURLs</a></li>
</ul>
</li>
<li><a href="node-software/hornet/docs/configuration/config.html#5-pruning">5. Pruning</a></li>
<li><a href="node-software/hornet/docs/configuration/config.html#6-protocol">6. Protocol</a>
<ul>
<li><a href="node-software/hornet/docs/configuration/config.html#publickeyranges">PublicKeyRanges</a></li>
</ul>
</li>
<li><a href="node-software/hornet/docs/configuration/config.html#7-requests">7. Requests</a></li>
<li><a href="node-software/hornet/docs/configuration/config.html#8-coordinator">8. Coordinator</a>
<ul>
<li><a href="node-software/hornet/docs/configuration/config.html#checkpoints">Checkpoints</a></li>
<li><a href="node-software/hornet/docs/configuration/config.html#quorum">Quorum</a>
<ul>
<li><a href="node-software/hornet/docs/configuration/config.html#groups">Groups</a>
<ul>
<li><a href="node-software/hornet/docs/configuration/config.html#-group-name-">{GROUP_NAME}</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="node-software/hornet/docs/configuration/config.html#signing">Signing</a></li>
<li><a href="node-software/hornet/docs/configuration/config.html#tipsel">Tipsel</a></li>
</ul>
</li>
<li><a href="node-software/hornet/docs/configuration/config.html#9-tipsel">9. Tipsel</a>
<ul>
<li><a href="node-software/hornet/docs/configuration/config.html#nonlazy">NonLazy</a></li>
<li><a href="node-software/hornet/docs/configuration/config.html#semilazy">SemiLazy</a></li>
</ul>
</li>
<li><a href="node-software/hornet/docs/configuration/config.html#10-node">10. Node</a></li>
<li><a href="node-software/hornet/docs/configuration/config.html#11-p2p">11. P2P</a>
<ul>
<li><a href="node-software/hornet/docs/configuration/config.html#connectionmanager">ConnectionManager</a></li>
<li><a href="node-software/hornet/docs/configuration/config.html#peerstore">PeerStore</a></li>
</ul>
</li>
<li><a href="node-software/hornet/docs/configuration/config.html#13-logger">13. Logger</a></li>
<li><a href="node-software/hornet/docs/configuration/config.html#14-warpsync">14. Warpsync</a></li>
<li><a href="node-software/hornet/docs/configuration/config.html#15-spammer">15. Spammer</a></li>
<li><a href="node-software/hornet/docs/configuration/config.html#16-mqtt">16. MQTT</a></li>
<li><a href="node-software/hornet/docs/configuration/config.html#17-profiling">17. Profiling</a></li>
<li><a href="node-software/hornet/docs/configuration/config.html#18-prometheus">18. Prometheus</a>
<ul>
<li><a href="node-software/hornet/docs/configuration/config.html#fileservicediscovery">FileServiceDiscovery</a></li>
</ul>
</li>
<li><a href="node-software/hornet/docs/configuration/config.html#19-gossip">19. Gossip</a></li>
<li><a href="node-software/hornet/docs/configuration/config.html#20-debug">20. Debug</a></li>
<li><a href="node-software/hornet/docs/configuration/config.html#21-legacy">21. Legacy</a></li>
<li><a href="node-software/hornet/docs/configuration/config.html#211-migrator">21.1 Migrator</a></li>
<li><a href="node-software/hornet/docs/configuration/config.html#212-receipts">21.2 Receipts</a>
<ul>
<li><a href="node-software/hornet/docs/configuration/config.html#backup">Backup</a></li>
<li><a href="node-software/hornet/docs/configuration/config.html#validator">Validator</a>
<ul>
<li><a href="node-software/hornet/docs/configuration/config.html#api">Api</a></li>
<li><a href="node-software/hornet/docs/configuration/config.html#coordinator">Coordinator</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<hr />
<h2 id="1-rest-api"><a class="header" href="#1-rest-api">1. REST API</a></h2>
<table><thead><tr><th align="left">Name</th><th align="left">Description</th><th align="left">Type</th></tr></thead><tbody>
<tr><td align="left"><a href="node-software/hornet/docs/configuration/config.html#basic-auth">basicAuth</a></td><td align="left">config for basic auth</td><td align="left">object</td></tr>
<tr><td align="left">permittedRoutes</td><td align="left">the allowed HTTP REST routes which can be called from non whitelisted addresses</td><td align="left">array of strings</td></tr>
<tr><td align="left">whitelistedAddresses</td><td align="left">the whitelist of addresses which are allowed to access the REST API</td><td align="left">array of strings</td></tr>
<tr><td align="left">bindAddress</td><td align="left">the bind address on which the REST API listens on</td><td align="left">string</td></tr>
<tr><td align="left">powEnabled</td><td align="left">whether the node does PoW if messages are received via API</td><td align="left">bool</td></tr>
<tr><td align="left">powWorkerCount</td><td align="left">the amount of workers used for calculating PoW when issuing messages via API</td><td align="left">integer</td></tr>
<tr><td align="left"><a href="node-software/hornet/docs/configuration/config.html#limits">limits</a></td><td align="left">config for api limits</td><td align="left">object</td></tr>
<tr><td align="left">excludeHealthCheckFromAuth</td><td align="left">whether to allow the health check route anyways</td><td align="left">bool</td></tr>
</tbody></table>
<h3 id="basic-auth"><a class="header" href="#basic-auth">Basic auth</a></h3>
<table><thead><tr><th align="left">Name</th><th align="left">Description</th><th align="left">Type</th></tr></thead><tbody>
<tr><td align="left">enabled</td><td align="left">whether to use HTTP basic auth for the REST API</td><td align="left">bool</td></tr>
<tr><td align="left">userName</td><td align="left">the username of the HTTP basic auth</td><td align="left">string</td></tr>
<tr><td align="left">passwordHash</td><td align="left">the HTTP basic auth password+salt as a scrypt hash</td><td align="left">string</td></tr>
<tr><td align="left">passwordSalt</td><td align="left">the HTTP basic auth salt used for hashing the password</td><td align="left">string</td></tr>
</tbody></table>
<h3 id="limits"><a class="header" href="#limits">Limits</a></h3>
<table><thead><tr><th align="left">Name</th><th align="left">Description</th><th align="left">Type</th></tr></thead><tbody>
<tr><td align="left">bodyLength</td><td align="left">the maximum number of characters that the body of an API call may contain</td><td align="left">string</td></tr>
<tr><td align="left">maxResults</td><td align="left">the maximum number of results that may be returned by an endpoint</td><td align="left">integer</td></tr>
</tbody></table>
<p>Example:</p>
<pre><code class="language-json">  &quot;restAPI&quot;: {
    &quot;basicAuth&quot;: {
      &quot;enabled&quot;: false,
      &quot;userName&quot;: &quot;admin&quot;,
      &quot;passwordHash&quot;: &quot;0000000000000000000000000000000000000000000000000000000000000000&quot;,
      &quot;passwordSalt&quot;: &quot;0000000000000000000000000000000000000000000000000000000000000000&quot;
    },
    &quot;excludeHealthCheckFromAuth&quot;: false,
    &quot;permittedRoutes&quot;: [
      &quot;/health&quot;,
      &quot;/mqtt&quot;,
      &quot;/api/v1/info&quot;,
      &quot;/api/v1/tips&quot;,
      &quot;/api/v1/messages/:messageID&quot;,
      &quot;/api/v1/messages/:messageID/metadata&quot;,
      &quot;/api/v1/messages/:messageID/raw&quot;,
      &quot;/api/v1/messages/:messageID/children&quot;,
      &quot;/api/v1/messages&quot;,
      &quot;/api/v1/transactions/:transactionID/included-message&quot;,
      &quot;/api/v1/milestones/:milestoneIndex&quot;,
      &quot;/api/v1/milestones/:milestoneIndex/utxo-changes&quot;,
      &quot;/api/v1/outputs/:outputID&quot;,
      &quot;/api/v1/addresses/:address&quot;,
      &quot;/api/v1/addresses/:address/outputs&quot;,
      &quot;/api/v1/addresses/ed25519/:address&quot;,
      &quot;/api/v1/addresses/ed25519/:address/outputs&quot;,
      &quot;/api/v1/treasury&quot;
    ],
    &quot;whitelistedAddresses&quot;: [
      &quot;127.0.0.1&quot;,
      &quot;::1&quot;
    ],
    &quot;bindAddress&quot;: &quot;0.0.0.0:14265&quot;,
    &quot;powEnabled&quot;: false,
    &quot;powWorkerCount&quot;: 1,
    &quot;limits&quot;: {
      &quot;bodyLength&quot;: &quot;1M&quot;,
      &quot;maxResults&quot;: 1000
    }
  },
</code></pre>
<h2 id="2-dashboard"><a class="header" href="#2-dashboard">2. Dashboard</a></h2>
<table><thead><tr><th align="left">Name</th><th align="left">Description</th><th align="left">Type</th></tr></thead><tbody>
<tr><td align="left">bindAddress</td><td align="left">the bind address on which the dashboard can be access from</td><td align="left">string</td></tr>
<tr><td align="left">dev</td><td align="left">whether to run the dashboard in dev mode</td><td align="left">bool</td></tr>
<tr><td align="left"><a href="node-software/hornet/docs/configuration/config.html#auth">auth</a></td><td align="left">config for dashboard auth</td><td align="left">object</td></tr>
</tbody></table>
<h3 id="auth"><a class="header" href="#auth">Auth</a></h3>
<table><thead><tr><th align="left">Name</th><th align="left">Description</th><th align="left">Type</th></tr></thead><tbody>
<tr><td align="left">sessionTimeout</td><td align="left">how long the auth session should last before expiring</td><td align="left">string</td></tr>
<tr><td align="left">username</td><td align="left">the auth username</td><td align="left">string</td></tr>
<tr><td align="left">passwordHash</td><td align="left">the auth password+salt as a scrypt hash</td><td align="left">string</td></tr>
<tr><td align="left">passwordSalt</td><td align="left">the auth salt used for hashing the password</td><td align="left">string</td></tr>
</tbody></table>
<p>Example:</p>
<pre><code class="language-json">  &quot;dashboard&quot;: {
    &quot;bindAddress&quot;: &quot;localhost:8081&quot;,
    &quot;dev&quot;: false,
    &quot;auth&quot;: {
      &quot;sessionTimeout&quot;: &quot;72h&quot;,
      &quot;username&quot;: &quot;admin&quot;,
      &quot;passwordHash&quot;: &quot;0000000000000000000000000000000000000000000000000000000000000000&quot;,
      &quot;passwordSalt&quot;: &quot;0000000000000000000000000000000000000000000000000000000000000000&quot;
    }
  },
</code></pre>
<h2 id="3-db"><a class="header" href="#3-db">3. DB</a></h2>
<table><thead><tr><th align="left">Name</th><th align="left">Description</th><th align="left">Type</th></tr></thead><tbody>
<tr><td align="left">engine</td><td align="left">the used database engine (pebble/bolt/rocksdb)</td><td align="left">string</td></tr>
<tr><td align="left">path</td><td align="left">the path to the database folder</td><td align="left">string</td></tr>
<tr><td align="left">autoRevalidation</td><td align="left">whether to automatically start revalidation on startup if the database is corrupted</td><td align="left">bool</td></tr>
<tr><td align="left">debug</td><td align="left">ignore the check for corrupted databases (should only be used for debug reasons)</td><td align="left">bool</td></tr>
</tbody></table>
<p>Example:</p>
<pre><code class="language-json">  &quot;db&quot;: {
    &quot;engine&quot;: &quot;pebble&quot;,
    &quot;path&quot;: &quot;mainnetdb&quot;,
    &quot;autoRevalidation&quot;: false,
    &quot;debug&quot;: false,
  },
</code></pre>
<h2 id="4-snapshots"><a class="header" href="#4-snapshots">4. Snapshots</a></h2>
<table><thead><tr><th align="left">Name</th><th align="left">Description</th><th align="left">Type</th></tr></thead><tbody>
<tr><td align="left">interval</td><td align="left">interval, in milestones, at which snapshot files are created (snapshots are only created if the node is synced)</td><td align="left">integer</td></tr>
<tr><td align="left">depth</td><td align="left">the depth, respectively the starting point, at which a snapshot of the ledger is generated</td><td align="left">integer</td></tr>
<tr><td align="left">fullPath</td><td align="left">path to the full snapshot file</td><td align="left">string</td></tr>
<tr><td align="left">deltaPath</td><td align="left">path to the delta snapshot file</td><td align="left">string</td></tr>
<tr><td align="left"><a href="node-software/hornet/docs/configuration/config.html#downloadurls">downloadURLs</a></td><td align="left">URLs to load the snapshot files from.</td><td align="left">array of objects</td></tr>
</tbody></table>
<h3 id="downloadurls"><a class="header" href="#downloadurls">DownloadURLs</a></h3>
<table><thead><tr><th align="left">Name</th><th align="left">Description</th><th align="left">Type</th></tr></thead><tbody>
<tr><td align="left">full</td><td align="left">download link to the full snapshot file</td><td align="left">string</td></tr>
<tr><td align="left">delta</td><td align="left">download link to the delta snapshot file</td><td align="left">string</td></tr>
</tbody></table>
<p>Example:</p>
<pre><code class="language-json">&quot;snapshots&quot;: {
    &quot;interval&quot;: 50,
    &quot;depth&quot;: 50,
    &quot;fullPath&quot;: &quot;snapshots/mainnet/full_export.bin&quot;,
    &quot;deltaPath&quot;: &quot;snapshots/mainnet/delta_export.bin&quot;,
    &quot;downloadURLs&quot;: [
      {
        &quot;full&quot;: &quot;https://source1.example.com/full_export.bin&quot;,
        &quot;delta&quot;: &quot;https://source1.example.com/delta_export.bin&quot;
      },
      {
        &quot;full&quot;: &quot;https://source2.example.com/full_export.bin&quot;,
        &quot;delta&quot;: &quot;https://source2.example.com/delta_export.bin&quot;
      }
    ]
  },
</code></pre>
<h2 id="5-pruning"><a class="header" href="#5-pruning">5. Pruning</a></h2>
<table><thead><tr><th align="left">Name</th><th align="left">Description</th><th align="left">Type</th></tr></thead><tbody>
<tr><td align="left">enabled</td><td align="left">whether to delete old message data from the database</td><td align="left">bool</td></tr>
<tr><td align="left">delay</td><td align="left">amount of milestone cones to keep in the database</td><td align="left">integer</td></tr>
<tr><td align="left">pruneReceipts</td><td align="left">whether to delete old receipts data from the database</td><td align="left">bool</td></tr>
</tbody></table>
<p>Example:</p>
<pre><code class="language-json">  &quot;pruning&quot;: {
    &quot;enabled&quot;: true,
    &quot;delay&quot;: 60480,
    &quot;pruneReceipts&quot;: false
  },
</code></pre>
<h2 id="6-protocol"><a class="header" href="#6-protocol">6. Protocol</a></h2>
<table><thead><tr><th align="left">Name</th><th align="left">Description</th><th align="left">Type</th></tr></thead><tbody>
<tr><td align="left">networkID</td><td align="left">the network ID on which this node operates on</td><td align="left">string</td></tr>
<tr><td align="left">bech32HRP</td><td align="left">the HRP which should be used for Bech32 addresses</td><td align="left">string</td></tr>
<tr><td align="left">minPoWScore</td><td align="left">the minimum PoW score required by the network</td><td align="left">float</td></tr>
<tr><td align="left">milestonePublicKeyCount</td><td align="left">the amount of public keys in a milestone</td><td align="left">integer</td></tr>
<tr><td align="left"><a href="node-software/hornet/docs/configuration/config.html#publickeyranges">publicKeyRanges</a></td><td align="left">List of public key ranges from the coordinator</td><td align="left">array of objects</td></tr>
</tbody></table>
<h3 id="publickeyranges"><a class="header" href="#publickeyranges">PublicKeyRanges</a></h3>
<table><thead><tr><th align="left">Name</th><th align="left">Description</th><th align="left">Type</th></tr></thead><tbody>
<tr><td align="left">key</td><td align="left">public key</td><td align="left">string</td></tr>
<tr><td align="left">start</td><td align="left">Milestone start index</td><td align="left">integer</td></tr>
<tr><td align="left">end</td><td align="left">Milestone end index</td><td align="left">integer</td></tr>
</tbody></table>
<p>Example:</p>
<pre><code class="language-json">  &quot;protocol&quot;: {
    &quot;networkID&quot;: &quot;mainnet1&quot;,
    &quot;bech32HRP&quot;: &quot;iota&quot;,
    &quot;minPoWScore&quot;: 4000,
    &quot;milestonePublicKeyCount&quot;: 2,
    &quot;publicKeyRanges&quot;: [
      {
        &quot;key&quot;: &quot;7205c145525cee64f1c9363696811d239919d830ad964b4e29359e6475848f5a&quot;,
        &quot;start&quot;: 0,
        &quot;end&quot;: 0
      },
      {
        &quot;key&quot;: &quot;e468e82df33d10dea3bd0eadcd7867946a674d207c39f5af4cc44365d268a7e6&quot;,
        &quot;start&quot;: 0,
        &quot;end&quot;: 0
      },
      {
        &quot;key&quot;: &quot;0758028d34508079ba1f223907ac3bb5ce8f6bdccc6b961c7c85a2f460b30c1d&quot;,
        &quot;start&quot;: 0,
        &quot;end&quot;: 0
      }
    ]
  },
</code></pre>
<h2 id="7-requests"><a class="header" href="#7-requests">7. Requests</a></h2>
<table><thead><tr><th align="left">Name</th><th align="left">Description</th><th align="left">Type</th></tr></thead><tbody>
<tr><td align="left">discardOlderThan</td><td align="left">the maximum time a request stays in the request queue</td><td align="left">string</td></tr>
<tr><td align="left">pendingReEnqueueInterval</td><td align="left">the interval the pending requests are re-enqueued</td><td align="left">string</td></tr>
</tbody></table>
<p>Example:</p>
<pre><code class="language-json">  &quot;requests&quot;: {
    &quot;discardOlderThan&quot;: &quot;15s&quot;,
    &quot;pendingReEnqueueInterval&quot;: &quot;5s&quot;
  },
</code></pre>
<h2 id="8-coordinator"><a class="header" href="#8-coordinator">8. Coordinator</a></h2>
<table><thead><tr><th align="left">Name</th><th align="left">Description</th><th align="left">Type</th></tr></thead><tbody>
<tr><td align="left"><a href="node-software/hornet/docs/configuration/config.html#checkpoints">checkpoints</a></td><td align="left">config for checkpoints</td><td align="left">object</td></tr>
<tr><td align="left">interval</td><td align="left">the interval milestones are issued</td><td align="left">string</td></tr>
<tr><td align="left">powWorkerCount</td><td align="left">the amount of workers used for calculating PoW when issuing checkpoints and milestones</td><td align="left">integer</td></tr>
<tr><td align="left"><a href="node-software/hornet/docs/configuration/config.html#quorum">quorum</a></td><td align="left">config for quorum</td><td align="left">object</td></tr>
<tr><td align="left"><a href="node-software/hornet/docs/configuration/config.html#signing">signing</a></td><td align="left">config for signing</td><td align="left">object</td></tr>
<tr><td align="left">stateFilePath</td><td align="left">the path to the state file of the coordinator</td><td align="left">string</td></tr>
<tr><td align="left"><a href="node-software/hornet/docs/configuration/config.html#tipsel">tipsel</a></td><td align="left">config for tip selection</td><td align="left">object</td></tr>
</tbody></table>
<h3 id="checkpoints"><a class="header" href="#checkpoints">Checkpoints</a></h3>
<table><thead><tr><th align="left">Name</th><th align="left">Description</th><th align="left">Type</th></tr></thead><tbody>
<tr><td align="left">maxTrackedMessages</td><td align="left">maximum amount of known messages for milestone tipselection</td><td align="left">integer</td></tr>
</tbody></table>
<h3 id="quorum"><a class="header" href="#quorum">Quorum</a></h3>
<table><thead><tr><th align="left">Name</th><th align="left">Description</th><th align="left">Type</th></tr></thead><tbody>
<tr><td align="left">enabled</td><td align="left">whether the coordinator quorum is enabled</td><td align="left">bool</td></tr>
<tr><td align="left"><a href="node-software/hornet/docs/configuration/config.html#groups">groups</a></td><td align="left">the quorum groups used to ask other nodes for correct ledger state of the coordinator</td><td align="left">Array of object arrays</td></tr>
<tr><td align="left">timeout</td><td align="left">the timeout until a node in the quorum must have answered</td><td align="left">string</td></tr>
</tbody></table>
<h4 id="groups"><a class="header" href="#groups">Groups</a></h4>
<table><thead><tr><th align="left">Name</th><th align="left">Description</th><th align="left">Type</th></tr></thead><tbody>
<tr><td align="left"><a href="node-software/hornet/docs/configuration/config.html#group_name">{GROUP_NAME}</a></td><td align="left">the qourum group used to ask other nodes for correct ledger state of the coordinator</td><td align="left">Array of objects</td></tr>
</tbody></table>
<h5 id="group_name"><a class="header" href="#group_name">{GROUP_NAME}</a></h5>
<table><thead><tr><th align="left">Name</th><th align="left">Description</th><th align="left">Type</th></tr></thead><tbody>
<tr><td align="left">alias</td><td align="left">alias of the quorum client (optional)</td><td align="left">string</td></tr>
<tr><td align="left">baseURL</td><td align="left">baseURL of the quorum client</td><td align="left">string</td></tr>
<tr><td align="left">userName</td><td align="left">username for basic auth (optional)</td><td align="left">string</td></tr>
<tr><td align="left">password</td><td align="left">password for basic auth (optional)</td><td align="left">string</td></tr>
</tbody></table>
<h3 id="signing"><a class="header" href="#signing">Signing</a></h3>
<table><thead><tr><th align="left">Name</th><th align="left">Description</th><th align="left">Type</th></tr></thead><tbody>
<tr><td align="left">provider</td><td align="left">the signing provider the coordinator uses to sign a milestone (local/remote)</td><td align="left">string</td></tr>
<tr><td align="left">remoteAddress</td><td align="left">the address of the remote signing provider (insecure connection!)</td><td align="left">string</td></tr>
</tbody></table>
<h3 id="tipsel"><a class="header" href="#tipsel">Tipsel</a></h3>
<table><thead><tr><th align="left">Name</th><th align="left">Description</th><th align="left">Type</th></tr></thead><tbody>
<tr><td align="left">heaviestBranchSelectionTimeout</td><td align="left">the maximum duration to select the heaviest branch tips</td><td align="left">string</td></tr>
<tr><td align="left">maxHeaviestBranchTipsPerCheckpoint</td><td align="left">maximum amount of checkpoint messages with heaviest branch tips</td><td align="left">integer</td></tr>
<tr><td align="left">minHeaviestBranchUnreferencedMessagesThreshold</td><td align="left">minimum threshold of unreferenced messages in the heaviest branch</td><td align="left">integer</td></tr>
<tr><td align="left">randomTipsPerCheckpoint</td><td align="left">amount of checkpoint messages with random tips</td><td align="left">integer</td></tr>
</tbody></table>
<p>Example:</p>
<pre><code class="language-json">  &quot;coordinator&quot;: {
    &quot;stateFilePath&quot;: &quot;coordinator.state&quot;,
    &quot;interval&quot;: &quot;10s&quot;,
    &quot;powWorkerCount&quot;: 15,
    &quot;checkpoints&quot;: {
      &quot;maxTrackedMessages&quot;: 10000
    },
    &quot;tipsel&quot;: {
      &quot;minHeaviestBranchUnreferencedMessagesThreshold&quot;: 20,
      &quot;maxHeaviestBranchTipsPerCheckpoint&quot;: 10,
      &quot;randomTipsPerCheckpoint&quot;: 3,
      &quot;heaviestBranchSelectionTimeout&quot;: &quot;100ms&quot;
    },
    &quot;signing&quot;: {
      &quot;provider&quot;: &quot;local&quot;,
      &quot;remoteAddress&quot;: &quot;localhost:12345&quot;
    },
    &quot;quorum&quot;: {
      &quot;enabled&quot;: false,
      &quot;groups&quot;: {
        &quot;hornet&quot;: [
          {
            &quot;alias&quot;: &quot;hornet1&quot;,
            &quot;baseURL&quot;: &quot;http://hornet1.example.com:14265&quot;,
            &quot;userName&quot;: &quot;&quot;,
            &quot;password&quot;: &quot;&quot;
          }
        ],
        &quot;bee&quot;: [
          {
            &quot;alias&quot;: &quot;bee1&quot;,
            &quot;baseURL&quot;: &quot;http://bee1.example.com:14265&quot;,
            &quot;userName&quot;: &quot;&quot;,
            &quot;password&quot;: &quot;&quot;
          }
        ]
      },
      &quot;timeout&quot;: &quot;2s&quot;
    }
  },
</code></pre>
<h2 id="9-tipsel"><a class="header" href="#9-tipsel">9. Tipsel</a></h2>
<table><thead><tr><th align="left">Name</th><th align="left">Description</th><th align="left">Type</th></tr></thead><tbody>
<tr><td align="left">maxDeltaMsgYoungestConeRootIndexToCMI</td><td align="left">the maximum allowed delta value for the YCRI of a given message in relation to the current CMI before it gets lazy</td><td align="left">integer</td></tr>
<tr><td align="left">maxDeltaMsgOldestConeRootIndexToCMI</td><td align="left">the maximum allowed delta value between OCRI of a given message in relation to the current CMI before it gets semi-lazy</td><td align="left">integer</td></tr>
<tr><td align="left">belowMaxDepth</td><td align="left">the maximum allowed delta value for the OCRI of a given message in relation to the current CMI before it gets lazy</td><td align="left">integer</td></tr>
<tr><td align="left"><a href="node-software/hornet/docs/configuration/nonlazy">nonLazy</a></td><td align="left">config for tips from the non-lazy pool</td><td align="left">object</td></tr>
<tr><td align="left"><a href="node-software/hornet/docs/configuration/semilazy">semiLazy</a></td><td align="left">config for tips from the semi-lazy pool</td><td align="left">object</td></tr>
</tbody></table>
<h3 id="nonlazy"><a class="header" href="#nonlazy">NonLazy</a></h3>
<table><thead><tr><th align="left">Name</th><th align="left">Description</th><th align="left">Type</th></tr></thead><tbody>
<tr><td align="left">retentionRulesTipsLimit</td><td align="left">the maximum number of current tips for which the retention rules are checked (non-lazy)</td><td align="left">integer</td></tr>
<tr><td align="left">maxReferencedTipAge</td><td align="left">the maximum time a tip remains in the tip pool after it was referenced by the first message (non-lazy)</td><td align="left">string</td></tr>
<tr><td align="left">maxChildren</td><td align="left">the maximum amount of references by other messages before the tip is removed from the tip pool (non-lazy)</td><td align="left">integer</td></tr>
<tr><td align="left">spammerTipsThreshold</td><td align="left">the maximum amount of tips in a tip-pool (non-lazy) before the spammer tries to reduce these</td><td align="left">integer</td></tr>
</tbody></table>
<h3 id="semilazy"><a class="header" href="#semilazy">SemiLazy</a></h3>
<table><thead><tr><th align="left">Name</th><th align="left">Description</th><th align="left">Type</th></tr></thead><tbody>
<tr><td align="left">retentionRulesTipsLimit</td><td align="left">the maximum number of current tips for which the retention rules are checked (semi-lazy)</td><td align="left">integer</td></tr>
<tr><td align="left">maxReferencedTipAge</td><td align="left">the maximum time a tip remains in the tip pool after it was referenced by the first message (semi-lazy)</td><td align="left">string</td></tr>
<tr><td align="left">maxChildren</td><td align="left">the maximum amount of references by other messages before the tip is removed from the tip pool (semi-lazy)</td><td align="left">integer</td></tr>
<tr><td align="left">spammerTipsThreshold</td><td align="left">the maximum amount of tips in a tip-pool (semi-lazy) before the spammer tries to reduce these</td><td align="left">integer</td></tr>
</tbody></table>
<p>Example:</p>
<pre><code class="language-json">  &quot;tipsel&quot;: {
    &quot;maxDeltaMsgYoungestConeRootIndexToCMI&quot;: 8,
    &quot;maxDeltaMsgOldestConeRootIndexToCMI&quot;: 13,
    &quot;belowMaxDepth&quot;: 15,
    &quot;nonLazy&quot;: {
      &quot;retentionRulesTipsLimit&quot;: 100,
      &quot;maxReferencedTipAge&quot;: &quot;3s&quot;,
      &quot;maxChildren&quot;: 30,
      &quot;spammerTipsThreshold&quot;: 0
    },
    &quot;semiLazy&quot;: {
      &quot;retentionRulesTipsLimit&quot;: 20,
      &quot;maxReferencedTipAge&quot;: &quot;3s&quot;,
      &quot;maxChildren&quot;: 2,
      &quot;spammerTipsThreshold&quot;: 30
    }
  },
</code></pre>
<h2 id="10-node"><a class="header" href="#10-node">10. Node</a></h2>
<table><thead><tr><th align="left">Name</th><th align="left">Description</th><th align="left">Type</th></tr></thead><tbody>
<tr><td align="left">alias</td><td align="left">the alias to identify a node</td><td align="left">string</td></tr>
<tr><td align="left">profile</td><td align="left">Sets the profile with which the node runs</td><td align="left">string</td></tr>
<tr><td align="left">disablePlugins</td><td align="left">a list of plugins that shall be disabled</td><td align="left">array of strings</td></tr>
<tr><td align="left">enablePlugins</td><td align="left">a list of plugins that shall be enabled</td><td align="left">array of strings</td></tr>
</tbody></table>
<p>Example:</p>
<pre><code class="language-json">  &quot;node&quot;: {
    &quot;alias&quot;: &quot;Mainnet&quot;,
    &quot;profile&quot;: &quot;auto&quot;,
    &quot;disablePlugins&quot;: [
      &quot;Warpsync&quot;
    ],
    &quot;enablePlugins&quot;: [
      &quot;Prometheus&quot;,
      &quot;Spammer&quot;
    ]
  },
</code></pre>
<h2 id="11-p2p"><a class="header" href="#11-p2p">11. P2P</a></h2>
<table><thead><tr><th align="left">Name</th><th align="left">Description</th><th align="left">Type</th></tr></thead><tbody>
<tr><td align="left">bindMultiAddresses</td><td align="left">the bind addresses for this node</td><td align="left">array of strings</td></tr>
<tr><td align="left"><a href="node-software/hornet/docs/configuration/config.html#connectionmanager">connectionManager</a></td><td align="left">config for connection manager</td><td align="left">object</td></tr>
<tr><td align="left">gossipUnknownPeersLimit</td><td align="left">maximum amount of unknown peers a gossip protocol connection is established to</td><td align="left">integer</td></tr>
<tr><td align="left">identityPrivateKey</td><td align="left">private key used to derive the node identity (optional)</td><td align="left">string</td></tr>
<tr><td align="left"><a href="node-software/hornet/docs/configuration/config.html#peerstore">peerStore</a></td><td align="left">config for peer store</td><td align="left">object</td></tr>
<tr><td align="left">reconnectInterval</td><td align="left">the time to wait before trying to reconnect to a disconnected peer</td><td align="left">string</td></tr>
</tbody></table>
<h3 id="connectionmanager"><a class="header" href="#connectionmanager">ConnectionManager</a></h3>
<table><thead><tr><th align="left">Name</th><th align="left">Description</th><th align="left">Type</th></tr></thead><tbody>
<tr><td align="left">highWatermark</td><td align="left">the threshold up on which connections count truncates to the lower watermark</td><td align="left">integer</td></tr>
<tr><td align="left">lowWatermark</td><td align="left">the minimum connections count to hold after the high watermark was reached</td><td align="left">integer</td></tr>
</tbody></table>
<h3 id="peerstore"><a class="header" href="#peerstore">PeerStore</a></h3>
<table><thead><tr><th align="left">Name</th><th align="left">Description</th><th align="left">Type</th></tr></thead><tbody>
<tr><td align="left">path</td><td align="left">the path to the peer store</td><td align="left">string</td></tr>
</tbody></table>
<p>Example:</p>
<pre><code class="language-json">  &quot;p2p&quot;: {
    &quot;bindMultiAddresses&quot;: [
      &quot;/ip4/127.0.0.1/tcp/15600&quot;
    ],
    &quot;connectionManager&quot;: {
      &quot;highWatermark&quot;: 10,
      &quot;lowWatermark&quot;: 5
    },
    &quot;gossipUnknownPeersLimit&quot;: 4,
    &quot;identityPrivateKey&quot;: &quot;&quot;,
    &quot;peerStore&quot;: {
      &quot;path&quot;: &quot;./p2pstore&quot;
    },
    &quot;reconnectInterval&quot;: &quot;30s&quot;
  },
</code></pre>
<h2 id="13-logger"><a class="header" href="#13-logger">13. Logger</a></h2>
<table><thead><tr><th align="left">Name</th><th align="left">Description</th><th align="left">Type</th></tr></thead><tbody>
<tr><td align="left">level</td><td align="left">the minimum enabled logging level. Valid values are: &quot;debug&quot;, &quot;info&quot;, &quot;warn&quot;, &quot;error&quot;, &quot;dpanic&quot;, &quot;panic&quot;, &quot;fatal&quot;</td><td align="left">string</td></tr>
<tr><td align="left">disableCaller</td><td align="left">stops annotating logs with the calling function's file name and line number</td><td align="left">bool</td></tr>
<tr><td align="left">encoding</td><td align="left">sets the logger's encoding. Valid values are &quot;json&quot; and &quot;console&quot;</td><td align="left">string</td></tr>
<tr><td align="left">outputPaths</td><td align="left">a list of URLs, file paths or stdout/stderr to write logging output to</td><td align="left">array of strings</td></tr>
</tbody></table>
<p>Example:</p>
<pre><code class="language-json">  &quot;logger&quot;: {
    &quot;level&quot;: &quot;info&quot;,
    &quot;disableCaller&quot;: true,
    &quot;encoding&quot;: &quot;console&quot;,
    &quot;outputPaths&quot;: [
      &quot;stdout&quot;,
      &quot;hornet.log&quot;
    ]
  },
</code></pre>
<h2 id="14-warpsync"><a class="header" href="#14-warpsync">14. Warpsync</a></h2>
<table><thead><tr><th align="left">Name</th><th align="left">Description</th><th align="left">Type</th></tr></thead><tbody>
<tr><td align="left">advancementRange</td><td align="left">the used advancement range per warpsync checkpoint</td><td align="left">integer</td></tr>
</tbody></table>
<p>Example: </p>
<pre><code class="language-json">  &quot;warpsync&quot;: {
    &quot;advancementRange&quot;: 150,
  }
</code></pre>
<h2 id="15-spammer"><a class="header" href="#15-spammer">15. Spammer</a></h2>
<table><thead><tr><th align="left">Name</th><th align="left">Description</th><th align="left">Type</th></tr></thead><tbody>
<tr><td align="left">message</td><td align="left">the message to embed within the spam messages</td><td align="left">string</td></tr>
<tr><td align="left">index</td><td align="left">the indexation of the message</td><td align="left">string</td></tr>
<tr><td align="left">indexSemiLazy</td><td align="left">the indexation of the message if the semi-lazy pool is used (uses &quot;index&quot; if empty)</td><td align="left">string</td></tr>
<tr><td align="left">cpuMaxUsage</td><td align="left">workers remains idle for a while when cpu usage gets over this limit (0 = disable)</td><td align="left">float</td></tr>
<tr><td align="left">mpsRateLimit</td><td align="left">the rate limit for the spammer (0 = no limit)</td><td align="left">float</td></tr>
<tr><td align="left">workers</td><td align="left">the amount of parallel running spammers</td><td align="left">integer</td></tr>
<tr><td align="left">autostart</td><td align="left">automatically start the spammer on node startup</td><td align="left">bool</td></tr>
</tbody></table>
<p>Example: </p>
<pre><code class="language-json">  &quot;spammer&quot;: {
    &quot;message&quot;: &quot;Binary is the future.&quot;,
    &quot;index&quot;: &quot;HORNET Spammer&quot;,
    &quot;indexSemiLazy&quot;: &quot;HORNET Spammer Semi-Lazy&quot;,
    &quot;cpuMaxUsage&quot;: 0.5,
    &quot;mpsRateLimit&quot;: 0,
    &quot;workers&quot;: 1,
    &quot;autostart&quot;: false
  },
</code></pre>
<h2 id="16-mqtt"><a class="header" href="#16-mqtt">16. MQTT</a></h2>
<table><thead><tr><th align="left">Name</th><th align="left">Description</th><th align="left">Type</th></tr></thead><tbody>
<tr><td align="left">bindAddress</td><td align="left">bind address on which the MQTT broker listens on</td><td align="left">string</td></tr>
<tr><td align="left">wsPort</td><td align="left">port of the WebSocket MQTT broker</td><td align="left">integer</td></tr>
<tr><td align="left">workerCount</td><td align="left">number of parallel workers the MQTT broker uses to publish messages</td><td align="left">integer</td></tr>
</tbody></table>
<p>Example:</p>
<pre><code class="language-json">  &quot;mqtt&quot;: {
    &quot;bindAddress&quot;: &quot;localhost:1883&quot;,
    &quot;wsPort&quot;: 1888,
    &quot;workerCount&quot;: 100
  },
</code></pre>
<h2 id="17-profiling"><a class="header" href="#17-profiling">17. Profiling</a></h2>
<table><thead><tr><th align="left">Name</th><th align="left">Description</th><th align="left">Type</th></tr></thead><tbody>
<tr><td align="left">bindAddress</td><td align="left">the bind address on which the profiler listens on</td><td align="left">string</td></tr>
</tbody></table>
<p>Example:</p>
<pre><code class="language-json">  &quot;profiling&quot;: {
    &quot;bindAddress&quot;: &quot;localhost:6060&quot;
  },
</code></pre>
<h2 id="18-prometheus"><a class="header" href="#18-prometheus">18. Prometheus</a></h2>
<table><thead><tr><th align="left">Name</th><th align="left">Description</th><th align="left">Type</th></tr></thead><tbody>
<tr><td align="left">bindAddress</td><td align="left">the bind address on which the Prometheus exporter listens on</td><td align="left">string</td></tr>
<tr><td align="left"><a href="node-software/hornet/docs/configuration/config.html#fileservicediscovery">fileServiceDiscovery</a></td><td align="left">config for file service discovery</td><td align="left">object</td></tr>
<tr><td align="left">databaseMetrics</td><td align="left">include database metrics</td><td align="left">bool</td></tr>
<tr><td align="left">nodeMetrics</td><td align="left">include node metrics</td><td align="left">bool</td></tr>
<tr><td align="left">gossipMetrics</td><td align="left">include gossip metrics</td><td align="left">bool</td></tr>
<tr><td align="left">cachesMetrics</td><td align="left">include caches metrics</td><td align="left">bool</td></tr>
<tr><td align="left">restAPIMetrics</td><td align="left">include restAPI metrics</td><td align="left">bool</td></tr>
<tr><td align="left">migrationMetrics</td><td align="left">include migration metrics</td><td align="left">bool</td></tr>
<tr><td align="left">coordinatorMetrics</td><td align="left">include coordinator metrics</td><td align="left">bool</td></tr>
<tr><td align="left">debugMetrics</td><td align="left">include debug metrics</td><td align="left">bool</td></tr>
<tr><td align="left">goMetrics</td><td align="left">include go metrics</td><td align="left">bool</td></tr>
<tr><td align="left">processMetrics</td><td align="left">include process metrics</td><td align="left">bool</td></tr>
<tr><td align="left">promhttpMetrics</td><td align="left">include promhttp metrics</td><td align="left">bool</td></tr>
</tbody></table>
<h3 id="fileservicediscovery"><a class="header" href="#fileservicediscovery">FileServiceDiscovery</a></h3>
<table><thead><tr><th align="left">Name</th><th align="left">Description</th><th align="left">Type</th></tr></thead><tbody>
<tr><td align="left">enabled</td><td align="left">whether the plugin should write a Prometheus 'file SD' file</td><td align="left">bool</td></tr>
<tr><td align="left">path</td><td align="left">the path where to write the 'file SD' file to</td><td align="left">string</td></tr>
<tr><td align="left">target</td><td align="left">the target to write into the 'file SD' file</td><td align="left">string</td></tr>
</tbody></table>
<p>Example:</p>
<pre><code class="language-json">  &quot;prometheus&quot;: {
    &quot;bindAddress&quot;: &quot;localhost:9311&quot;,
    &quot;fileServiceDiscovery&quot;: {
      &quot;enabled&quot;: false,
      &quot;path&quot;: &quot;target.json&quot;,
      &quot;target&quot;: &quot;localhost:9311&quot;
    },
    &quot;databaseMetrics&quot;: true,
    &quot;nodeMetrics&quot;: true,
    &quot;gossipMetrics&quot;: true,
    &quot;cachesMetrics&quot;: true,
    &quot;restAPIMetrics&quot;: true,
    &quot;migrationMetrics&quot;: true,
    &quot;coordinatorMetrics&quot;: true,
    &quot;debugMetrics&quot;: false,
    &quot;goMetrics&quot;: false,
    &quot;processMetrics&quot;: false,
    &quot;promhttpMetrics&quot;: false
  }
</code></pre>
<h2 id="19-gossip"><a class="header" href="#19-gossip">19. Gossip</a></h2>
<table><thead><tr><th align="left">Name</th><th align="left">Description</th><th align="left">Type</th></tr></thead><tbody>
<tr><td align="left">streamReadTimeout</td><td align="left">the read timeout for reads from the gossip stream</td><td align="left">string</td></tr>
<tr><td align="left">streamWriteTimeout</td><td align="left">the write timeout for writes to the gossip stream</td><td align="left">string</td></tr>
</tbody></table>
<p>Example: </p>
<pre><code class="language-json">  &quot;gossip&quot;: {
    &quot;streamReadTimeout&quot;: &quot;1m&quot;,
    &quot;streamWriteTimeout&quot;: &quot;10s&quot;,
  }
</code></pre>
<h2 id="20-debug"><a class="header" href="#20-debug">20. Debug</a></h2>
<table><thead><tr><th align="left">Name</th><th align="left">Description</th><th align="left">Type</th></tr></thead><tbody>
<tr><td align="left">whiteFlagParentsSolidTimeout</td><td align="left">defines the the maximum duration for the parents to become solid during white flag confirmation API call</td><td align="left">string</td></tr>
</tbody></table>
<p>Example: </p>
<pre><code class="language-json">  &quot;debug&quot;: {
    &quot;whiteFlagParentsSolidTimeout&quot;: &quot;2s&quot;,
  }
</code></pre>
<h2 id="21-legacy"><a class="header" href="#21-legacy">21. Legacy</a></h2>
<p>This is part the config used in the migration from IOTA 1.0 to IOTA 1.5 (Chrysalis)</p>
<h2 id="211-migrator"><a class="header" href="#211-migrator">21.1 Migrator</a></h2>
<table><thead><tr><th align="left">Name</th><th align="left">Description</th><th align="left">Type</th></tr></thead><tbody>
<tr><td align="left">queryCooldownPeriod</td><td align="left">the cooldown period of the service to ask for new data</td><td align="left">string</td></tr>
<tr><td align="left">receiptMaxEntries</td><td align="left">the max amount of entries to embed within a receipt</td><td align="left">integer</td></tr>
<tr><td align="left">stateFilePath</td><td align="left">path to the state file of the migrator</td><td align="left">string</td></tr>
</tbody></table>
<p>Example:</p>
<pre><code class="language-json">  &quot;migrator&quot;: {
    &quot;queryCooldownPeriod&quot;: &quot;5s&quot;,
    &quot;receiptMaxEntries&quot;: 110,
    &quot;stateFilePath&quot;: &quot;migrator.state&quot;,
  }
</code></pre>
<h2 id="212-receipts"><a class="header" href="#212-receipts">21.2 Receipts</a></h2>
<table><thead><tr><th align="left">Name</th><th align="left">Description</th><th align="left">Type</th></tr></thead><tbody>
<tr><td align="left"><a href="node-software/hornet/docs/configuration/config.html#backup">backup</a></td><td align="left">config for backup</td><td align="left">object</td></tr>
<tr><td align="left"><a href="node-software/hornet/docs/configuration/config.html#validator">validator</a></td><td align="left">config for validator</td><td align="left">object</td></tr>
</tbody></table>
<h3 id="backup-1"><a class="header" href="#backup-1">Backup</a></h3>
<table><thead><tr><th align="left">Name</th><th align="left">Description</th><th align="left">Type</th></tr></thead><tbody>
<tr><td align="left">enabled</td><td align="left">whether to backup receipts in the backup folder</td><td align="left">bool</td></tr>
<tr><td align="left">folder</td><td align="left">path to the receipts backup folder</td><td align="left">string</td></tr>
</tbody></table>
<h3 id="validator"><a class="header" href="#validator">Validator</a></h3>
<table><thead><tr><th align="left">Name</th><th align="left">Description</th><th align="left">Type</th></tr></thead><tbody>
<tr><td align="left"><a href="node-software/hornet/docs/configuration/config.html#api">api</a></td><td align="left">config for legacy API</td><td align="left">object</td></tr>
<tr><td align="left"><a href="node-software/hornet/docs/configuration/config.html#coordinator">coordinator</a></td><td align="left">config for legacy Coordinator</td><td align="left">object</td></tr>
<tr><td align="left">ignoreSoftErrors</td><td align="left">whether to ignore soft errors and not panic if one is encountered</td><td align="left">bool</td></tr>
<tr><td align="left">validate</td><td align="left">whether to validate receipts</td><td align="left">bool</td></tr>
</tbody></table>
<h4 id="api-3"><a class="header" href="#api-3">Api</a></h4>
<table><thead><tr><th align="left">Name</th><th align="left">Description</th><th align="left">Type</th></tr></thead><tbody>
<tr><td align="left">address</td><td align="left">address of the legacy node API</td><td align="left">string</td></tr>
<tr><td align="left">timeout</td><td align="left">timeout of API calls</td><td align="left">string</td></tr>
</tbody></table>
<h4 id="coordinator"><a class="header" href="#coordinator">Coordinator</a></h4>
<table><thead><tr><th align="left">Name</th><th align="left">Description</th><th align="left">Type</th></tr></thead><tbody>
<tr><td align="left">address</td><td align="left">address of the legacy coordinator</td><td align="left">string</td></tr>
<tr><td align="left">merkleTreeDepth</td><td align="left">depth of the Merkle tree of the coordinator</td><td align="left">integer</td></tr>
</tbody></table>
<p>Example:</p>
<pre><code class="language-json">  &quot;receipts&quot;: {
    &quot;backup&quot;: {
      &quot;enabled&quot;: false,
      &quot;folder&quot;: &quot;receipts&quot;,
    },
    &quot;validator&quot;: {
      &quot;api&quot;: {
        &quot;address&quot;: &quot;http://localhost:14266&quot;,
        &quot;timeout&quot;: &quot;5s&quot;,
      },
      &quot;coordinator&quot;: {
        &quot;address&quot;: &quot;JFQ999DVN9CBBQX9DSAIQRAFRALIHJMYOXAQSTCJLGA9DLOKIWHJIFQKMCQ9QHWW9RXQMDBVUIQNIY9GZ&quot;,
        &quot;merkleTreeDepth&quot;: 18,
      },
      &quot;ignoreSoftErrors&quot;: false,
      &quot;validate&quot;: false,
    },
  }
</code></pre>
<h1 id="peeringjson"><a class="header" href="#peeringjson">peering.json</a></h1>
<p>The easiest way to add peers in Hornet is via dashboard. Simply go to <code>Peers</code> and click on <code>Add Peer</code>.<br />
But for the sake of completeness this document describes the structure of the <code>peering.json</code> file.</p>
<p>The <code>peering.json</code> file contains a list of peers. Peers have the following attributes:</p>
<table><thead><tr><th align="left">Name</th><th align="left">Description</th><th align="left">Type</th></tr></thead><tbody>
<tr><td align="left">alias</td><td align="left">alias of the peer</td><td align="left">string</td></tr>
<tr><td align="left">multiAddress</td><td align="left">multiAddress of the peer</td><td align="left">string</td></tr>
</tbody></table>
<p>Example:</p>
<pre><code class="language-json">{
  &quot;peers&quot;: [
    {
      &quot;alias&quot;: &quot;Node1&quot;,
      &quot;multiAddress&quot;: &quot;/ip4/192.0.2.0/tcp/15600/p2p/12D3KooWCKWcTWevORKa2KEBputEGASvEBuDfRDSbe8t1DWugUmL&quot;
    },
    {
      &quot;alias&quot;: &quot;Node2&quot;,
      &quot;multiAddress&quot;: &quot;/ip6/2001:db8:3333:4444:5555:6666:7777:8888/tcp/16600/p2p/12D3KooWJDqHjhd8us8XdbKy1Adp5nV6XoI7XhjZbPWAfbAbkLbH&quot;
    },
    {
      &quot;alias&quot;: &quot;Node3&quot;,
      &quot;multiAddress&quot;: &quot;/dns/example.com/tcp/15600/p2p/12D3KooWN7F4eRAYbavnasME8WGXwkrpzWWoZSXfNSEpudmWi9YP&quot;
    }
  ]
}
</code></pre>
<h1 id="api-reference-7"><a class="header" href="#api-reference-7">API Reference</a></h1>
<p>This document specifies the REST API for IOTA node software:</p>
<ul>
<li><a href="https://editor.swagger.io/?url=https://raw.githubusercontent.com/rufsam/protocol-rfcs/master/text/0026-rest-api/rest-api.yaml">IOTA REST API</a></li>
</ul>
<p>The node event API is in charge of publishing information about events within the node software:</p>
<ul>
<li><a href="https://playground.asyncapi.io/?load=https://raw.githubusercontent.com/luca-moser/protocol-rfcs/rfc/node-event-api/text/0033-node-event-api/0033-node-event-api.yml">Node event API</a> </li>
</ul>
<h1 id="troubleshooting-6"><a class="header" href="#troubleshooting-6">Troubleshooting</a></h1>
<p>Check our <a href="node-software/hornet/docs/./FAQ.html">Frequently asked questions</a>.</p>
<p>If your question is not covered in the FAQ, feel free to ask in the <code>#hornet</code> channel (<a href="https://discord.iota.org/">official iota discord server</a>).</p>
<h2 id="something-went-wrong"><a class="header" href="#something-went-wrong">Something went wrong?</a></h2>
<ul>
<li><strong>Please open a <a href="https://github.com/gohornet/hornet/issues/new">new issue</a> if you detect an error or crash (or submit a PR if you have already fixed it).</strong></li>
</ul>
<h1 id="faq-1"><a class="header" href="#faq-1">FAQ</a></h1>
<h1 id="contributing-1"><a class="header" href="#contributing-1">Contributing</a></h1>
<p><strong>By participating to this project, you agree to abide our <a href="node-software/hornet/docs//CODE_OF_CONDUCT.html">code of conduct</a>.</strong></p>
<hr />
<h2 id="how-to-contribute"><a class="header" href="#how-to-contribute">How to contribute</a></h2>
<h3 id="basic-setup"><a class="header" href="#basic-setup">Basic setup</a></h3>
<p><code>HORNET</code> is written in <a href="https://golang.org/">Go</a>.</p>
<p>Prerequisites:</p>
<ol>
<li>Setup <a href="https://golang.org/doc/install">Go 1.14+</a></li>
<li>Fork <code>HORNET</code></li>
<li>Test your setup by building <code>HORNET</code>:
<code>go build</code></li>
</ol>
<h2 id="make-your-changes"><a class="header" href="#make-your-changes">Make your changes</a></h2>
<p>Make your changes and test them sufficiently.</p>
<h2 id="create-a-commit"><a class="header" href="#create-a-commit">Create a commit</a></h2>
<p>Commit messages should be well formatted.</p>
<p>You can use this as a guide:
<a href="https://www.conventionalcommits.org">Conventional Commits</a></p>
<h2 id="submit-a-pull-request"><a class="header" href="#submit-a-pull-request">Submit a pull request</a></h2>
<p>Push your branch to your <code>HORNET</code> fork and open a pull request to the
<strong>develop</strong> branch.</p>
<h1 id="contributor-covenant-code-of-conduct"><a class="header" href="#contributor-covenant-code-of-conduct">Contributor Covenant Code of Conduct</a></h1>
<h2 id="our-pledge"><a class="header" href="#our-pledge">Our Pledge</a></h2>
<p>In the interest of fostering an open and welcoming environment, we as
contributors and maintainers pledge to make participation in our project and
our community a harassment-free experience for everyone, regardless of age, body
size, disability, ethnicity, sex characteristics, gender identity and expression,
level of experience, education, socio-economic status, nationality, personal
appearance, race, religion, or sexual identity and orientation.</p>
<h2 id="our-standards"><a class="header" href="#our-standards">Our Standards</a></h2>
<p>Examples of behavior that contributes to creating a positive environment
include:</p>
<ul>
<li>Using welcoming and inclusive language</li>
<li>Being respectful of differing viewpoints and experiences</li>
<li>Gracefully accepting constructive criticism</li>
<li>Focusing on what is best for the community</li>
<li>Showing empathy towards other community members</li>
</ul>
<p>Examples of unacceptable behavior by participants include:</p>
<ul>
<li>The use of sexualized language or imagery and unwelcome sexual attention or
advances</li>
<li>Trolling, insulting/derogatory comments, and personal or political attacks</li>
<li>Public or private harassment</li>
<li>Publishing others' private information, such as a physical or electronic
address, without explicit permission</li>
<li>Other conduct which could reasonably be considered inappropriate in a
professional setting</li>
</ul>
<h2 id="our-responsibilities"><a class="header" href="#our-responsibilities">Our Responsibilities</a></h2>
<p>Project maintainers are responsible for clarifying the standards of acceptable
behavior and are expected to take appropriate and fair corrective action in
response to any instances of unacceptable behavior.</p>
<p>Project maintainers have the right and responsibility to remove, edit, or
reject comments, commits, code, wiki edits, issues, and other contributions
that are not aligned to this Code of Conduct, or to ban temporarily or
permanently any contributor for other behaviors that they deem inappropriate,
threatening, offensive, or harmful.</p>
<h2 id="scope"><a class="header" href="#scope">Scope</a></h2>
<p>This Code of Conduct applies within all project spaces, and it also applies when
an individual is representing the project or its community in public spaces.
Examples of representing a project or community include using an official
project e-mail address, posting via an official social media account, or acting
as an appointed representative at an online or offline event. Representation of
a project may be further defined and clarified by project maintainers.</p>
<h2 id="enforcement"><a class="header" href="#enforcement">Enforcement</a></h2>
<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be
reported by contacting the project team at hornet@iotmod.de. All
complaints will be reviewed and investigated and will result in a response that
is deemed necessary and appropriate to the circumstances. The project team is
obligated to maintain confidentiality with regard to the reporter of an incident.
Further details of specific enforcement policies may be posted separately.</p>
<p>Project maintainers who do not follow or enforce the Code of Conduct in good
faith may face temporary or permanent repercussions as determined by other
members of the project's leadership.</p>
<h2 id="attribution"><a class="header" href="#attribution">Attribution</a></h2>
<p>This Code of Conduct is adapted from the <a href="http://contributor-covenant.org">Contributor Covenant</a>, version 1.4,
available at <a href="http://contributor-covenant.org/version/1/4/">http://contributor-covenant.org/version/1/4</a></p>
<h1 id="welcome-to-the-bee-docs--"><a class="header" href="#welcome-to-the-bee-docs--">Welcome to the Bee Docs 🐝 📖</a></h1>
</h1>
<h2 align="center">A framework for building IOTA nodes, clients, and applications in Rust.</h2>
<p align="center">
  <a href="https://discord.iota.org/" style="text-decoration:none;"><img src="https://img.shields.io/badge/Discord-9cf.svg?logo=discord" alt="Discord"></a>
  <a href="https://iota.stackexchange.com/" style="text-decoration:none;"><img src="https://img.shields.io/badge/StackExchange-9cf.svg?logo=stackexchange" alt="StackExchange"></a>
  <a href="https://github.com/iotaledger/bee/blob/master/LICENSE" style="text-decoration:none;"><img src="https://img.shields.io/github/license/iotaledger/bee.svg" alt="Apache 2.0 license"></a>
</p>
<p align="center">
  <img src="https://github.com/iotaledger/bee/workflows/Format/badge.svg">
  <img src="https://github.com/iotaledger/bee/workflows/Audit/badge.svg">
  <img src="https://github.com/iotaledger/bee/workflows/Clippy/badge.svg">
  <img src="https://github.com/iotaledger/bee/workflows/Build/badge.svg">
  <img src="https://github.com/iotaledger/bee/workflows/Test/badge.svg">
  <img src="https://coveralls.io/repos/github/iotaledger/bee/badge.svg?branch=master">
</p>
<p align="center">
  <a href="node-software/Bee/docs/welcome.html#about">About</a> ◈
  <a href="node-software/Bee/docs/welcome.html#design">Design</a> ◈
  <a href="node-software/Bee/docs/welcome.html#supporting-the-project">Supporting the project</a> ◈
  <a href="node-software/Bee/docs/welcome.html#joining-the-discussion">Joining the discussion</a>
</p>
<hr />
<h1 id="about"><a class="header" href="#about">About</a></h1>
<p>The IOTA Foundation aims to allow machines of all performance levels to
contribute to the IOTA network, from microcontrollers to phones, web browsers, and servers.</p>
<p>Therefore, Bee is being developed as a modular collection of extendable crates, which expose foreign function interfaces (FFIs) for the next iteration of client libraries.</p>
<p><strong>Note:</strong> You can find details about future development plans in our <a href="https://roadmap.iota.org">roadmap</a>.</p>
<h2 id="design"><a class="header" href="#design">Design</a></h2>
<p>Bee will be a central reference implementation for the most important
data structures and algorithms. This implementation will be verified during a <a href="https://github.com/iotaledger/bee-rfcs/">Request for Comments</a> (RFC) process and eventually certified.</p>
<p>By using this approach, we hope that improvements to core components will quickly propagate to all other client libraries, rather than
having to fix each one individually.</p>
<p><strong>Note:</strong> The Rust programming language was chosen for Bee because of its C/C++ like performance and its strong memory safety guarantees. <a href="https://www.rust-lang.org/">Learn more about Rust</a>.</p>
<h2 id="supporting-the-project"><a class="header" href="#supporting-the-project">Supporting the project</a></h2>
<p>If you want to discuss Bee or have some questions about it, join us on the
<a href="https://discord.iota.org/">IOTA Discord server</a> in the <code>#bee-dev</code> and
<code>#bee-discussion</code> channels.</p>
<p>If you want to be a part of development, please see the <a href="node-software/Bee/docs/.github/CONTRIBUTING.html">contributing guidelines</a> for information on how to contribute.</p>
<h2 id="joining-the-discussion-14"><a class="header" href="#joining-the-discussion-14">Joining the discussion</a></h2>
<p>If you want to get involved in the community, need help getting started, have any issues related to the repository or just want to discuss blockchain, distributed ledgers, and IoT with other people, feel free to join our <a href="https://discord.iota.org/">Discord</a>.</p>
<h1 id="overview-8"><a class="header" href="#overview-8">Overview</a></h1>
<blockquote>
<p>[TODO]</p>
</blockquote>
<ul>
<li>List all Crates</li>
</ul>
<h1 id="setup-a-node"><a class="header" href="#setup-a-node">Setup a Node</a></h1>
<h1 id="bee-node"><a class="header" href="#bee-node">bee-node</a></h1>
<h1 id="installing-from-source"><a class="header" href="#installing-from-source">Installing from source</a></h1>
<h2 id="dependencies-1"><a class="header" href="#dependencies-1">Dependencies</a></h2>
<h3 id="debian"><a class="header" href="#debian">Debian</a></h3>
<pre><code class="language-sh">apt-get update
apt-get upgrade
apt-get install git npm build-essential cmake pkg-config librocksdb-dev llvm clang libclang-dev libssl-dev
</code></pre>
<h3 id="macos-1"><a class="header" href="#macos-1">MacOS</a></h3>
<pre><code class="language-sh">/bin/bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)&quot;
brew install cmake npm
</code></pre>
<h3 id="windows-1"><a class="header" href="#windows-1">Windows</a></h3>
<p>Open Powershell and execute the following commands:</p>
<pre><code class="language-sh">Set-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString('https://chocolatey.org/install.ps1'))
choco install git --params '/NoAutoCrlf' nodejs-lts cmake --installargs 'ADD_CMAKE_TO_PATH=System' llvm
</code></pre>
<p>Restart Powershell</p>
<h3 id="rust-2"><a class="header" href="#rust-2">Rust</a></h3>
<p>Minimum required version 1.48.</p>
<h4 id="installation-debian-macos"><a class="header" href="#installation-debian-macos">Installation (Debian, MacOS)</a></h4>
<pre><code class="language-sh">curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
source $HOME/.cargo/env
</code></pre>
<h4 id="installation-windows"><a class="header" href="#installation-windows">Installation (Windows)</a></h4>
<p>Install Rust from <a href="https://www.rust-lang.org/learn/get-started">here</a>.</p>
<h4 id="update"><a class="header" href="#update">Update</a></h4>
<pre><code class="language-sh">rustup update
</code></pre>
<h2 id="compilation"><a class="header" href="#compilation">Compilation</a></h2>
<pre><code class="language-sh">git clone https://github.com/iotaledger/bee.git --branch chrysalis-pt-2
cd bee/bee-node
</code></pre>
<p>With dashboard</p>
<pre><code class="language-sh">git submodule update --init
cd src/plugins/dashboard/frontend
npm install
npm run build-bee
cd ../../../../
cargo build --release --features dashboard
</code></pre>
<p>Without dashboard</p>
<pre><code class="language-sh">cargo build --release
</code></pre>
<h2 id="running"><a class="header" href="#running">Running</a></h2>
<pre><code class="language-sh">cp config.example.toml config.toml
../target/release/bee
</code></pre>
<h1 id="contribute-to-bee"><a class="header" href="#contribute-to-bee">Contribute to Bee</a></h1>
<p>This document describes how to contribute to Bee.</p>
<p>We encourage everyone with knowledge of IOTA technology to contribute.</p>
<p>Thanks! :heart:</p>
<details>
<summary>Do you have a question :question:</summary>
<br>
<p>If you have a general or technical question, you can use one of the following resources instead of submitting an issue:</p>
<ul>
<li><a href="https://docs.iota.org/"><strong>Developer documentation:</strong></a> For official information about developing with IOTA technology</li>
<li><a href="https://discord.iota.org/"><strong>Discord:</strong></a> For real-time chats with the developers and community members</li>
<li><a href="https://iota.cafe/"><strong>IOTA cafe:</strong></a> For technical discussions with the Research and Development Department at the IOTA Foundation</li>
<li><a href="https://iota.stackexchange.com/"><strong>StackExchange:</strong></a> For technical and troubleshooting questions</li>
</ul>
</details>
<br>
<details>
<summary>Ways to contribute :mag:</summary>
<br>
<p>To contribute to Bee on GitHub, you can:</p>
<ul>
<li>Report a bug</li>
<li>Suggest a new feature</li>
<li>Build a new feature</li>
<li>Join the Bee Initiative</li>
</ul>
</details>
<br>
<details>
<summary>Report a bug :bug:</summary>
<br>
<p>This section guides you through reporting a bug. Following these guidelines helps maintainers and the community understand the bug, reproduce the behavior, and find related bugs.</p>
<h3 id="before-reporting-a-bug"><a class="header" href="#before-reporting-a-bug">Before reporting a bug</a></h3>
<p>Please check the following list:</p>
<ul>
<li>
<p><strong>Do not open a GitHub issue for <a href="node-software/Bee/docs/.github/SECURITY.MD">security vulnerabilities</a></strong>, instead, please contact us at <a href="mailto:security@iota.org">security@iota.org</a>.</p>
</li>
<li>
<p><strong>Ensure the bug was not already reported</strong> by searching on GitHub under <a href="https://github.com/iotaledger/bee/issues"><strong>Issues</strong></a>. If the bug has already been reported <strong>and the issue is still open</strong>, add a comment to the existing issue instead of opening a new one.</p>
</li>
</ul>
<p><strong>Note:</strong> If you find a <strong>Closed</strong> issue that seems similar to what you're experiencing, open a new issue and include a link to the original issue in the body of your new one.</p>
<h3 id="submitting-a-bug-report"><a class="header" href="#submitting-a-bug-report">Submitting A Bug Report</a></h3>
<p>To report a bug, <a href="https://github.com/iotaledger/bee/issues/new">open a new issue</a>, and be sure to include as many details as possible, using the template.</p>
<p><strong>Note:</strong> Minor changes such as fixing a typo can but do not need an open issue.</p>
<p>If you also want to fix the bug, submit a <a href="node-software/Bee/docs/contribution.html#pull-requests">pull request</a> and reference the issue.</p>
</details>
<br>
<details>
<summary>Suggest a new feature :bulb:</summary>
<br>
<p>This section guides you through suggesting a new feature. Following these guidelines helps maintainers and the community collaborate to find the best possible way forward with your suggestion.</p>
<h3 id="before-suggesting-a-new-feature"><a class="header" href="#before-suggesting-a-new-feature">Before suggesting a new feature</a></h3>
<p><strong>Ensure the feature has not already been suggested</strong> by searching on GitHub under <a href="https://github.com/iotaledger/bee/issues"><strong>Issues</strong></a>.</p>
<h3 id="suggesting-a-new-feature"><a class="header" href="#suggesting-a-new-feature">Suggesting a new feature</a></h3>
<p>To suggest a new feature, talk to the IOTA community and IOTA Foundation members in the #bee-discussion channel on <a href="https://discord.iota.org/">Discord</a>.</p>
<p>Or, you can submit an official <a href="https://github.com/iotaledger/bee-rfcs/">Request for Comments (RFC)</a>.</p>
</details>
<br>
<details>
<summary>Build a new feature :hammer:</summary>
<br>
<p>This section guides you through building a new feature. Following these guidelines helps give your feature the best chance of being approved and merged.</p>
<h3 id="before-building-a-new-feature"><a class="header" href="#before-building-a-new-feature">Before building a new feature</a></h3>
<p>Make sure to discuss the feature in the #bee-discussion channel on <a href="https://discord.iota.org/">Discord</a>.</p>
<p>Otherwise, your feature may not be approved at all.</p>
<h3 id="building-a-new-feature"><a class="header" href="#building-a-new-feature">Building a new feature</a></h3>
<p>To build a new feature, check out a new branch based on the <code>master</code> branch, and be sure to document any public-facing APIs, using Rust code comments.</p>
</details>
<br>
<details>
<summary>Join the Bee Initiative :deciduous_tree:</summary>
<br>
<p>The <a href="https://github.com/iota-community/bee">Bee Initiative</a> is a collaborative effort to improve the Bee developer experience by focussing on the following goals:</p>
<ul>
<li>Quality Assurance and Quality Control</li>
<li>Documentation</li>
<li>Benchmarks</li>
<li>RFCs</li>
<li>Node usability</li>
<li>Improvements to modules and libraries</li>
</ul>
<h2 id="how-much-time-is-involved"><a class="header" href="#how-much-time-is-involved">How much time is involved</a></h2>
<p>You can invest as much or as little time as you want into the initiative.</p>
<h2 id="whats-in-it-for-you"><a class="header" href="#whats-in-it-for-you">What's in it for you</a></h2>
<p>In return for your time, not only do you get to be a part of the future of IOTA technology, you will also be given a badge on Discord to show others that you're a valuable member of the IOTA community.</p>
<h2 id="how-to-join"><a class="header" href="#how-to-join">How to join</a></h2>
<p>If you're interested in joining, chat to us in the #experience channel on <a href="https://discord.iota.org/">Discord</a>.</p>
</details>
<br>
<details>
<summary>Pull requests :mega:</summary>
<br>
<p>This section guides you through submitting a pull request (PR). Following these guidelines helps give your PR the best chance of being approved and merged.</p>
<h3 id="before-submitting-a-pull-request"><a class="header" href="#before-submitting-a-pull-request">Before submitting a pull request</a></h3>
<p>Before submitting a pull request, please follow these steps to have your contribution considered by the maintainers:</p>
<ul>
<li>
<p>A pull request should have exactly one concern (for example one feature or one bug). If a PR addresses more than one concern, it should be split into two or more PRs.</p>
</li>
<li>
<p>A pull request can be merged only if it references an open issue</p>
<p><strong>Note:</strong> You don't need to open an issue for minor changes such as typos, but you can if you want.</p>
</li>
<li>
<p>All public interfaces should have descriptive documentation, including an
example that compiles and passes <a href="https://doc.rust-lang.org/rustdoc/documentation-tests.html">documentation tests</a></p>
</li>
<li>
<p>All instances of <code>unsafe</code> should have a comment that explains why its use was unavoidable</p>
</li>
<li>
<p>All code should be well tested, using unit tests and integration tests</p>
</li>
<li>
<p>Code must compile and pass our <a href="node-software/Bee/docs/.github/workflows">continuous integration tests</a></p>
</li>
<li>
<p>To be compatible with the guidelines of the Eclipse foundation, all code must be licensed under the <a href="https://www.apache.org/licenses/LICENSE-2.0">Apache License, Version 2.0</a>. This license must be referenced in every crate of the workspace (add [<code>./LICENSE</code>] to the crate's top level directory). For Rust crates, every <code>Cargo.toml</code> must contain the line <code>license = &quot;Apache-2.0&quot;</code>.</p>
</li>
</ul>
<h3 id="submitting-a-pull-request"><a class="header" href="#submitting-a-pull-request">Submitting a pull request</a></h3>
<p>The following is a typical workflow for submitting a new pull request:</p>
<ol>
<li>Fork this repository</li>
<li>Create a new branch based on your fork. For example, <code>git checkout -b fix/my-fix</code> or <code> git checkout -b feat/my-feature</code>.</li>
<li>Run the <code>rustfmt</code> command to make sure your code is well formatted</li>
<li>Commit changes and push them to your fork</li>
<li>Target your pull request to be merged with <code>master</code></li>
</ol>
<p>If all <a href="https://help.github.com/articles/about-status-checks/">status checks</a> pass, and the maintainer approves the PR, it will be merged.</p>
<p><strong>Note:</strong> Reviewers may ask you to complete additional work, tests, or other changes before your pull request can be approved and merged.</p>
</details>
<br>
<details>
<summary>Code of Conduct :clipboard:</summary>
<br>
<p>This project and everyone participating in it is governed by the <a href="node-software/Bee/docs/.github/CODE_OF_CONDUCT.html">IOTA Code of Conduct</a>.</p>
<h1 id="welcome-3"><a class="header" href="#welcome-3">Welcome</a></h1>
<p>Welcome to the GoShimmer docs!</p>
<p>GoShimmer is a prototype node software exploring the implementation of <a href="https://coordicide.iota.org/">the Coordicide project</a>. This wiki helps the reader to understand the basic concepts and ideas behind the Coordicide and how its modules are implemented in GoShimmer.</p>
<p>Due to the prototypical nature of the project, things written today may not be reflecting how things are tomorrow. We seek to keep the docs as updated as possible, since it is also used as guide for our team. If you find any inconsistencies, feel free to contact us on Discord or better, <a href="https://github.com/iotaledger/goshimmer/issues/new/choose">create an issue on this repository</a>.</p>
<h1 id="faq-2"><a class="header" href="#faq-2">FAQ</a></h1>
<h3 id="what-is-goshimmer"><a class="header" href="#what-is-goshimmer">What is GoShimmer?</a></h3>
<p>GoShimmer is a research and engineering project from the IOTA Foundation seeking to evaluate Coordicide concepts by implementing them in a node software.</p>
<h3 id="what-kind-of-confirmation-time-can-i-expect"><a class="header" href="#what-kind-of-confirmation-time-can-i-expect">What kind of confirmation time can I expect?</a></h3>
<p>Since non conflicting transactions aren't even voted up on, they materialize after 2x the average network delay parameter we set. This means that a transaction usually confirms within a time boundary of ~10 seconds.</p>
<h3 id="where-can-i-see-the-state-of-the-pollen-testnet"><a class="header" href="#where-can-i-see-the-state-of-the-pollen-testnet">Where can I see the state of the Pollen testnet?</a></h3>
<p>You can access the global analysis dashboard <a href="http://ressims.iota.cafe:28080/autopeering">here</a> showcasing the network graph and active ongoing votes on conflicts.</p>
<h3 id="how-much-tps-can-goshimmer-sustain"><a class="header" href="#how-much-tps-can-goshimmer-sustain">How much TPS can GoShimmer sustain?</a></h3>
<p>The transactions per second metric is irrelevant for the current development state of GoShimmer. We are evaluating components from Coordicide and aren't currently interested in squeezing out every little ounce of performance. Meaning, we value simplicity over optimization since the primary goal is to evaluate Coordicide components. Even if we would put out a TPS number, it would simply not reflect an actual metric in a finished production ready node software. </p>
<h3 id="how-is-spamming-prevented"><a class="header" href="#how-is-spamming-prevented">How is spamming prevented?</a></h3>
<p>The Coordicide lays out concepts for spam prevention through the means of rate control and such. However, in the current version, GoShimmer relies on PoW to prevent over saturation of the network. Usually doing the PoW for a message will take a couple of seconds on commodity hardware.</p>
<h3 id="what-happens-if-i-issue-a-double-spend"><a class="header" href="#what-happens-if-i-issue-a-double-spend">What happens if I issue a double spend?</a></h3>
<p>If you have funds and are simultaneously issuing transactions spending those, then with high certainty your transactions are going to be rejected by the network. This goes even so far, that your funds will be blocked indefinitely (this might change in the future). If you issue a transaction, await the average network delay and then issue the double spend, then the first issued transaction should usually become confirmed and the 2nd one rejected.</p>
<h3 id="whos-the-target-audience-for-operating-a-goshimmer-node"><a class="header" href="#whos-the-target-audience-for-operating-a-goshimmer-node">Who's the target audience for operating a GoShimmer node?</a></h3>
<p>We are mainly interested in individuals helping us out who have a strong IT background, since we simply lack time to help people with things like setting up their nodes, fixing their NAT configs, teaching them how to use Linux and so on. People interested in trying out the bleeding edge of IOTA development and providing meaningful feedback or problem reporting (in form of issues) are welcome. Again, our primary focus is on testing out Coordicide components rather than giving people of any knowledge-level the easiest way to operate a node.</p>
<h1 id="tutorials-1"><a class="header" href="#tutorials-1">Tutorials</a></h1>
<h1 id="setting-up-a-goshimmer-node"><a class="header" href="#setting-up-a-goshimmer-node">Setting up a GoShimmer node</a></h1>
<p>This page describes how to setup your own GoShimmer node in the Pollen testnet with Docker.</p>
<blockquote>
<p>DISCLAIMER: <strong>Note that there will be breaking changes frequently (approx. bi-weekly) where the entire network needs to upgrade. If you don't have time to continuously monitor and upgrade your node, then running a GoShimmer node might not be for you.</strong>  We want to emphasize that running a GoShimmer node requires proper knowledge in Linux and IT related topics such as networking and so on. It is not meant as a node to be run by people with little experience in the mentioned fields. <strong>Do not plan to run any production level services on your node/network.</strong></p>
</blockquote>
<table><thead><tr><th align="left">Contents</th></tr></thead><tbody>
<tr><td align="left"><a href="node-software/goshimmer/docs/tutorials/setup.html#why-you-should-run-a-node">Why you should run a node</a></td></tr>
<tr><td align="left"><a href="node-software/goshimmer/docs/tutorials/setup.html#installing-goshimmer-with-docker">Installing GoShimmer with Docker</a></td></tr>
<tr><td align="left"><a href="node-software/goshimmer/docs/tutorials/setup.html#running-the-goshimmer-node">Running the GoShimmer node</a></td></tr>
<tr><td align="left"><a href="node-software/goshimmer/docs/tutorials/setup.html#managing-the-goshimmer-node-lifecycle">Managing the GoShimmer node lifecycle</a></td></tr>
<tr><td align="left"><a href="node-software/goshimmer/docs/tutorials/setup.html#setting-up-the-grafana-dashboard">Setting up the Grafana dashboard</a></td></tr>
</tbody></table>
<h2 id="why-you-should-run-a-node"><a class="header" href="#why-you-should-run-a-node">Why you should run a node</a></h2>
<p>Running a node in the Pollen testnet helps us in the following ways:</p>
<ul>
<li>It increases the amount of nodes in the network and thus lets it form a more realistic network.</li>
<li>Your node will be configured to send debug log messages to a centralized logger from which we can assess and debug research questions and occurring problems.</li>
<li>Your node is configured to send metric data to a centralized analysis server where we store information such as resource consumption, traffic, FPC vote context processing and so on. This data helps us further fostering the development of GoShimmer and assessing network behavior.</li>
<li>If you expose your HTTP API port, you provide an entrypoint for other people to interact with the network.</li>
</ul>
<blockquote>
<p>Note that any metric data is anonymous.</p>
</blockquote>
<h2 id="installing-goshimmer-with-docker"><a class="header" href="#installing-goshimmer-with-docker">Installing GoShimmer with Docker</a></h2>
<h4 id="hardware-requirements"><a class="header" href="#hardware-requirements">Hardware Requirements</a></h4>
<blockquote>
<p>Note that we do not provide a Docker image or binaries for ARM based systems such as Raspberry Pis.</p>
</blockquote>
<p>We recommend running GoShimmer on a x86 VPS with following minimum hardware specs:</p>
<ul>
<li>2 cores / 4 threads</li>
<li>4 GB of memory</li>
<li>40 GB of disk space</li>
</ul>
<p>A cheap <a href="https://www.hetzner.de/cloud">CX21 Hetzner instance</a> is thereby sufficient.</p>
<p>If you plan on running your GoShimmer node from home, please only do so if you know how to properly configure NAT on your router, as otherwise your node will not correctly participate in the network.</p>
<hr />
<blockquote>
<p>In the following sections we are going to use a CX21 Hetzner instance with Ubuntu 20.04 while being logged in as root</p>
</blockquote>
<p>Lets first upgrade the packages on our system:</p>
<pre><code>$ apt update &amp;&amp; apt dist-upgrade -y
</code></pre>
<h4 id="install-docker"><a class="header" href="#install-docker">Install Docker</a></h4>
<p>Install needed dependencies:</p>
<pre><code>$ apt-get install \
     apt-transport-https \
     ca-certificates \
     curl \
     gnupg-agent \
     software-properties-common
</code></pre>
<p>Add Docker’s official GPG key:</p>
<pre><code>$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | apt-key add -
</code></pre>
<p>Verify that the GPG key matches:</p>
<pre><code>$ apt-key fingerprint 0EBFCD88
pub   rsa4096 2017-02-22 [SCEA]
      9DC8 5822 9FC7 DD38 854A  E2D8 8D81 803C 0EBF CD88
uid           [ unknown] Docker Release (CE deb) &lt;docker@docker.com&gt;
sub   rsa4096 2017-02-22 [S]

</code></pre>
<p>Add the actual repository:</p>
<pre><code>$ add-apt-repository \
   &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu \
   $(lsb_release -cs) \
   stable&quot;
</code></pre>
<p>Update the package index:</p>
<pre><code>$ apt-get update
</code></pre>
<p>And finally, install docker:</p>
<pre><code>$ apt-get install docker-ce docker-ce-cli containerd.io
</code></pre>
<p>On windows-subsystem for Linux (WSL2) it may be necessary to start docker seperately:</p>
<pre><code>$ /etc/init.d/docker start
</code></pre>
<p>Note, this may not work on WSL1.</p>
<p>Check whether docker is running by executing <code>docker ps</code>:</p>
<pre><code>$ docker ps
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
</code></pre>
<h3 id="install-docker-compose"><a class="header" href="#install-docker-compose">Install Docker Compose</a></h3>
<p>Docker compose gives us the ability to define our services with <code>docker-compose.yml</code> files instead of having to define all container parameters directly on the CLI.</p>
<p>Download docker compose:</p>
<pre><code>$ curl -L &quot;https://github.com/docker/compose/releases/download/1.26.0/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose
</code></pre>
<p>Make it executable:</p>
<pre><code>$ chmod +x /usr/local/bin/docker-compose
</code></pre>
<p>Check that docker compose works:</p>
<pre><code>$ docker-compose --version
docker-compose version 1.26.0, build d4451659
</code></pre>
<h3 id="define-the-docker-composeyml"><a class="header" href="#define-the-docker-composeyml">Define the docker-compose.yml</a></h3>
<p>First, lets create a user defined bridged network. Unlike the already existing <code>bridge</code> network, the user defined one will have container name DNS resolution for containers within that network. This is useful if later we want to setup additional containers which need to speak with the GoShimmer container.</p>
<pre><code>$ docker network create --driver=bridge shimmer
c726034d295c3df66803b92c71ca517a0cf0e3c65c1c6d84ee5fa34ae76cbcd4
</code></pre>
<p>Lets create a folder holding our <code>docker-compose.yml</code>:</p>
<pre><code>$ mkdir /opt/goshimmer
</code></pre>
<p>Lets create a folder holding our database:</p>
<pre><code>$ cd /opt/goshimmer
$ mkdir db
$ chmod 0777 db
</code></pre>
<p>Finally, lets create our <code>docker-compose.yml</code>:</p>
<pre><code>$ nano docker-compose.yml
</code></pre>
<p>and add following content:</p>
<pre><code class="language-yaml">version: '3.3'

networks:
  outside:
    external:
      name: shimmer

services:
  goshimmer:
    image: iotaledger/goshimmer:latest
    container_name: goshimmer
    hostname: goshimmer
    stop_grace_period: 2m
    volumes:
      - &quot;./db:/tmp/mainnetdb:rw&quot;   
      - &quot;/etc/localtime:/etc/localtime:ro&quot;
    ports:
      # Autopeering 
      - &quot;0.0.0.0:14626:14626/udp&quot;
      # Gossip
      - &quot;0.0.0.0:14666:14666/tcp&quot;
      # FPC
      - &quot;0.0.0.0:10895:10895/tcp&quot;
      # HTTP API
      - &quot;0.0.0.0:8080:8080/tcp&quot;
      # Dashboard
      - &quot;0.0.0.0:8081:8081/tcp&quot;
      # pprof profiling
      - &quot;0.0.0.0:6061:6061/tcp&quot;
    environment:
      - ANALYSIS_CLIENT_SERVERADDRESS=ressims.iota.cafe:21888
      - AUTOPEERING_PORT=14626
      - DASHBOARD_BINDADDRESS=0.0.0.0:8081
      - GOSSIP_PORT=14666
      - WEBAPI_BINDADDRESS=0.0.0.0:8080
      - PROFILING_BINDADDRESS=0.0.0.0:6061
      - NETWORKDELAY_ORIGINPUBLICKEY=9DB3j9cWYSuEEtkvanrzqkzCQMdH1FGv3TawJdVbDxkd
      - FPC_BINDADDRESS=0.0.0.0:10895
      - PROMETHEUS_BINDADDRESS=0.0.0.0:9311
    command: &gt;
      --skip-config=true
      --autopeering.entryNodes=2PV5487xMw5rasGBXXWeqSi4hLz7r19YBt8Y1TGAsQbj@ressims.iota.cafe:15626,5EDH4uY78EA6wrBkHHAVBWBMDt7EcksRq6pjzipoW15B@entryshimmer.tanglebay.com:14646
      --node.disablePlugins=
      --node.enablePlugins=remotelog,networkdelay,spammer,prometheus
      --logger.level=info
      --logger.disableEvents=false
      --logger.remotelog.serverAddress=ressims.iota.cafe:5213
      --drng.pollen.instanceId=1
      --drng.pollen.threshold=3
      --drng.pollen.committeeMembers=AheLpbhRs1XZsRF8t8VBwuyQh9mqPHXQvthV5rsHytDG,FZ28bSTidszUBn8TTCAT9X1nVMwFNnoYBmZ1xfafez2z,GT3UxryW4rA9RN9ojnMGmZgE2wP7psagQxgVdA4B9L1P,4pB5boPvvk2o5MbMySDhqsmC2CtUdXyotPPEpb7YQPD7,64wCsTZpmKjRVHtBKXiFojw7uw3GszumfvC4kHdWsHga
      --drng.xteam.instanceId=1339
      --drng.xteam.threshold=4
      --drng.xteam.committeeMembers=GUdTwLDb6t6vZ7X5XzEnjFNDEVPteU7tVQ9nzKLfPjdo,68vNzBFE9HpmWLb2x4599AUUQNuimuhwn3XahTZZYUHt,Dc9n3JxYecaX3gpxVnWb4jS3KVz1K1SgSK1KpV1dzqT1,75g6r4tqGZhrgpDYZyZxVje1Qo54ezFYkCw94ELTLhPs,CN1XLXLHT9hv7fy3qNhpgNMD6uoHFkHtaNNKyNVCKybf,7SmttyqrKMkLo5NPYaiFoHs8LE6s7oCoWCQaZhui8m16,CypSmrHpTe3WQmCw54KP91F5gTmrQEL7EmTX38YStFXx
    networks:
      - outside
</code></pre>
<blockquote>
<p>If performance is a concern, you can also run your containers with <code>network_mode: &quot;host&quot;</code>, however, you must then adjust the hostnames in the configs for the corresponding containers and perhaps also create some iptable rules to block traffic from outside accessing your services directly.</p>
</blockquote>
<p>Note how we are setting up NATs for different ports:</p>
<table><thead><tr><th>Port</th><th>Functionality</th><th>Protocol</th></tr></thead><tbody>
<tr><td>14626</td><td>Autopeering</td><td>UDP</td></tr>
<tr><td>14666</td><td>Gossip</td><td>TCP</td></tr>
<tr><td>10895</td><td>FPC</td><td>TCP/HTTP</td></tr>
<tr><td>8080</td><td>HTTP API</td><td>TCP/HTTP</td></tr>
<tr><td>8081</td><td>Dashboard</td><td>TCP/HTTP</td></tr>
<tr><td>6061</td><td>pprof HTTP API</td><td>TCP/HTTP</td></tr>
</tbody></table>
<p>It is important that the ports are correctly mapped so that the node for example actively participates in FPC votes or can gain inbound neighbors.</p>
<blockquote>
<p>If the UDP NAT mapping is not configured correctly, GoShimmer will terminate with an error message stating to check the NAT configuration</p>
</blockquote>
<h2 id="running-the-goshimmer-node"><a class="header" href="#running-the-goshimmer-node">Running the GoShimmer node</a></h2>
<p>Within the <code>/opt/goshimmer</code> folder where the <code>docker-compose.yml</code> resides, simply execute:</p>
<pre><code>$ docker-compose up -d
Pulling goshimmer (iotaledger/goshimmer:0.2.0)...
...
</code></pre>
<p>to start the GoShimmer node.</p>
<p>You should see your container running now:</p>
<pre><code>CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                                                                                                                                    NAMES
687f52b78cb5        iotaledger/goshimmer:0.2.0       &quot;/run/goshimmer --sk…&quot;   19 seconds ago      Up 17 seconds       0.0.0.0:6061-&gt;6061/tcp, 0.0.0.0:8080-8081-&gt;8080-8081/tcp, 0.0.0.0:10895-&gt;10895/tcp, 0.0.0.0:14666-&gt;14666/tcp, 0.0.0.0:14626-&gt;14626/udp   goshimmer
</code></pre>
<p>You can follow the log output of the node via:</p>
<pre><code>$ docker logs -f --since=1m goshimmer
</code></pre>
<h3 id="syncing"><a class="header" href="#syncing">Syncing</a></h3>
<p>When the node starts for the first time, it must synchronize its state with the rest of the network. GoShimmer currently uses a sync beacon mechanism to help nodes determine their synced status and help syncing messages.</p>
<p>Follow these links to learn more about <a href="https://github.com/iotaledger/goshimmer/wiki/How-to-run-a-sync-beacon#what-is-a-sync-beacon">how sync beacons work, why you should run sync beacons</a> on your node and how to <a href="https://github.com/iotaledger/goshimmer/wiki/How-to-configure-followed-sync-beacon-nodes">configure your node to listen to certain sync beacons</a>.</p>
<h4 id="dashboard"><a class="header" href="#dashboard">Dashboard</a></h4>
<p>The dashboard of your GoShimmer node should be accessible via <code>http://&lt;your-ip&gt;:8081</code>. If your node is still synchronizing, you might see a higher inflow of MPS.</p>
<p><img src="https://i.imgur.com/8xAvi7X.png" alt="" /></p>
<p>After a while, your node's dashboard should also display up to 8 neighbors:
<img src="https://i.imgur.com/gAyAXK9.png" alt="" /></p>
<h4 id="http-api"><a class="header" href="#http-api">HTTP API</a></h4>
<p>GoShimmer also exposes an HTTP API. To check whether that works correctly, you can access it via <code>http://&lt;your-ip&gt;:8080/info</code> which should return a JSON response in the form of:</p>
<pre><code>{
  &quot;version&quot;: &quot;v0.2.0&quot;,
  &quot;synced&quot;: true,
  &quot;identityID&quot;: &quot;69RxiehGQ2c&quot;,
  &quot;publicKey&quot;: &quot;52Gzw9bo7k2dARFi4yxtt3B8xMht5UeFQX7pWdLFnxV5&quot;,
  &quot;enabledPlugins&quot;: [
    &quot;Analysis-Client&quot;,
    &quot;Autopeering&quot;,
    &quot;CLI&quot;,
    &quot;Config&quot;,
    &quot;DRNG&quot;,
    &quot;Dashboard&quot;,
    &quot;Database&quot;,
    &quot;Gossip&quot;,
    ...
    &quot;WebAPI info Endpoint&quot;,
    &quot;WebAPI message Endpoint&quot;
  ],
  &quot;disabledPlugins&quot;: [
    &quot;Analysis-Dashboard&quot;,
    &quot;Analysis-Server&quot;,
    &quot;Banner&quot;,
    &quot;Bootstrap&quot;,
    &quot;Faucet&quot;,
    &quot;WebAPI Auth&quot;
  ]
}
</code></pre>
<h2 id="managing-the-goshimmer-node-lifecycle"><a class="header" href="#managing-the-goshimmer-node-lifecycle">Managing the GoShimmer node lifecycle</a></h2>
<h5 id="stopping-the-node"><a class="header" href="#stopping-the-node">Stopping the node</a></h5>
<pre><code>$ docker-compose stop
</code></pre>
<h5 id="resetting-the-node"><a class="header" href="#resetting-the-node">Resetting the node</a></h5>
<pre><code>$ docker-compose down
</code></pre>
<h5 id="upgrading-the-node"><a class="header" href="#upgrading-the-node">Upgrading the node</a></h5>
<p><strong>Ensure that the image version in the <code>docker-compose.yml</code> is <code>latest</code></strong> then execute following commands:</p>
<pre><code>$ docker-compose down
$ rm db/*
$ docker-compose pull
$ docker-compose up -d
</code></pre>
<h5 id="following-log-output"><a class="header" href="#following-log-output">Following log output</a></h5>
<pre><code>$ docker logs -f --since=1m goshimmer
</code></pre>
<h5 id="create-a-logtxt"><a class="header" href="#create-a-logtxt">Create a log.txt</a></h5>
<pre><code>$ docker logs goshimmer &gt; log.txt
</code></pre>
<h5 id="update-grafana-dashboard"><a class="header" href="#update-grafana-dashboard">Update Grafana Dashboard</a></h5>
<p>If you set up the Grafana dashboard for your node according to the next section &quot;Setting up the Grafana dashboard&quot;, the following method will help you to update when a new version is released.</p>
<p>You have to manually copy the new <a href="https://github.com/iotaledger/goshimmer/blob/master/tools/monitoring/grafana/dashboards/local_dashboard.json">dashboard file</a> into <code>/opt/goshimmer/grafana/dashboards</code> directory.
Supposing you are at <code>/opt/goshimmer/</code>:</p>
<pre><code>$ wget https://raw.githubusercontent.com/iotaledger/goshimmer/master/tools/monitoring/grafana/dashboards/local_dashboard.json
$ cp local_dashboard.json grafana/dashboards
</code></pre>
<p>Restart the grafana container:</p>
<pre><code>$ docker restart grafana
</code></pre>
<h2 id="setting-up-the-grafana-dashboard"><a class="header" href="#setting-up-the-grafana-dashboard">Setting up the Grafana dashboard</a></h2>
<h4 id="add-prometheus-and-grafana-containers-to-docker-composeyml"><a class="header" href="#add-prometheus-and-grafana-containers-to-docker-composeyml">Add Prometheus and Grafana Containers to <code>docker-compose.yml</code></a></h4>
<p>Append the following to the previously described <code>docker-compose.yml</code> file (<strong>make sure to also copy the space in front of &quot;prometheus&quot;/the entire whitespace</strong>):</p>
<pre><code class="language-yaml">  prometheus:
    image: prom/prometheus:latest
    container_name: prometheus
    restart: unless-stopped
    ports:
      - &quot;9090:9090/tcp&quot;
    command:
      - --config.file=/etc/prometheus/prometheus.yml
    volumes:
      - ./prometheus/prometheus.yml:/etc/prometheus/prometheus.yml:ro
      - ./prometheus/data:/prometheus:rw
    depends_on:
      - goshimmer
    networks:
      - outside

  grafana:
    image: grafana/grafana:latest
    container_name: grafana
    restart: unless-stopped
    environment:
      # path to provisioning definitions can only be defined as
      # environment variables for grafana within docker
      - GF_PATHS_PROVISIONING=/var/lib/grafana/provisioning
    ports:
      - &quot;3000:3000/tcp&quot;
    user: &quot;472&quot;
    volumes:
      - ./grafana:/var/lib/grafana:rw
    networks:
      - outside
</code></pre>
<h4 id="create-prometheus-config"><a class="header" href="#create-prometheus-config">Create Prometheus config</a></h4>
<ol>
<li>Create a <code>prometheus/data</code> directory in <code>/opt/goshimmer</code>:</li>
</ol>
<pre><code>$ cd /opt/goshimmer
$ mkdir -p prometheus/data
</code></pre>
<ol start="2">
<li>Create a <code>prometheus.yml</code> in <code>prometheus</code> directory:</li>
</ol>
<pre><code>$ nano prometheus/prometheus.yml
</code></pre>
<p>The content of the file should be:</p>
<pre><code class="language-yaml">scrape_configs:
    - job_name: goshimmer_local
      scrape_interval: 5s
      static_configs:
      - targets:
        - goshimmer:9311
</code></pre>
<ol start="3">
<li>Add permissions to <code>prometheus</code> config directory:</li>
</ol>
<pre><code>$ chmod -R 777 prometheus
</code></pre>
<h4 id="create-grafana-configs"><a class="header" href="#create-grafana-configs">Create Grafana configs</a></h4>
<ol>
<li>Create necessary config dirs in <code>/opt/goshimmer/</code>.</li>
</ol>
<pre><code>$ mkdir -p grafana/provisioning/datasources grafana/provisioning/dashboards grafana/provisioning/notifiers
$ mkdir -p grafana/dashboards
</code></pre>
<ol start="2">
<li>Create a datasource configuration file in <code>grafana/provisioning/datasources</code>:</li>
</ol>
<pre><code>$ nano grafana/provisioning/datasources/datasources.yaml
</code></pre>
<p>With the following content:</p>
<pre><code class="language-yaml">apiVersion: 1

datasources:
  - name: Prometheus
    type: prometheus
    # &lt;string, required&gt; access mode. proxy or direct (Server or Browser in the UI). Required
    access: proxy
    orgId: 1
    url: http://prometheus:9090
    jsonData:
      graphiteVersion: '1.1'
      timeInterval: '1s'
    # &lt;string&gt; json object of data that will be encrypted.
    secureJsonData:
      # &lt;string&gt; database password, if used
      password:
      # &lt;string&gt; basic auth password
      basicAuthPassword:
    version: 1
    # &lt;bool&gt; allow users to edit datasources from the UI.
    editable: true
</code></pre>
<ol start="3">
<li>Create a dashboard configuration file in <code>grafana/provisioning/dashboards</code>:</li>
</ol>
<pre><code>$ nano grafana/provisioning/dashboards/dashboards.yaml
</code></pre>
<p>With the following content:</p>
<pre><code class="language-yaml">apiVersion: 1

providers:
  - name: 'Goshimmer Local Metrics'
    orgId: 1
    folder: ''
    type: file
    disableDeletion: false
    editable: true
    updateIntervalSeconds: 10
    allowUiUpdates: true
    options:
      path: /var/lib/grafana/dashboards
</code></pre>
<ol start="4">
<li>Add predefined Goshimmer Local Metrics Dashboard.</li>
</ol>
<p>Head over to the GoShimmer repository and download <a href="https://github.com/iotaledger/goshimmer/blob/master/tools/monitoring/grafana/dashboards/local_dashboard.json">local_dashboard.json</a>.</p>
<pre><code>$ wget https://raw.githubusercontent.com/iotaledger/goshimmer/master/tools/monitoring/grafana/dashboards/local_dashboard.json
$ cp local_dashboard.json grafana/dashboards
</code></pre>
<ol start="5">
<li>Add permissions to Grafana config folder</li>
</ol>
<pre><code>$ chmod -R 777 grafana
</code></pre>
<h4 id="run-goshimmer-with-prometheus-and-grafana"><a class="header" href="#run-goshimmer-with-prometheus-and-grafana">Run GoShimmer with Prometheus and Grafana:</a></h4>
<pre><code>$ docker-compose up -d
</code></pre>
<p>The Grafana dashboard should be accessible at <code>http://&lt;your-ip&gt;:3000</code>.</p>
<p>Default login credentials are:</p>
<ul>
<li><code>username</code>: admin</li>
<li><code>password</code>: admin</li>
</ul>
<h1 id="how-to-obtain-tokens-from-the-faucet"><a class="header" href="#how-to-obtain-tokens-from-the-faucet">How to obtain tokens from the faucet</a></h1>
<h2 id="the-faucet-dapp"><a class="header" href="#the-faucet-dapp">The faucet dApp</a></h2>
<p>The faucet is a dApp built on top of the <a href="https://github.com/iotaledger/goshimmer/wiki/Layers#value-layer">value-</a> and <a href="https://github.com/iotaledger/goshimmer/wiki/Layers#communication-layer">communication layer</a>. It sends IOTA tokens to addresses by listening to faucet request messages. A faucet message is a Message containing an address encoded in Base58, and it is retrievable via <a href="https://github.com/iotaledger/goshimmer/wiki/Client-Lib:-Interaction-with-layers#retrieve-messages"><code>FindMessageByID()</code></a>.
After sending a faucet request message, you can check your balances via <a href="https://github.com/iotaledger/goshimmer/wiki/Client-Lib:-Interaction-with-layers#retrieve-utxosbalances"><code>GetUnspentOutputs()</code></a>.</p>
<h2 id="obtain-tokens-from-the-faucet"><a class="header" href="#obtain-tokens-from-the-faucet">Obtain tokens from the faucet</a></h2>
<p>There are 3 ways to send a faucet request message to obtain IOTA tokens:</p>
<ol>
<li>Via the Go client library</li>
<li>Via the HTTP API directly</li>
<li>Requesting tokens via the GoShimmer web dashboard</li>
<li>Via the wallet</li>
</ol>
<h3 id="via-the-go-client-library"><a class="header" href="#via-the-go-client-library">Via the Go client library</a></h3>
<p>Follow the instructions in <a href="https://github.com/iotaledger/goshimmer/wiki/Client-Lib:-Interaction-with-layers#use-the-api">Use the API</a> to set up the API instance. </p>
<p>Example:</p>
<pre><code>// provide your Base58 encoded destination address
messageID, err := goshimAPI.SendFaucetRequest(&quot;JaMauTaTSVBNc13edCCvBK9fZxZ1KKW5fXegT1B7N9jY&quot;)

---- or

// get the given address from your wallet instance and 
// use String() to get its Base58 representation
addr := wallet.Seed().Address(0)
messageID, err := goshimAPI.SendFaucetRequest(addr.String())
</code></pre>
<h3 id="via-the-http-api-directly"><a class="header" href="#via-the-http-api-directly">Via the HTTP API directly</a></h3>
<p>The URI for POSTing faucet request messages is <code>http://&lt;host&gt;:&lt;web-api-port&gt;/faucet</code></p>
<table><thead><tr><th>Parameter</th><th>Required</th><th>Description</th><th>Type</th></tr></thead><tbody>
<tr><td><code>address</code></td><td>Yes</td><td>Destination address to which to send tokens to encoded in Base58</td><td>string</td></tr>
</tbody></table>
<p>cURL example:</p>
<pre><code>curl http://localhost:8080 \
-X POST \
-H 'Content-Type: application/json' \
-d '{
  &quot;address&quot;: &quot;JaMauTaTSVBNc13edCCvBK9fZxZ1KKW5fXegT1B7N9jY&quot;
}'
</code></pre>
<h3 id="requesting-tokens-via-the-goshimmer-web-dashboard"><a class="header" href="#requesting-tokens-via-the-goshimmer-web-dashboard">Requesting tokens via the GoShimmer web dashboard</a></h3>
<p>You can send the faucet request message via the faucet tab on the dashboard by filling in a Base58 encoded address to receive tokens.</p>
<p>You can then use the link provided below to check the funds on your supplied address.</p>
<img src="https://user-images.githubusercontent.com/11289354/85510396-d9127000-b629-11ea-8d5c-d5bb10d7c34a.png" width="650">
<h3 id="via-the-wallet"><a class="header" href="#via-the-wallet">Via the wallet</a></h3>
<p>Currently, there are two GUI wallets to use, one from the community member <a href="https://github.com/Dr-Electron/ElectricShimmer">Dr-Electron ElectricShimmer</a> and another from the foundation <a href="https://github.com/iotaledger/pollen-wallet/tree/master">pollen-wallet</a>. You can request funds from the faucet with these two implementations.</p>
<p>As for pollen-wallet, follow the instructions in <a href="https://github.com/iotaledger/pollen-wallet/tree/master">pollen-wallet</a> to build and execute the wallet.</p>
<p>You can request funds by pressing the <code>Request Funds</code> in the wallet.</p>
<p><strong>Note</strong>: You need to create a wallet first before requesting funds.</p>
<img src="https://user-images.githubusercontent.com/11289354/88524828-70edea00-d02c-11ea-9a01-d7e1a8b7bdfd.png" height="450">
<p>This may take a while to receive funds:</p>
<img src="https://user-images.githubusercontent.com/11289354/88525200-e0fc7000-d02c-11ea-9f7f-a545cf14b318.png" width="450">
<p>When the faucet request is successful, you can check the received balances:</p>
<img src="https://user-images.githubusercontent.com/11289354/88525478-38024500-d02d-11ea-92c7-25c80eb6a947.png" width="450">
<h1 id="the-wallet-library"><a class="header" href="#the-wallet-library">The wallet library</a></h1>
<p>This page describes how to use the wallet library.</p>
<p>GoShimmer ships with a very basic wallet library so that developers and testers can use it to move tokens around.</p>
<p>To demonstrate its functionalities we have developed a simple command line interface (cli-wallet). 
You can have a look at its source code to have an idea about how the wallet library can be used. </p>
<p>The cli-wallet supports the following commands:</p>
<img src="https://user-images.githubusercontent.com/11289354/88368467-b8703e00-cdc0-11ea-83b2-757c8b9e25c8.png" height="400">
<h1 id="how-to-create-a-simple-dapp"><a class="header" href="#how-to-create-a-simple-dapp">How to create a simple dApp</a></h1>
<blockquote>
<p>This guide is meant for developers familiar with the Go programming language.</p>
</blockquote>
<blockquote>
<p><strong>DISCLAIMER:</strong> GoShimmer is a rapidly evolving prototype software. As such, the described steps here will likely change in the future. Specifically, we are envisioning to ease the process of dApp creation and installation for node owners. Furthermore, the current approach is in no way hardened and should be seen as purely experimental. Do not write any software for actual production use.</p>
</blockquote>
<h2 id="network-delay-dapp"><a class="header" href="#network-delay-dapp">Network Delay dApp</a></h2>
<p>In this guide we are going to explain how to write a very simple dApp based on an actual dApp we are using in GoShimmer to help us measure the network delay, i.e., how long it takes for every active node in the network to receive a message. Gathering this data will enable us to set realistic parameters for FCoB.</p>
<p>The complete source code of the application can be found <a href="https://github.com/iotaledger/goshimmer/tree/develop/dapps/networkdelay">in the repository</a>. </p>
<h3 id="overview-9"><a class="header" href="#overview-9">Overview</a></h3>
<p>Our network delay dApp should help us to identify the time it takes for every active node to receive and process a message. That can be done in a few simple steps:</p>
<ol>
<li>A (known) node sends a special message containing a network delay object.</li>
<li>Upon receipt, every other node in the network answers to the special message by posting its current time to our remote logger.</li>
<li>For simplicity we gather the information in an <a href="https://www.elastic.co/what-is/elk-stack">ELK stack</a>. This helps us to easily interpret and analyze the data.</li>
</ol>
<p>Within GoShimmer we need 3 components to realize this undertaking. First, we need to <strong>define and register a network delay object type</strong>. Second, we need a way to <strong>initiate a message</strong> with a network delay object via the web API. And lastly, we need to <strong>listen</strong> for network delay objects and take appropriate action.</p>
<p>If a node does not have our dApp installed and activated, the message will be simply treated as a raw data message without any particular meaning. In general that means that in order for a dApp to be useful, node owners need to explicitly install it. In our case we simply ship it with GoShimmer.</p>
<h3 id="define--register-the-network-delay-object"><a class="header" href="#define--register-the-network-delay-object">Define &amp; Register The Network Delay Object</a></h3>
<p>First, we need to decide what data our network delay object should contain and define the byte layout accordingly.
In our case we need an <code>ID</code> to identify a network delay message and the <code>sent time</code> of the initiator. 
Therefore, we can define the byte layout as follows:</p>
<pre><code>type&lt;uint32-4bytes&gt; // every object has to have this
length&lt;uint32-4bytes&gt; // every object has to have this
id&lt;32bytes&gt;
sentTime&lt;int64-8bytes&gt;
</code></pre>
<p>Next, we need to fulfill the <code>Payload</code> interface and provide the functionality to read/write an object from/to bytes. The <a href="https://github.com/iotaledger/hive.go/tree/master/marshalutil"><code>hive.go/marshalutil</code></a> package simplifies this step tremendously.</p>
<pre><code class="language-Go">type Payload interface {
	// Type returns the type of the payload.
	Type() Type
	// Bytes returns the payload bytes.
	Bytes() []byte
	// Unmarshal unmarshals the payload from the given bytes.
	Unmarshal(bytes []byte) error
	// String returns a human-friendly representation of the payload.
	String() string
}
</code></pre>
<p>Finally, we need to register our network delay object type so that it can be properly unmarshalled. </p>
<pre><code class="language-Go">func init() {
	payload.RegisterType(Type, func(data []byte) (payload payload.Payload, err error) {
		payload = &amp;Object{}
		err = payload.Unmarshal(data)

		return
	})
}
</code></pre>
<h3 id="create-the-web-api-endpoints"><a class="header" href="#create-the-web-api-endpoints">Create The Web API Endpoints</a></h3>
<p>In order to issue a message with our newly created network delay object, we need to create a web API endpoint. Here we simply create a random <code>ID</code> and the <code>sentTime</code> and then issue a message with <code>issuer.IssuePayload()</code>. This plugin takes care of all the specifics and employs the <code>MessageFactory</code> to, i.a., select tips and sign the message.</p>
<pre><code class="language-Go">webapi.Server.POST(&quot;networkdelay&quot;, broadcastNetworkDelayObject)

func broadcastNetworkDelayObject(c echo.Context) error {
	// generate random id
	rand.Seed(time.Now().UnixNano())
	var id [32]byte
	if _, err := rand.Read(id[:]); err != nil {
		return c.JSON(http.StatusInternalServerError, Response{Error: err.Error()})
	}

	msg, err := issuer.IssuePayload(NewObject(id, time.Now().UnixNano()))
	if err != nil {
		return c.JSON(http.StatusBadRequest, Response{Error: err.Error()})
	}
	return c.JSON(http.StatusOK, Response{ID: msg.Id().String()})
}
</code></pre>
<h3 id="listen-for-network-delay-objects"><a class="header" href="#listen-for-network-delay-objects">Listen for network delay objects</a></h3>
<p>Every dApp listens for messages from the <em>communication layer</em> and when its data type is detected, takes appropriate action. For us that means listening for network delay objects and sending messages to our remote logger if we encounter any. Of course in this context, we only want to react to network delay objects which were issued by our analysis/entry node server. Therefore, matching the message signer's public key with a configured public key lets us only react to the appropriate network delay objects.</p>
<pre><code class="language-Go">// subscribe to message-layer
messagelayer.Tangle.Events.MessageSolid.Attach(events.NewClosure(onReceiveMessageFromMessageLayer))

func onReceiveMessageFromMessageLayer(cachedMessage *message.CachedMessage, cachedMessageMetadata *messageTangle.CachedMessageMetadata) {
	defer cachedMessage.Release()
	defer cachedMessageMetadata.Release()

	solidMessage := cachedMessage.Unwrap()
	if solidMessage == nil {
		log.Debug(&quot;failed to unpack solid message from message layer&quot;)

		return
	}

	messagePayload := solidMessage.Payload()
	if messagePayload.Type() != Type {
		return
	}

	// check for node identity -&gt; only answer if it's send from a configured node
	issuerPubKey := solidMessage.IssuerPublicKey()
	if issuerPubKey != originPublicKey || issuerPubKey == myPublicKey {
		return
	}

	// make sure we really got a message with our type. 
	// since we are in a distributed setting anyone could send a message with our type id and put other data in it.
	networkDelayObject, ok := messagePayload.(*Object)
	if !ok {
		log.Info(&quot;could not cast payload to network delay object&quot;)

		return
	}

	now := time.Now().UnixNano()

	sendToRemoteLog(networkDelayObject, now)
}
</code></pre>
<h1 id="how-to-run-a-sync-beacon"><a class="header" href="#how-to-run-a-sync-beacon">How to run a sync beacon</a></h1>
<h2 id="what-is-a-sync-beacon"><a class="header" href="#what-is-a-sync-beacon">What is a sync beacon?</a></h2>
<p>A sync beacon is a special type of payload in the message tangle. It contains the unix timestamp of issuance of the beacon. Node owners may configure their nodes to distribute such sync beacons periodically to the network. Followers can listen to sync beacons issued by a particular set of nodes, and derive their <code>synced</code> status based on if they are able to solidify the messages containing those sync beacons.</p>
<h2 id="why-should-i-run-a-sync-beacon"><a class="header" href="#why-should-i-run-a-sync-beacon">Why should I run a sync beacon?</a></h2>
<p>Simply put: the more sync beacons there are in the network, the easier it is for followers to accurately determine their synced status.</p>
<p>Followers are free to choose which nodes to follow, and to what percentage of the nodes they need to be synced to, in order to consider themselves synced. The correct determination of the <code>synced</code> state is not only important for knowing the current status of your node, but also to build a healthy Tangle. You want to attach messages to recent tips, tips that are also known to others in the network, which you only know by being in sync with them.</p>
<h2 id="how-to-enable-the-sync-beacon-plugin"><a class="header" href="#how-to-enable-the-sync-beacon-plugin">How to enable the sync beacon plugin?</a></h2>
<p>All you need to do is enable the <code>syncbeacon</code> plugin in your node config. To do it via <code>config.json</code>, add it to the list of enabled plugins:</p>
<pre><code>  &quot;node&quot;: {
    &quot;disablePlugins&quot;: [],
    &quot;enablePlugins&quot;: [&quot;syncbeacon&quot;]
  },
</code></pre>
<p>You may also configure how often your node should send a sync beacon with <code>broadcastInterval</code> (seconds):</p>
<pre><code>...
  },
  &quot;syncbeacon&quot;: {
    &quot;broadcastInterval&quot;: 30
  },
...
</code></pre>
<h1 id="how-to-configure-followed-sync-beacon-nodes"><a class="header" href="#how-to-configure-followed-sync-beacon-nodes">How to configure followed sync beacon nodes</a></h1>
<h2 id="why-do-you-need-to-follow-sync-beacons"><a class="header" href="#why-do-you-need-to-follow-sync-beacons">Why do you need to follow sync beacons?</a></h2>
<p><a href="https://github.com/iotaledger/goshimmer/wiki/How-to-run-a-sync-beacon#what-is-a-sync-beacon">Sync beacons</a> help your node to determine its synced status. To conclude that your node has the same view on the Tangle in a fully decentralized network, you have to rely on information coming from your peers. Sync beacons are part of the mechanism that lets you do exactly this.</p>
<p>You listen to sync beacons in the message Tangle from your choice of nodes, and try to solidify them. If successfully done within a predefined time window, you conclude that your node is <code>synced</code> compared to the node that issued the sync beacon. Since you can follow an arbitrary number of sync beacon nodes, your <code>own synced</code> status is determined as a quorum of your <code>synced</code> status compared to others. The quorum size (in percentage) is configurable via config file or cli flags, but has to be within the [0.5, 1.0] interval. <code>0.5</code> means that you have to be in sync at least to half of the nodes you are following, <code>1.0</code> means that you have to be synced to all of them.</p>
<h2 id="follow-a-set-of-nodes"><a class="header" href="#follow-a-set-of-nodes">Follow a set of nodes</a></h2>
<p>To configure which nodes to follow, you have to specify their public key in your node's <code>config.json</code>:</p>
<pre><code>  &quot;syncbeaconfollower&quot;: {
    &quot;followNodes&quot;: [
      &quot;98u5J7Xz4CS6efttPGYLgetZCAmpXpNiUbhAP6mmUHfW&quot;,
      &quot;EpPTtBhkr1fAQJGTVqkE6XoSDeS5k5awEo7s4UeLSR2Y&quot;
    ]
  },
</code></pre>
<p>If you don't specify any nodes in your config, your node will only follow two predefined sync beacon nodes.</p>
<h2 id="configure-sync-quorum-size"><a class="header" href="#configure-sync-quorum-size">Configure sync quorum size</a></h2>
<p>To configure the quorum size, use the <code>syncPercentage</code> config parameter:</p>
<pre><code>  &quot;syncbeaconfollower&quot;: {
    &quot;followNodes&quot;: [
      &quot;98u5J7Xz4CS6efttPGYLgetZCAmpXpNiUbhAP6mmUHfW&quot;,
      &quot;EpPTtBhkr1fAQJGTVqkE6XoSDeS5k5awEo7s4UeLSR2Y&quot;
    ],
    &quot;syncPercentage&quot;: 0.8
  },
</code></pre>
<p>If you don't specify <code>syncPercentage</code> in your config, or it is outside the [0.5, 1.0] interval, the quorum size will default to <code>0.5</code> (50%).</p>
<h2 id="observe-synced-status-on-your-local-dashboard"><a class="header" href="#observe-synced-status-on-your-local-dashboard">Observe synced status on your local dashboard</a></h2>
<p>Your node dashboard will display the <code>synced</code> information related to the nodes that you follow. You can see the latest beacons which were used to derive the synced status, and the time of their issuance.</p>
<p><img src="https://i.imgur.com/4QXwhyJ.png" alt="Sync status on local dashboard" /></p>
<h1 id="create-a-static-identity"><a class="header" href="#create-a-static-identity">Create a static identity</a></h1>
<p>To create a static GoShimmer identity, you will need to generate a random 32byte autopeering seed. You can use <code>openssl</code> or the <code>rand-seed</code> tool we provide under the GoShimmer folder <code>tools/rand-seed</code>.
For example, by running:</p>
<ul>
<li><code>openssl rand -base64 32</code>: generates a random 32 byte sequence encoded in base64. The output should look like: <code>gP0uRLhwBG2yJJmnLySX4S4R5G250Z3dbN9yBR6VSyY=</code></li>
<li><code>go run main.go</code> under the GoShimmer folder <code>tools/rand-seed</code>: generates a random 32 byte sequence encoded in both base64 and base58. The output is written into the file <code>random-seed.txt</code> and should look like:</li>
</ul>
<pre><code>base64:nQW9MhNSLpIqBUiZe90XI320g680zxFoB1UIK09Acus=
base58:BZx5tDLymckUV5wiswXJtajgQrBEzTBBRR4uGfr1YNGS
</code></pre>
<p>You can now copy one of that strings (together with the encoding type prefix) and paste it into the GoShimmer <code>config.json</code> under the <code>autopeering</code> section:</p>
<pre><code>&quot;autopeering&quot;: {
    &quot;entryNodes&quot;: [
      &quot;2PV5487xMw5rasGBXXWeqSi4hLz7r19YBt8Y1TGAsQbj@ressims.iota.cafe:15626&quot;
    ],
    &quot;port&quot;: 14626,
    &quot;seed&quot;:&quot;base64:gP0uRLhwBG2yJJmnLySX4S4R5G250Z3dbN9yBR6VSyY=&quot;
  },
</code></pre>
<p>Or if you are using docker and prefer to set this with a command, you can define the same by changing the GoShimmer docker-compose.yml:</p>
<pre><code class="language-yml">goshimmer:
    network_mode: host
    image: iotaledger/goshimmer
    build:
      context: ./
      dockerfile: Dockerfile
    container_name: iota_goshimmer
    command: &gt;
      --node.enablePlugins=prometheus
      --autopeering.seed=&quot;base64:gP0uRLhwBG2yJJmnLySX4S4R5G250Z3dbN9yBR6VSyY=&quot;
    # Mount volumes:
    # make sure to give read/write access to the folder ./mainnetdb (e.g., chmod -R 777 ./mainnetdb)
    # optionally, you can mount a config.json into the container
    volumes:
      - ./mainnetdb/:/tmp/mainnetdb/:rw
      - ./config.json:/config.json:ro
    # Expose ports:
    # gossip:       - &quot;14666:14666/tcp&quot;
    # autopeering:  - &quot;14626:14626/udp&quot;
    # webAPI:       - &quot;8080:8080/tcp&quot;
    # dashboard:    - &quot;8081:8081/tcp&quot;
    ports:
      - &quot;14666:14666/tcp&quot;
      - &quot;14626:14626/udp&quot;
      - &quot;9311:9311/tcp&quot; # prometheus exporter
      - &quot;8080:8080/tcp&quot; # webApi
      - &quot;8081:8081/tcp&quot; # dashboard
</code></pre>
<h1 id="drng-api"><a class="header" href="#drng-api">dRNG API</a></h1>
<p>All the steps are described in the <a href="https://github.com/iotaledger/drng/wiki">dRNG wiki</a>.</p>
<h1 id="setting-up-monitoring-dashboard"><a class="header" href="#setting-up-monitoring-dashboard">Setting up Monitoring Dashboard</a></h1>
<h2 id="motivation"><a class="header" href="#motivation">Motivation</a></h2>
<p>GoShimmer is shipped with its internal node dashboard that you can reach at <code>127.0.0.1:8081</code> by default. While this dashboard provides some basic metrics information, its main functionality is to provide a graphical interface to interact with your node.</p>
<p>Node operators who wish to have more insights into what is happening within their node have the option to enable a <a href="https://prometheus.io/">Prometheus</a> exporter plugin that gathers important metrics about their node. To visualize these metrics, a <a href="https://grafana.com/oss/grafana/">Grafana Dashboard</a> is utilized.</p>
<h1 id="setting-up-run-goshimmer-from-a-vps"><a class="header" href="#setting-up-run-goshimmer-from-a-vps">Setting up (run Goshimmer from a VPS)</a></h1>
<p>To enable the <strong>Monitoring Dashboard</strong> for a GoShimmer node running from a VPS as described <a href="https://github.com/iotaledger/goshimmer/wiki/Setup-up-a-GoShimmer-node-(Joining-the-GoShimmer-testnet)">here</a>, you need to carry out some additional steps.</p>
<ol>
<li>Edit <code>docker-compose.yml</code>
TODO</li>
<li>Create Prometheus config.
TODO</li>
<li>Create Grafana config.
TODO</li>
<li>Run <code>docker-compose up</code>.
TODO</li>
</ol>
<h1 id="setting-up-run-goshimmer-from-your-home-machine"><a class="header" href="#setting-up-run-goshimmer-from-your-home-machine">Setting up (run Goshimmer from your home machine)</a></h1>
<p>Depending on how you run your GoShimmer node, there are different ways to set up the <strong>Monitoring Dashboard</strong>.</p>
<h2 id="docker-1"><a class="header" href="#docker-1">Docker</a></h2>
<p>One of the easiest ways to run a node is to use <a href="https://www.docker.com/">Docker</a>. To automatically launch GoShimmer and the Monitoring Dashboard with docker, follow these steps:</p>
<ol>
<li><a href="https://docs.docker.com/get-docker/">Install docker</a>. On Linux, make sure you install both the <a href="https://docs.docker.com/engine/install/">Docker Engine</a> and <a href="https://docs.docker.com/compose/install/">Docker Compose</a>.</li>
<li>Clone the GoShimmer repository.
<pre><code class="language-bash">$ git clone git@github.com:iotaledger/goshimmer.git
</code></pre>
</li>
<li>Create a <code>config.json</code> from the provided <code>config.default.json</code>.
<pre><code class="language-bash">$ cd goshimmer
$ cp config.default.json config.json
</code></pre>
Make sure, that following entry is present in <code>config.json</code>:
<pre><code class="language-json">  &quot;prometheus&quot;: {
    &quot;bindAddress&quot;: &quot;127.0.0.1:9311&quot;
  },
</code></pre>
</li>
<li>From the root of the repo, start GoShimmer with:
<pre><code class="language-bash">$ docker-compose up
</code></pre>
</li>
</ol>
<p>You should be able to reach the Monitoring Dashboard via browser at <a href="http://localhost:3000">localhost:3000</a>. Default login credentials are:</p>
<ul>
<li><code>username</code> : admin</li>
<li><code>password</code> : admin</li>
</ul>
<p>After initial login, you will be prompted to change your password.
You can experiment with the dashboard, change layout, add panels and discover metrics. Your changes will be saved into a Grafana database located in the repo at <code>tools/monitoring/grafana/grafana.db</code>.</p>
<h2 id="binary-1"><a class="header" href="#binary-1">Binary</a></h2>
<p>If you run the <a href="https://github.com/iotaledger/goshimmer/releases">released binaries</a>, or build GoShimmer from source, you need to setup Prometheus and Grafana separately, furthermore, you have to configure GoShimmer to export data.</p>
<h3 id="goshimmer-configuration"><a class="header" href="#goshimmer-configuration">Goshimmer Configuration</a></h3>
<ol>
<li>Make sure that the <code>prometheus.bindAddress</code> config parameter is set in your <code>config.json</code>:
<pre><code class="language-json">  &quot;prometheus&quot;: {
    &quot;bindAddress&quot;: &quot;127.0.0.1:9311&quot;
  },
</code></pre>
</li>
<li>Make sure, that the <code>prometheus</code> plugin is enabled in your <code>config.json</code>:
<pre><code class="language-json">&quot;node&quot;: {
  &quot;disablePlugins&quot;: [],
  &quot;enablePlugins&quot;: [&quot;prometheus&quot;]
},
</code></pre>
</li>
</ol>
<h3 id="install-and-configure-prometheus"><a class="header" href="#install-and-configure-prometheus">Install and Configure Prometheus</a></h3>
<p>First, we take a look on how to configure and run Prometheus as a standalone application. Then, we setup a Linux system service that automatically runs Prometheus in the background.</p>
<h4 id="prometheus-as-standalone-app"><a class="header" href="#prometheus-as-standalone-app">Prometheus as Standalone App</a></h4>
<ol>
<li><a href="https://prometheus.io/download/">Download</a> the latest release of Prometheus for your system.</li>
<li>Unpack the downloaded file:
<pre><code class="language-bash">$ tar xvfz prometheus-*.tar.gz
$ cd prometheus-*
</code></pre>
</li>
<li>Create a <code>prometheus.yml</code> in the unpacked directory with the following content:
<pre><code class="language-yaml">scrape_configs:
    - job_name: goshimmer_local
      scrape_interval: 5s
      static_configs:
      - targets:
        # goshimmer prometheus plugin export
        - 127.0.0.1:9311
</code></pre>
</li>
<li>Start Prometheus from the unpacked folder:
<pre><code class="language-bash"># By default, Prometheus stores its database in ./data (flag --storage.tsdb.path).
$ ./prometheus --config.file=prometheus.yml
</code></pre>
</li>
<li>You can access the prometheus server at <a href="http://localhost:9090">localhost:9090</a>.</li>
<li>(Optional) Prometheus server is running, but observe that <a href="http://localhost:9090/targets">localhost:9090/targets</a> shows the target being <code>DOWN</code>. Run GoShimmer with the configuration from the previous stage, and you will soon see the <code>goshimmer_local</code> target being <code>UP</code>.</li>
</ol>
<h4 id="prometheus-as-a-system-service-linux"><a class="header" href="#prometheus-as-a-system-service-linux">Prometheus as a System Service (Linux)</a></h4>
<p>Note: you have to have root privileges with your user to carry out the following steps.</p>
<ol>
<li>Create a Prometheus user, directories, and set this user as the owner of those directories.
<pre><code>$ sudo useradd --no-create-home --shell /bin/false prometheus
$ sudo mkdir /etc/prometheus
$ sudo mkdir /var/lib/prometheus
$ sudo chown prometheus:prometheus /etc/prometheus
$ sudo chown prometheus:prometheus /var/lib/prometheus
</code></pre>
</li>
<li>Download Prometheus source, extract and rename.
<pre><code>$ wget https://github.com/prometheus/prometheus/releases/download/v2.19.1/prometheus-2.19.1.linux-amd64.tar.gz
$ tar xvfz prometheus-2.19.1.linux-amd64.tar.gz
$ mv prometheus-2.19.1.linux-amd64.tar.gz prometheus-files
</code></pre>
</li>
<li>Copy Prometheus binaries to <code>/bin</code> and change their ownership
<pre><code>$ sudo cp prometheus-files/prometheus /usr/local/bin/
$ sudo cp prometheus-files/promtool /usr/local/bin/
$ sudo chown prometheus:prometheus /usr/local/bin/prometheus
$ sudo chown prometheus:prometheus /usr/local/bin/promtool
</code></pre>
</li>
<li>Copy Prometheus console libraries to <code>/etc</code> and change their ownership.
<pre><code>$ sudo cp -r prometheus-files/consoles /etc/prometheus
$ sudo cp -r prometheus-files/console_libraries /etc/prometheus
$ sudo chown -R prometheus:prometheus /etc/prometheus/consoles
$ sudo chown -R prometheus:prometheus /etc/prometheus/console_libraries
</code></pre>
</li>
<li>Create Prometheus config file, define targets.
To create and open up the config file:
<pre><code>$ sudo nano /etc/prometheus/prometheus.yml
</code></pre>
Put the following content into the file:
<pre><code class="language-yaml">scrape_configs:
    - job_name: goshimmer_local
      scrape_interval: 5s
      static_configs:
      - targets:
        # goshimmer prometheus plugin export
        - 127.0.0.1:9311
</code></pre>
Save and exit the editor.</li>
<li>Change ownership of the config file.
<pre><code>$ sudo chown prometheus:prometheus /etc/prometheus/prometheus.yml
</code></pre>
</li>
<li>Create a Prometheus service file.
<pre><code>$ sudo nano /etc/systemd/system/prometheus.service
</code></pre>
Copy the following content into the file:
<pre><code class="language-yaml">[Unit]
Description=Prometheus GoShimmer Server
Wants=network-online.target
After=network-online.target

[Service]
User=prometheus
Group=prometheus
Type=simple
ExecStart=/usr/local/bin/prometheus \
    --config.file /etc/prometheus/prometheus.yml \
    --storage.tsdb.path /var/lib/prometheus/ \
    --web.console.templates=/etc/prometheus/consoles \
    --web.console.libraries=/etc/prometheus/console_libraries

[Install]
WantedBy=multi-user.target
</code></pre>
</li>
<li>Reload <code>systemd</code> service to register the prometheus service.
<pre><code>$ sudo systemctl daemon-reload
$ sudo systemctl start prometheus
</code></pre>
</li>
<li>Check if the service is running.
<pre><code>$ sudo systemctl status prometheus
</code></pre>
</li>
<li>You can access the prometheus server at <a href="http://localhost:9090">localhost:9090</a>.</li>
<li>(Optional) Prometheus server is running, but observe that <a href="http://localhost:9090/targets">localhost:9090/targets</a> shows the target being <code>DOWN</code>. Run GoShimmer with the configuration from the previous stage, and you will soon see the <code>goshimmer_local</code> target being <code>UP</code>.</li>
</ol>
<p>+1. When you want to stop the service, run:</p>
<pre><code>$ sudo systemctl stop prometheus
</code></pre>
<p>Prometheus now collects metrics from your node, but we need to setup Grafana to visualize the collected data.</p>
<h3 id="install-and-configure-grafana"><a class="header" href="#install-and-configure-grafana">Install and configure Grafana</a></h3>
<p>Head over to <a href="https://grafana.com/docs/grafana/latest/installation/">Grafana Documentation</a> and install Grafana. For Linux, the OSS Release is recommended.</p>
<h4 id="grafana-as-standalaon-app"><a class="header" href="#grafana-as-standalaon-app">Grafana as Standalaon App</a></h4>
<p>Depending on where you install Grafana from, the configuration directories will change. For clarity, we will proceed with the binary install here.</p>
<ol>
<li>
<p><a href="https://grafana.com/grafana/download">Download Grafana</a> binary and extract it into a folder.
For example:</p>
<pre><code class="language-bash">$ wget https://dl.grafana.com/oss/release/grafana-7.0.4.linux-amd64.tar.gz
$ tar -zxvf grafana-7.0.4.linux-amd64.tar.gz
</code></pre>
</li>
<li>
<p>We will need couple files from the GoShimmer repository. Here we suppose, that you have the repository directory <code>goshimmer</code> on the same level as the extracted <code>grafana-7.0.4</code> directory:</p>
<pre><code>├── grafana-7.0.4   
│   ├── bin       
│   ├── conf         
│   ├── LICENSE   
│   ├── NOTICE.md
│   ├── plugins-bundled
│   ├── public 
│   ├── README.md
│   ├── scripts 
│   └── VERSIO
├── goshimmer               
│   ├── CHANGELOG.md
│   ├── client             
│   ├── config.default.json
    ...
</code></pre>
<p>We copy a couple configuration files from the repository into Grafana's directory:</p>
<pre><code>$ cp -R goshimmer/tools/monitoring/grafana/dashboards/local_dashboard.json grafana-7.0.4/public/dashboards/
$ cp goshimmer/tools/monitoring/grafana/provisioning/datasources/datasources.yaml grafana-7.0.4/conf/provisioning/datasources/datasources.yaml
$ cp goshimmer/tools/monitoring/grafana/provisioning/dashboards/dashboards.yaml grafana-7.0.4/conf/provisioning/dashboards/dashboards.yaml
</code></pre>
</li>
<li>
<p>Run Grafana.</p>
<pre><code>$ cd grafana-7.0.4/bin
$ ./grafana-server
</code></pre>
</li>
<li>
<p>Open Moitoring Dashboard at <a href="http://localhost:3000">localhost:3000</a>.</p>
</li>
</ol>
<p>Default login credentials are:</p>
<ul>
<li><code>username</code> : admin</li>
<li><code>password</code> : admin</li>
</ul>
<h4 id="grafana-as-a-system-service-linux"><a class="header" href="#grafana-as-a-system-service-linux">Grafana as a System Service (Linux)</a></h4>
<p>Instead of running the <code>grafana-server</code> app each time we can create a service that runs in the background.</p>
<p>When you install Grafana from</p>
<ul>
<li><a href="https://grafana.com/docs/grafana/latest/installation/debian/#install-from-apt-repository">APT repository</a> or <code>.deb</code> <a href="https://grafana.com/docs/grafana/latest/installation/debian/#install-deb-package">package</a> (Ubuntu or Debian),</li>
<li><a href="https://grafana.com/docs/grafana/latest/installation/rpm/#install-from-yum-repository">YUM repository</a> or <code>.rpm</code> <a href="https://grafana.com/docs/grafana/latest/installation/rpm/#install-with-rpm">package</a> (CentOS, Fedora, OpenSuse, RedHat),</li>
</ul>
<p>then Grafana is configured to run as a system service without any modification. All you need to do is copy config files from the GoShimmer repository:</p>
<ol>
<li>Copy <a href="https://github.com/iotaledger/goshimmer/blob/develop/tools/monitoring/grafana/provisioning/datasources/datasources.yaml">datasource yaml config</a> to <code>/etc/grafana</code>:
(assuming you are at the root of the cloned GoShimmer repository)
<pre><code>$ sudo cp tools/monitoring/grafana/provisioning/datasources/datasources.yaml /etc/grafana/provisioning/datasources
</code></pre>
</li>
<li>Copy <a href="https://github.com/iotaledger/goshimmer/blob/develop/tools/monitoring/grafana/provisioning/dashboards/dashboards.yaml">dashboard yaml config</a> to <code>/etc/grafana</code>:
<pre><code>$ sudo cp tools/monitoring/grafana/provisioning/dashboards/dashboards.yaml /etc/grafana/provisioning/dashboards
</code></pre>
</li>
<li>Copy <a href="https://github.com/iotaledger/goshimmer/blob/develop/tools/monitoring/grafana/dashboards/local_dashboard.json">Goshimmer Local Metrics</a> dashboard to <code>/var/lib/grafana/</code>:
<pre><code>$ sudo cp -R tools/monitoring/grafana/dashboards /var/lib/grafana/
</code></pre>
</li>
<li>Reload daemon and start Grafana.
<pre><code>$ sudo systemctl daemon-reload
$ sudo systemctl start grafana-server
</code></pre>
</li>
<li>Open Moitoring Dashboard at <a href="http://localhost:3000">localhost:3000</a>.</li>
</ol>
<p>Default login credentials are:</p>
<ul>
<li><code>username</code> : admin</li>
<li><code>password</code> : admin</li>
</ul>
<h4 id="grafana-config-via-gui"><a class="header" href="#grafana-config-via-gui">Grafana Config via GUI</a></h4>
<p>If you successfully installed Grafana and would like to set it up using its graphical interface, here are the steps you need to take:</p>
<ol>
<li>Run Grafana.</li>
<li>Open <a href="http://localhost:3000">localhost:3000</a> in a browser window.
Default login credentials are:
<ul>
<li><code>username</code> : admin</li>
<li><code>password</code> : admin</li>
</ul>
</li>
<li>On the left side, open <strong>Configuration -&gt; Data Sources</strong>. Click on <strong>Add data source</strong> and select <strong>Prometheus</strong> core plugin.</li>
<li>Fill the following fields:
<ul>
<li><code>URL</code>: http://localhost:9090</li>
<li><code>Scrape interval</code>: 5s</li>
</ul>
</li>
<li>Click on <strong>Save &amp; Test</strong>. If you have a running Prometheus server, everything should turn green. If the URL can't be reached, try changing the <strong>Access</strong> field to <code>Browser</code>.</li>
<li>On the left side panel, click on <strong>Dashboards -&gt; Manage</strong>.</li>
<li>Click on <strong>Import</strong>. Paste the content of <a href="https://github.com/iotaledger/goshimmer/blob/develop/tools/monitoring/grafana/dashboards/local_dashboard.json">local_dashboard.json</a> in the <strong>Import via panel json</strong>, or download the life and use the <strong>Upload .json file</strong> option.</li>
<li>Now you can open <strong>GoShimmer Local Metrics</strong> dashboard under <strong>Dashboards</strong>. Don't forget to start your node and run Prometheus!</li>
</ol>
<h1 id="application-logic"><a class="header" href="#application-logic">Application logic</a></h1>
<h1 id="protocol-high-level-overview"><a class="header" href="#protocol-high-level-overview">Protocol high level overview</a></h1>
<p>will link (in the future) to specific specs</p>
<ul>
<li>Overall data flow might help here</li>
</ul>
<h1 id="implementation-design"><a class="header" href="#implementation-design">Implementation design</a></h1>
<h1 id="event-driven-model"><a class="header" href="#event-driven-model">Event driven model</a></h1>
<p>Event driven model is popular approach often used for example in GUI applications, where a program is waiting for some external event to take place (e.g. mouse click) in order to perform some action.
In case of GoShimmer there is no GUI, however it applies this architecture approach as it's really flexible and is used to handle communication with other nodes and other internal parts. 
In GoShimmer some of those events can be e.g. arrival of new tangle message, peering request or plugin start. 
When an event is triggered, an event handler (or a collection of handlers) is executed and the state of the application is updated as necessary.</p>
<h2 id="glossary"><a class="header" href="#glossary">Glossary:</a></h2>
<p>At first let's define some terms used further to avoid misunderstandings:</p>
<ul>
<li>
<p>Event - represents the type of event (e.g. new message or peering request) as well as set of handlers and trigger functions. Each type of event is separately defined 
which means that events are independent of each other - each event has its own set of handlers and is triggered separately.</p>
</li>
<li>
<p>Event handler (callback) - is a function that is executed when an event of given type occurs. An event handler can accept multiple arguments (e.g. message ID or plugin) so that it can perform appropriate actions.
Every handler must accept the same set of parameters. Each event has a different set of handlers (there can be multiple handlers) that are executed when the event is triggered.</p>
</li>
<li>
<p>Trigger - is a method that triggers execution of event handlers with given parameter values.</p>
</li>
</ul>
<h2 id="creating-new-event-with-custom-callbacks"><a class="header" href="#creating-new-event-with-custom-callbacks">Creating new event with custom callbacks</a></h2>
<p>Below are the steps that show the example code necessary to create a custom event, attach a handler and trigger the event. </p>
<ol>
<li>Create a function that will call event handlers (handler caller) for a specific event. 
Each event has only one handler caller. It enforces that all handlers for the event must share the same interface, because the caller will pass a fixed set of arguments of specific types to handler function. 
It's not possible to pass different number of arguments or types to the handler function. 
Callers for all events must also share the same interface - the first argument represents the handler function that will be called represented by a generic argument.
Further arguments represent parameters that will be passed to the handler during execution. Below are example callers that accept one and two parameters respectively. 
More arguments can be passed in similar manner. </li>
</ol>
<pre><code class="language-go">func singleArgCaller(handler interface{}, params ...interface{}) {
    handler.(func (*Plugin))(params[0].(*Plugin))
}

func twoArgsCaller(handler interface{}, params ...interface{}) {
    handler.(func(*peer.Peer, error))(params[0].(*peer.Peer), params[1].(error))
}
</code></pre>
<p><code>handler.(func (*Plugin))(params[0].(*Plugin))</code> - this code seems a little complicated, so to make things simpler we will divide into smaller parts and explain each:</p>
<ul>
<li><code>handler.(func (*Plugin))</code> (A) - this part does type-cast the handler from generic type onto type of desired, specific function type - in this case it's a function that accepts <code>*Plugin</code> as its only parameter.</li>
<li><code>params[0].(*Plugin)</code> (B)- similarly to previous part, first element of parameter slice is type-casted onto <code>*Plugin</code> type, so that it matches the handler function interface.</li>
<li><code>handler.(func (*Plugin))(params[0].(*Plugin))</code> - the whole expression calls the type-casted handler function with the type-casted parameter value. We can also write this as <code>A(B)</code> to make things simpler.</li>
</ul>
<p>The above explanation also allows a better understanding of why all handlers must share the same interface - handler caller passes fixed number of parameters and does type-casting of arguments onto specific types.</p>
<ol start="2">
<li>Next, a new event object needs to be created. We pass the handler caller as an argument, which is saved inside the object to be called when the event is triggered.</li>
</ol>
<pre><code class="language-go">import &quot;github.com/iotaledger/hive.go/events&quot;

ThisEvent := events.NewEvent(singleArgCaller)
</code></pre>
<ol start="3">
<li>After creating the event, handlers (or callbacks) can be attached to it. An event can have multiple callbacks, however they all need to share the same interface. 
One thing to note, is that functions are not passed directly - first they are wrapped into a <code>events.Closure</code> object like in the example below. </li>
</ol>
<pre><code class="language-go">ThisEvent.Attach(events.NewClosure(func (arg *Plugin) {
    // do something
}))
</code></pre>
<ol start="4">
<li>In order to trigger the event with some parameters we need to run the <code>.Trigger</code> method on the event object with parameters that handler functions will receive:</li>
</ol>
<pre><code class="language-go">somePlugin Plugin
ThisEvent.Trigger(&amp;somePlugin)
</code></pre>
<h1 id="dependency-of-packages-and-plugins"><a class="header" href="#dependency-of-packages-and-plugins">Dependency of packages and plugins</a></h1>
<p>In GoShimmer, new features are added through the <a href="node-software/goshimmer/docs/implementation_design/plugin.html">plugin system</a>.
When creating a new plugin, it must implement an interface shared with all other plugins, so it's easy to add new
plugins and change their internal implementation without worrying about compatibility. 
Because of this, to make the code clean and easily manageable the plugin's internal logic has to be implemented in a different package.
This is an example of an <a href="https://en.wikipedia.org/wiki/Adapter_pattern">adapter design pattern</a> that is often used in plugin systems.
It's really useful in a prototype software like GoShimmer, because it's possible to easily switch between different implementations 
and internal interfaces just by using a different plugin, without having to rewrite the code using it. </p>
<p>When creating a new plugin, the logic should be implemented in a separate package stored in the <code>packages/</code> directory. 
The package should contain all struct and interface definitions used, as well as the specific logic. 
It should not reference any <code>plugin</code> packages from the <code>plugin/</code> directory as this could lead to circular dependencies between packages.</p>
<p>There are no special interfaces or requirements that packages in the <code>packages/</code> directory are forced to follow. However, they should be independent of other packages if possible, 
to avoid problems due to changing interfaces in other packages.</p>
<h1 id="plugin-system"><a class="header" href="#plugin-system">Plugin system</a></h1>
<p>GoShimmer is a complex application that is used in a research environment where requirements often changed and new ideas arise. 
The Plugin system allows to quickly and easily add and remove modules that need to be started. However, one thing that might be non-intuitive about the use of plugins is that it's taken to an extreme - everything is run through plugins. 
The only code that is not executed through a plugin system is the code responsible for configuring and starting the plugins.
All new future features added to the GoShimmer must be added by creating a new plugin. </p>
<h2 id="plugin-structure"><a class="header" href="#plugin-structure">Plugin structure</a></h2>
<p><code>Plugin</code> structure is defined as following.</p>
<pre><code class="language-go">type Plugin struct {
	Node   *Node
	Name   string
	Status int
	Events pluginEvents
	wg     *sync.WaitGroup
}
</code></pre>
<p>Below is a brief description of each field: </p>
<ul>
<li><code>Node</code> - contains a pointer to <code>Node</code> object which contains references to all the plugins and node-level logger. #TODO: figure out why it is there - not really used anywhere</li>
<li><code>Name</code> - descriptive name of the plugin.</li>
<li><code>Status</code> - flag indicating whether plugin is enabled or disabled.</li>
<li><code>Events</code> - structure containing events used to properly deploy the plugin. Details described below.</li>
<li><code>wg</code> - a private field containing WaitGroup. #TODO: figure out why it is there - not really used anywhere</li>
</ul>
<h2 id="plugin-events"><a class="header" href="#plugin-events">Plugin events</a></h2>
<p>Each plugin defines 3 events: <code>Init</code>, <code>Configure</code>, <code>Run</code>. 
Those events are triggered during different stages of node startup, but the plugin doesn't have to define handlers for all of those events in order to do what it's been designed for.
Execution order and purpose of each event is described below: </p>
<ol>
<li><code>Init</code> - is triggered almost immediately after a node is started. It's used in plugins that are critical for GoShimmer such as reading config file or initializing global logger. Most plugins don't need to use this event.</li>
<li><code>Configure</code> - this event is used to configure the plugin before it is started. It is used to define events related to internal plugin logic or initialize objects used by the plugin. </li>
<li><code>Run</code> - this event is triggered as the last one. The event handler function contains the main logic of the plugin. 
For many plugins, the event handler function creates a separate worker that works in the background, so that the handler function for one plugin can finish and allow other plugins to be started.</li>
</ol>
<p>Each event could potentially have more than one handler, however currently all existing plugins follow a convention where each event has only one handler.</p>
<p>It is important to note that each event is triggered for all plugins sequentially, so that the event <code>Init</code> is triggered for all plugins, then <code>Configure</code> is triggered for all plugins and finally <code>Run</code>. 
Such order is crucial, because some plugins rely on other plugins' initialization or configuration. The order in which plugins are initialized, configured and run is also important and this is described below. </p>
<p>Handler functions for all plugin events share the same interface, so they could potentially be used interchangeably. Sample handler functions look like this:</p>
<pre><code class="language-go">func configure(_ *node.Plugin) {
    // configure stuff
}

func run(*node.Plugin) { 
    // run plugin	
}
</code></pre>
<p>The handler functions receive one argument of type <code>*Plugin</code>. The code responsible for triggering those events passes a pointer to the plugin object itself. 
The object needs to be passed so that the handler function can access plugin fields (e.g. plugin name to configure logger).</p>
<h2 id="creating-new-plugin"><a class="header" href="#creating-new-plugin">Creating new plugin</a></h2>
<p>A plugin object can be created by calling the <code>node.NewPlugin</code> method. 
The method creates and returns a new plugin object, as well as registers it so that GoShimmer knows the plugin is available.
It accepts the following arguments:</p>
<ul>
<li><code>name string</code> - plugin name.</li>
<li><code>status int</code> - flag indicating whether plugin is enabled or disabled by default. This can be overridden by enabling/disabling the plugin in the external configuration file. Possible values: <code>node.Enabled</code>, <code>node.Disabled</code>. </li>
<li><code>callbacks ...Callback</code> - list of event handler functions. The method will correctly create a plugin when passing up to 2 callbacks. Note: <code>type Callback = func(plugin *Plugin)</code>, which is a raw function type without being wrapped in <code>events.Closure</code>.</li>
</ul>
<p>There is a couple of ways that the method can be called, depending on which plugin events need to be configured. </p>
<ul>
<li>Define <code>Configure</code> and <code>Run</code> event handlers. It's the most common usage that plugins currently use. </li>
</ul>
<pre><code class="language-go">plugin = node.NewPlugin(PluginName, node.Enabled, configure, run)
</code></pre>
<ul>
<li>Define only <code>Configure</code> event. It's used for plugins that are used to configure objects used (or managed) by other plugins, such as creating API endpoints. </li>
</ul>
<pre><code class="language-go">plugin = node.NewPlugin(PluginName, node.Enabled, configure)
</code></pre>
<ul>
<li>Define a plugin without <code>Configure</code> or <code>Run</code> event handlers. This is used to create plugins that perform some action when the <code>Init</code> event is triggered.</li>
</ul>
<pre><code class="language-go">plugin = node.NewPlugin(PluginName, node.Enabled)
</code></pre>
<p>However, the <code>Init</code> event handler cannot be attached using the <code>node.NewPlugin</code> method. 
In order to specify this handler, plugin creator needs to attach it manually to the event, for example inside the package's <code>init()</code> method in the file containing the rest of the plugin definition.</p>
<pre><code class="language-go">func init() {
	plugin.Events.Init.Attach(events.NewClosure(func(*node.Plugin) {
		// do something
	}))
}
</code></pre>
<p>It's important to note, that the <code>node.NewPlugin</code> accepts handler functions in a raw format, that is, without being wrapped by the <code>events.Closure</code> object as the method does the wrapping inside.
However, when attaching the <code>Init</code> event handler manually, it must be wrapped by the <code>events.Closure</code> object. </p>
<p>It's crucial that each plugin is created only once and <code>sync.Once</code> class is used to guarantee that. Contents of a file containing sample plugin definition is presented. All plugins follow this format.</p>
<pre><code class="language-go">const PluginName = &quot;SamplePlugin&quot;

var (
	// plugin is the plugin instance of the new plugin plugin.
	plugin     *node.Plugin
	pluginOnce sync.Once
)

// Plugin gets the plugin instance.
func Plugin() *node.Plugin {
	pluginOnce.Do(func() {
		plugin = node.NewPlugin(PluginName, node.Enabled, configure, run)
	})
	return plugin
}

// Handler functions
func init() {
    plugin.Events.Init.Attach(events.NewClosure(func(*node.Plugin) {
        // do something
    }))
}
func configure(_ *node.Plugin) {
    // configure stuff
}

func run(*node.Plugin) {
    // run stuff	
}
</code></pre>
<h2 id="running-new-plugin"><a class="header" href="#running-new-plugin">Running new plugin</a></h2>
<p>In order to correctly add a new plugin to GoShimmer, apart from defining it, it must also be passed to the <code>node.Run</code> method. 
Because there are plenty of plugins, in order to improve readability and make managing plugins easier, they are grouped into separate wrappers passed to the <code>node.Run</code> method. 
When adding a new plugin, it must be added into one of those groups, or a new group must be created.</p>
<pre><code class="language-go">node.Run(
    plugins.Core,
    plugins.Research,
    plugins.UI,
    plugins.WebAPI,
)
</code></pre>
<p>You can add a plugin simply by calling the <code>Plugin()</code> method of the newly created plugin and passing the argument further. An example group definition is presented below. When it's added, the plugin is correctly added and will be run when GoShimmer starts.</p>
<pre><code class="language-go">var Core = node.Plugins(
    banner.Plugin(),
    newPlugin.Plugin(),
    // other plugins ommited 
)
</code></pre>
<h2 id="background-workers"><a class="header" href="#background-workers">Background workers</a></h2>
<p>In order to run plugins beyond the scope of the short-lived <code>Run</code> event handler, possibly multiple <code>daemon.BackgroundWorker</code> instances can be started inside the handler function. 
This allows the <code>Run</code> event handler to finish quickly, and the plugin logic can continue running concurrently in a separate goroutine. </p>
<p>Background worker can be started by running the <code>daemon.BackgroundWorker</code> method, which accepts following arguments:</p>
<ul>
<li><code>name string</code> - background worker name</li>
<li><code>handler WorkerFunc</code> - long-running function that will be started in its own goroutine. It accepts a single argument of type <code>&lt;-chan struct{}</code>. When something is sent to that channel, the worker will shut down. Note: <code>type WorkerFunc = func(shutdownSignal &lt;-chan struct{})</code></li>
<li><code>order ...int</code> - value used to define in which shutdown order this particular background worker must be shut down (higher = earlier).
The parameter can either accept one or zero values, more values will be ignored. When passing zero values, default value of <code>0</code> is assumed.
Values are normalized in the <code>github.com/iotaledger/goshimmer/packages/shutdown</code> package, and it should be used instead of passing integers manually. 
Correct shutdown order is as important as correct start order, because different plugins depend on others working correctly, so when one plugin shuts down too soon, other plugins may run into errors, crash and leave an incorrect state. </li>
</ul>
<p>An example code for creating a background worker: </p>
<pre><code class="language-go">func start(shutdownSignal &lt;-chan struct{}) {
	// long-running function
	// possibly start goroutines here
	// wait for shutdown signal
    &lt;-shutdownSignal
}

if err := daemon.BackgroundWorker(backgroundWorkerName, start, shutdown.PriorityGossip); err != nil {
	log.Panicf(&quot;Failed to start as daemon: %s&quot;, err)
}
</code></pre>
<h1 id="configuration-parameters"><a class="header" href="#configuration-parameters">Configuration parameters</a></h1>
<h2 id="customizing-configuration"><a class="header" href="#customizing-configuration">Customizing configuration</a></h2>
<p>Users can pass configuration parameters in two ways when running GoShimmer. One way is through a JSON configuration file and another way is through command line arguments.
Settings passed through command line arguments take precedence. The JSON configuration file is structured as a JSON object containing parameters and their values.
Parameters are grouped into embedded objects containing parameters for a single plugin or functionality. There is no limit on how deep the configuration object may be embedded.
For example, the config below contains example parameters for the PoW plugin.</p>
<pre><code class="language-json">{
  &quot;pow&quot;: {
    &quot;difficulty&quot;: 2,
    &quot;numThreads&quot;: 1,
    &quot;timeout&quot;: &quot;10s&quot;
  }
}
</code></pre>
<p>The same arguments can be passed through command line arguments in the following way. Embedded objects' values are described using JSON dot-notation.
Additionally,the user can pass the path of the JSON config file through a command-line argument as well, as shown in an example below. </p>
<pre><code class="language-bash">goshimmer \
--config=/tmp/config.json \
--pow.difficulty=2 \
--pow.numThreads=1 \
--pow.timeout=10s 
</code></pre>
<h2 id="custom-parameter-fields"><a class="header" href="#custom-parameter-fields">Custom parameter fields</a></h2>
<p>Currently, in the code there are two ways in which parameters are registered with GoShimmer. However, one is deprecated way, while the second should be used any longer when adding new parameters.</p>
<h3 id="old-deprecated-way"><a class="header" href="#old-deprecated-way">Old, deprecated way</a></h3>
<p>The old way is described shortly to give a basic understanding of how it works, but it should not be used any longer when adding new parameters.</p>
<p>In a package where the parameters will be used, create a <code>parameters.go</code> file, that contains the definition of constants, which define parameter names in JSON dot-notation. 
The constants will be later used in the code to access the parameter value. 
The file should also contain an <code>init()</code> function, which registers the parameters with the <code>flag</code> library responsible for parsing configuration along with its default value and short description.
It should include comments describing what the parameter is for. Here is an example <code>parameters.go</code> file:</p>
<pre><code class="language-go">package customPackage

import (
	flag &quot;github.com/spf13/pflag&quot;
)
const (
	// ParamName contains some value used within the plugin
	ParamName = &quot;customPlugin.paramName&quot;
)

func init() {
	flag.Float64(paramName, 0.31, &quot;ParamName used in some calculation&quot;)
}
</code></pre>
<p>The parameter values can be accessed in the code in the following way through the <code>config</code> plugin:</p>
<pre><code class="language-go">import &quot;github.com/iotaledger/goshimmer/plugins/config&quot;

config.Node().Int(CfgGossipPort)
</code></pre>
<h3 id="new-way"><a class="header" href="#new-way">New way</a></h3>
<p>Defining configuration parameters using the new way is really similar, however the parameters are not registered directly with the package reading the configuration,
but rather with our custom package that contains all the logic required to make it work seamlessly. </p>
<p>In this approach, instead of defining a parameter name, a new structure is defined with all necessary parameters, their default values and usage descriptions using Go's struct field tags.</p>
<p>One difference is that parameter names do not contain the namespace they belong to, the namespace is set when registering the parameters structure with the <code>configuration</code> package. One <code>parameters.go</code> file can contain definitions and register multiple parameter structures.</p>
<pre><code class="language-go">package customPlugin

import &quot;github.com/iotaledger/hive.go/configuration&quot;

// Parameters contains the configuration parameters used by the custom plugin.
var Parameters = struct {
	// ParamName contains some value used within the plugin
	ParamName float64 `default:&quot;0.31&quot; usage:&quot;ParamName used in some calculation&quot;`

	// ParamGroup contains an example of embedded configuration definitions.
	ParamGroup struct {
		// DetailedParam1 is the example value
		DetailedParam1        string `default:&quot;defaultValue&quot; usage:&quot;DetailedParam1 used in the plugin&quot;`
		// DetailedParam2 is the example value
		DetailedParam2        string `default:&quot;defaultValue&quot; usage:&quot;DetailedParam2 used in the plugin&quot;`
	}
}{}

func init() {
	configuration.BindParameters(&amp;Parameters, &quot;customPlugin&quot;)
}
</code></pre>
<p>In order to access the parameter value, a user can simply access the structure's field: <code>Parameters.ParamName</code> or <code>Parameters.ParamGroup.DetailedParam1</code> 
and it will be populated either with the default value or values passed through a JSON config or command-line argument. </p>
<p>This approach makes it more simple to define new parameters as well as makes accessing configuration values more clear. </p>
<h1 id="object-storage"><a class="header" href="#object-storage">Object storage</a></h1>
<p>In GoShimmer <code>ObjectStorage</code>  is used as a base data structure for many data collection elements such as <code>branchStorage</code>, <code>conflictStorage</code>, <code>messageStorage</code> and others.
It can be described by the following characteristics, it:</p>
<ul>
<li>is a manual cache which keeps objects in memory as long as consumers are using it</li>
<li>uses key-value storage type </li>
<li>provides mutex options for guarding shared variables and preventing changing the object state by multiple goroutines at the same time</li>
<li>takes care of  dynamic creation of different object types depending on the key, and the serialized data it receives through the utility <code>objectstorage.Factory</code></li>
<li>helps with the creation of multiple <code>ObjectStorage</code> instances from the same package and  automatic configuration.</li>
</ul>
<p>In order to create an object storage we need to provide the underlying <code>kvstore.KVStore</code> structure backed by the database.</p>
<h2 id="database"><a class="header" href="#database">Database</a></h2>
<p>GoShimmer stores data in the form of an object storage system. The data is stored in one large repository with flat structure. It is a scalable solution that allows for fast data retrieval because of its categorization structure.</p>
<p>Additionally, GoShimmer leaves the possibility to store data only in memory that can be specified with the parameter <code>CfgDatabaseInMemory</code> value. In-memory storage is purely based on a Go map, package <code>mapdb</code> from hive.go.
For the persistent storage in a database it uses package <code>badger</code> from hive.go. It is a simple and fast key-value database that performs well for both reads and writes simultaneously.</p>
<p>Both solutions are implemented in the <code>database</code> package, along with prefix definitions that can be used during the creation of new object storage elements.</p>
<p>The database plugin is responsible for creating a <code>store</code> instance of the chosen database under the directory specified with <code>CfgDatabaseDir</code> parameter. It will manage a proper closure of the database upon receiving a shutdown signal. During the start configuration, the database is marked as unhealthy, and it will be marked as healthy on shutdown. Then the garbage collector is run and the database can be closed.</p>
<h2 id="objectstorage"><a class="header" href="#objectstorage">ObjectStorage</a></h2>
<p>Assume we need to store data for some newly created object <code>A</code>. Then we need to define a new prefix for our package in the <code>database</code> package, and prefixes for single storage objects. They will be later used during <code>ObjectStorage</code> creation. A package prefix will be combined with a store specific prefix to create a specific realm.</p>
<pre><code class="language-Go">package example

type Storage struct {
	A                   *objectstorage.ObjectStorage
	...
	shutdownOnce        sync.Once
}
</code></pre>
<h3 id="objectstorage-factory"><a class="header" href="#objectstorage-factory">ObjectStorage factory</a></h3>
<p>To easily create multiple storage objects instances for one package, the most convenient way is to use the factory function.</p>
<pre><code class="language-Go">osFactory := objectstorage.NewFactory(store, database.Prefix)
</code></pre>
<p>It needs two parameters:</p>
<ul>
<li><code>store</code> - the key value <code>kvstore</code> instance</li>
<li><code>database.Prefix</code> - a prefix defined in the <code>database</code> package for our new <code>example</code> package. It will be responsible for automatic configuration of the newly provided <code>kvstore</code> instance.</li>
</ul>
<p>After defining the storage factory for the group of objects, we can use it to create an <code>*objectstorage.ObjectStorage</code> instance:</p>
<pre><code class="language-Go">AStorage = osFactory.New(objPrefix, FromObjectStorage)
AStorage = osFactory.New(objPrefix, FromObjectStorage, optionalOptions...)
</code></pre>
<p>For the function parameter we should provide:</p>
<ul>
<li><code>objPrefix</code> - mentioned before, we provide the object specific prefix.</li>
<li><code>FromObjectStorage</code> - a function that allows the dynamic creation of different object types depending on the stored data.</li>
<li><code>optionalOptions</code> -  an optional parameter provided in the form of options array <code>[]objectstorage.Option</code>. All possible options are defined in <code>objectstorage.Options</code>. If we do not specify them during creation, the default values will be used, such as enabled persistence or setting cache time to 0.</li>
</ul>
<h3 id="storableobject"><a class="header" href="#storableobject">StorableObject</a></h3>
<p><code>StorableObject</code> is an interface that allows the dynamic creation of different object types depending on the stored data. We need to make sure that all methods required by the interface are implemented to use the object storage factory.</p>
<ul>
<li><code>SetModified</code> - marks the object as modified, which will be written to the disk (if persistence is enabled).</li>
<li><code>IsModified</code> - returns true if the object is marked as modified</li>
<li><code>Delete</code> - marks the object to be deleted from the persistence layer</li>
<li><code>IsDeleted</code> - returns true if the object was marked as deleted</li>
<li><code>Persist</code> - enables or disables persistence for this object</li>
<li><code>ShouldPersist</code> - returns true if this object is going to be persisted</li>
<li><code>Update</code> - updates the object with the values of another object - requires an explicit implementation</li>
<li><code>ObjectStorageKey</code> - returns the key that is used to store the object in the database - requires an explicit implementation</li>
<li><code>ObjectStorageValue</code> - marshals the object data into a sequence of bytes that are used as the value part in the object storage - requires an explicit implementation</li>
</ul>
<p>Most of these have their default implementation in <code>objectstorage</code> library, except from <code>Update</code>, <code>ObjectStorageKey</code>, <code>ObjectStorageValue</code> which need to be provided.</p>
<h3 id="storableobjectfactory-function"><a class="header" href="#storableobjectfactory-function">StorableObjectFactory function</a></h3>
<p>The function <code>ObjectFromObjectStorage</code> from object storage provides functionality to restore objects from the <code>ObjectStorage</code>. By convention the implementation of this function usually follows the schema:
<code>ObjectFromObjectStorage</code> uses <code>ObjectFromBytes</code></p>
<pre><code class="language-Go">func ObjectFromObjectStorage(key []byte, data []byte) (result StorableObject, err error) {
    result, err := ObjectFromBytes(marshalutil.New(data))
    ...
    return
}
</code></pre>
<p><code>ObjectFromBytes</code> unmarshals the object sequence of bytes with a help of <code>marshalutil</code> library. The returned <code>consumedBytes</code> can be used for the testing purposes.
The created <code>marshalUtil</code> instance stores the stream of bytes and keeps track of what has been already read (<code>readOffset</code>).</p>
<pre><code class="language-Go">func ObjectFromBytes(bytes []byte) (object *ObjectType, consumedBytes int, err error) {
    marshalUtil := marshalutil.New(bytes)
    if object, err = ObjectFromMarshalUtil(marshalUtil); err != nil {
    ...
    consumedBytes = marshalUtil.ReadOffset()
    return
}
</code></pre>
<p>The key logic is implemented in <code>ObjectFromMarshalUtil</code> that takes the marshaled object and transforms it into the object of specified type.
Because the data is stored in a sequence of bytes, it has no information about the form of an object and any data types it had before writing to the database.
Thus, we need to serialize any data into a stream of bytes in order to write it (marshaling), and deserialize the stream of bytes back into correct data structures when reading it (unmarshaling). 
Let's consider as an example, unmarshaling of the <code>Approver</code> object.</p>
<pre><code class="language-Go">type Approver struct {
    approverType            ApproverType    //  8 bytes
    referencedMessageID     MessageID       // 32 bytes
    approverMessageID       MessageID       // 32 bytes
}
</code></pre>
<p>The order in which we read bytes has to reflect the order in which it was written down during marshaling. As in the example, the order: <code>referencedMessageID</code>, <code>approverType</code>, <code>approverMessageID</code> is the same in both marshalling and unmarshalling.</p>
<pre><code class="language-Go">// Unmarshalling
func ApproverFromMarshalUtil(marshalUtil *marshalutil.MarshalUtil) (result *Approver) {
    result = &amp;Approver{}
    result.referencedMessageID = MessageIDFromMarshalUtil(marshalUtil)
    result.approverType = ApproverTypeFromMarshalUtil(marshalUtil)
    result.approverMessageID = MessageIDFromMarshalUtil(marshalUtil)
    return
}
// Marshalling
func (a *Approver) ObjectStorageApprover() []byte {
    return marshalutil.New().
    Write(a.referencedMessageID).
    Write(a.approverType).
    Write(a.approverMessageID).
    Bytes()
}
</code></pre>
<p>We continue to decompose our object into smaller pieces with help of <code>MarshalUtil</code> struct that keeps track of bytes, and a read offset.
Then we use <code>marshalutil</code> build in methods on the appropriate parts of the byte stream with its length defined by the data
type of the struct field. This way, we are able to parse bytes to the correct Go data structure.</p>
<h3 id="objectstorage-methods"><a class="header" href="#objectstorage-methods">ObjectStorage methods</a></h3>
<p>After defining marshalling and unmarshalling mechanism for<code>objectStorage</code> bytes conversion, 
we can start using it for its sole purpose, to actually store and read the particular parts of the project elements. </p>
<ul>
<li>
<p><code>Load</code> allows retrieving the corresponding object based on the provided id. For example, the method on the message <code>objectStorage</code><br />
is getting the cached object. </p>
</li>
<li>
<p>To convert an object retrieved in the form of a cache to its own corresponding type, we can use <code>Unwrap</code>.
In the code below it will return the message wrapped by the cached object.</p>
</li>
<li>
<p><code>Exists</code> - checks weather the object has been deleted. If so it is released from memory with the <code>Release</code> method.</p>
<pre><code class="language-Go">func (s *Storage) Message(messageID MessageID) *CachedMessage {
    return &amp;CachedMessage{CachedObject: s.messageStorage.Load(messageID[:])}
}

cachedMessage := messagelayer.Tangle().Storage.Message(msgID)
if !cachedMessage.Exists() {
    msgObject.Release()
    }
message := cachedMessage.Unwrap()
</code></pre>
</li>
<li>
<p><code>Consume</code> will be useful when we want to apply a function on the cached object. <code>Consume</code> unwraps the <code>CachedObject</code> and passes a type-casted version to the consumer function.
Right after the object is consumed and when the callback is finished, the object is released.</p>
<pre><code class="language-Go">cachedMessage.Consume(func(message *tangle.Message) {
            doSomething(message)
        })
</code></pre>
</li>
<li>
<p><code>ForEach</code> - allows to apply a <code>Consumer</code> function for every object residing within the cache and the underlying persistence layer.
For example, this is how we can count the number of messages.</p>
<pre><code class="language-Go">messageCount := 0
messageStorage.ForEach(func(key []byte, cachedObject objectstorage.CachedObject) bool {
  	cachedObject.Consume(func(object objectstorage.StorableObject) {
  		messageCount++
      })
}
</code></pre>
</li>
<li>
<p><code>Store</code> - storing an object in the objectStorage. An extended version is method <code>StoreIfAbsent</code> 
that stores an object only if it was not stored before and returns boolean indication if the object was stored. 
<code>ComputeIfAbsent</code> works similarly but does not access the value log. </p>
<pre><code class="language-Go">cachedMessage := messageStorage.Store(newMessage)
cachedMessage, stored := messageStorage.StoreIfAbsent(newMessage)
cachedMessage := messageStorage.ComputeIfAbsent(newMessage, remappingFunction)
</code></pre>
</li>
</ul>
<h1 id="api-4"><a class="header" href="#api-4">API</a></h1>
<h1 id="client-lib-interaction-with-layers"><a class="header" href="#client-lib-interaction-with-layers">Client Lib: Interaction with layers</a></h1>
<blockquote>
<p>This guide is meant for developers familiar with the Go programming language.</p>
</blockquote>
<p>GoShimmer ships with a client Go library which communicates with the HTTP API. Please refer to the <a href="https://godoc.org/github.com/iotaledger/goshimmer/client">godoc.org docs</a> for function/struct documentation. There is also a set of APIs which do not directly have anything to do with the different layers. Since they are so simple, simply extract their usage from the GoDocs.</p>
<h1 id="use-the-api"><a class="header" href="#use-the-api">Use the API</a></h1>
<p>Simply <code>go get</code> the lib via:</p>
<pre><code>go get github.com/iotaledger/goshimmer/client
</code></pre>
<p>Init the API by passing in the API URI of your GoShimmer node:</p>
<pre><code>goshimAPI := client.NewGoShimmerAPI(&quot;http://mynode:8080&quot;)
</code></pre>
<p>Optionally, define your own <code>http.Client</code> to use, in order for example to define custom timeouts:</p>
<pre><code>goshimAPI := client.NewGoShimmerAPI(&quot;http://mynode:8080&quot;, http.Client{Timeout: 30 * time.Second})
</code></pre>
<h4 id="a-note-about-errors"><a class="header" href="#a-note-about-errors">A note about errors</a></h4>
<p>The API issues HTTP calls to the defined GoShimmer node. Non 200 HTTP OK status codes will reflect themselves as <code>error</code> in the returned arguments. Meaning that for example calling for attachments with a non existing/available transaction on a node, will return an <code>error</code> from the respective function. (There might be exceptions to this rule)</p>
<h1 id="webapi---clientlib"><a class="header" href="#webapi---clientlib">WebAPI - clientLib</a></h1>
<p>The web API interface allows to access functionality of the node software via exposed http endpoints.</p>
<h2 id="how-to-use-the-api"><a class="header" href="#how-to-use-the-api">How to use the API</a></h2>
<p>The default port to access the web API is set to <code>8080:8080/tcp</code> in <code>docker-compose.yml</code>, where the first port number is the internal port number within the node software, and the second for the access from an http port. An example where these two would be set to different values, or the external port is not utilized, can be found in the docker-network tool (see also the <code>docker-compose.yml</code> file in the docker-network tool folder).</p>
<p>The server instance of the web API is contacted via <code>webapi.Server()</code>. Next we need to register a route with a matching handler.</p>
<pre><code>webapi.Server().ROUTE(path string, h HandlerFunc)
</code></pre>
<p>where <code>ROUTE</code> will be replaced later in this documentation by <code>GET</code> or <code>POST</code>. The <code>HandlerFunc</code> defines a function to serve HTTP requests that gives access to the Context</p>
<pre><code>func HandlerFunc(c Context) error
</code></pre>
<p>We can then use the Context to send a JSON response to the node: </p>
<pre><code>JSON(statuscode int, i interface{}) error
</code></pre>
<p>An implementation example is shown later for the POST method.</p>
<h2 id="get-and-post"><a class="header" href="#get-and-post">GET and POST</a></h2>
<p>Two methods are currently used. First, with <code>GET</code> we register a new GET route for a handler function. The handler is accessed via the address <code>path</code>. The handler for a GET method can set the node to perform certain actions.</p>
<pre><code>webapi.Server().GET(&quot;path&quot;, HandlerFunc)
```	
A command can be sent to the node software to the API, e.g. via command prompt: 
</code></pre>
<p>curl &quot;http://127.0.0.1:8080/path?command&quot;</p>
<pre><code>
$$ . $$

Second, with `POST` we register a new POST route for a handler function. The handler can receive a JSON body input and send specific messages to the tangle.
</code></pre>
<p>webapi.Server().POST(&quot;path&quot;, HandlerFunc)</p>
<pre><code>
For example, the following Handler `broadcastData` sends a data message to the tangle
</code></pre>
<p>func broadcastData(c echo.Context) error {
var request Request
if err := c.Bind(&amp;request); err != nil {
log.Info(err.Error())
return c.JSON(http.StatusBadRequest, Response{Error: err.Error()})
}</p>
<pre><code>msg, err := messagelayer.IssuePayload(
	payload.NewGenericDataPayload(request.Data), messagelayer.Tangle())
if err != nil {
	return c.JSON(http.StatusBadRequest, Response{Error: err.Error()})
}
return c.JSON(http.StatusOK, Response{ID: msg.ID().String()})
</code></pre>
<p>}</p>
<pre><code>As an example the JSON body   
</code></pre>
<p>{
&quot;data&quot;:&quot;HelloWor&quot;
}</p>
<pre><code>can be sent to `http://127.0.0.1:8080/data`, which will issue a data message containing &quot;HelloWor&quot; (note that in this  example the data input is size limited.)
 
</code></pre>
<h1 id="mana-api-methods"><a class="header" href="#mana-api-methods">Mana API Methods</a></h1>
<p>The mana APIs provide methods for people to retrieve the amount of access/consensus mana of nodes and outputs, as well as the event logs.</p>
<p>HTTP APIs:</p>
<ul>
<li><a href="node-software/goshimmer/docs/apis/mana.html#mana">/mana</a></li>
<li><a href="node-software/goshimmer/docs/apis/mana.html#manaall">/mana/all</a></li>
<li><a href="node-software/goshimmer/docs/apis/mana.html#manapercentile">/mana/percentile</a></li>
<li><a href="node-software/goshimmer/docs/apis/mana.html#manaaccessonline">/mana/access/online</a></li>
<li><a href="node-software/goshimmer/docs/apis/mana.html#manaconsensusonline">/mana/consensus/online</a></li>
<li><a href="node-software/goshimmer/docs/apis/mana.html#manaaccessnhighest">/mana/access/nhighest</a></li>
<li><a href="node-software/goshimmer/docs/apis/mana.html#manaconsensusnhighest">/mana/consensus/nhighest</a></li>
<li><a href="node-software/goshimmer/docs/apis/mana.html#manapending">/mana/pending</a></li>
<li><a href="node-software/goshimmer/docs/apis/mana.html#manaconsensuspast">/mana/consensus/past</a></li>
<li><a href="node-software/goshimmer/docs/apis/mana.html#manaconsensuslogs">/mana/consensus/logs</a></li>
<li><a href="node-software/goshimmer/docs/apis/mana.html#valueallowedmanapledge">/value/allowedManaPledge</a></li>
</ul>
<p>Client lib APIs:</p>
<ul>
<li><a href="node-software/goshimmer/docs/apis/mana.html#getownmana">GetOwnMana()</a></li>
<li><a href="node-software/goshimmer/docs/apis/mana.html#getmanafullnodeid">GetManaFullNodeID()</a></li>
<li><a href="node-software/goshimmer/docs/apis/mana.html#getmana-with-short-node-id">GetMana with short node ID()</a></li>
<li><a href="node-software/goshimmer/docs/apis/mana.html#client-lib---getallmana">GetAllMana()</a></li>
<li><a href="node-software/goshimmer/docs/apis/mana.html#client-lib---getmanapercentile">GetManaPercentile()</a></li>
<li><a href="node-software/goshimmer/docs/apis/mana.html#client-lib---getonlineaccessmana">GetOnlineAccessMana()</a></li>
<li><a href="node-software/goshimmer/docs/apis/mana.html#client-lib---getonlineconsensusmana">GetOnlineConsensusMana()</a></li>
<li><a href="node-software/goshimmer/docs/apis/mana.html#client-lib---getnhighestaccessmana">GetNHighestAccessMana()</a></li>
<li><a href="node-software/goshimmer/docs/apis/mana.html#client-lib---getnhighestconsensusmana">GetNHighestConsensusMana()</a></li>
<li><a href="node-software/goshimmer/docs/apis/mana.html#client-lib---getpending">GetPending()</a></li>
<li><a href="node-software/goshimmer/docs/apis/mana.html#client-lib---getpastconsensusmanavector">GetPastConsensusManaVector()</a></li>
<li><a href="node-software/goshimmer/docs/apis/mana.html#client-lib---getconsensuseventlogs">GetConsensusEventLogs()</a></li>
<li><a href="node-software/goshimmer/docs/apis/mana.html#client-lib---getallowedmanapledgenodeids">GetAllowedManaPledgeNodeIDs()</a></li>
</ul>
<h2 id="mana"><a class="header" href="#mana"><code>/mana</code></a></h2>
<p>Get the access and consensus mana of the node.</p>
<h3 id="parameters-27"><a class="header" href="#parameters-27">Parameters</a></h3>
<table><thead><tr><th><strong>Parameter</strong></th><th><code>node ID</code></th></tr></thead><tbody>
<tr><td><strong>Required or Optional</strong></td><td>optional</td></tr>
<tr><td><strong>Description</strong></td><td>full node ID</td></tr>
<tr><td><strong>Type</strong></td><td>string</td></tr>
</tbody></table>
<h4 id="note"><a class="header" href="#note"><strong>Note</strong></a></h4>
<p>If no node ID is given, it returns the access and consensus mana of the node you're communicating with.</p>
<h3 id="examples-6"><a class="header" href="#examples-6">Examples</a></h3>
<h4 id="curl"><a class="header" href="#curl">cURL</a></h4>
<pre><code class="language-shell">curl http://localhost:8080/mana?2GtxMQD94KvDH1SJPJV7icxofkyV1njuUZKtsqKmtux5 \
-X GET \
-H 'Content-Type: application/json'
</code></pre>
<h4 id="client-lib"><a class="header" href="#client-lib">client lib</a></h4>
<p>There are 3 APIs to get mana of a node, which is based on the same HTTP API <code>/mana</code>.</p>
<h5 id="getownmana"><a class="header" href="#getownmana"><code>GetOwnMana</code></a></h5>
<p>Get the access and consensus mana of the node this API client is communicating with.</p>
<pre><code class="language-go">manas, err := goshimAPI.GetOwnMana()
if err != nil {
    // return error
}

// print the node ID
fmt.Println(&quot;full ID: &quot;, manas.NodeID, &quot;short ID: &quot;, manas.ShortNodeID)

// get access mana of the node
fmt.Println(&quot;access mana: &quot;, manas.Access, &quot;access mana updated time: &quot;, manas.AccessTimestamp)

// get consensus mana of the node
fmt.Println(&quot;consensus mana: &quot;, manas.Consensus, &quot;consensus mana updated time: &quot;, manas.ConsensusTimestamp)
</code></pre>
<h5 id="getmanafullnodeid"><a class="header" href="#getmanafullnodeid"><code>GetManaFullNodeID</code></a></h5>
<p>Get Mana of a node with its full node ID.</p>
<pre><code class="language-go">manas, err := goshimAPI.GetManaFullNodeID(&quot;2GtxMQD94KvDH1SJPJV7icxofkyV1njuUZKtsqKmtux5&quot;)
if err != nil {
    // return error
}
</code></pre>
<h5 id="getmana-with-short-node-id"><a class="header" href="#getmana-with-short-node-id"><code>GetMana</code> with short node ID</a></h5>
<pre><code class="language-go">manas, err := goshimAPI.GetMana(&quot;4AeXyZ26e4G&quot;)
if err != nil {
    // return error
}
</code></pre>
<h3 id="response-examples"><a class="header" href="#response-examples">Response examples</a></h3>
<pre><code class="language-shell">{
  &quot;shortNodeID&quot;: &quot;4AeXyZ26e4G&quot;,
  &quot;nodeID&quot;: &quot;2GtxMQD94KvDH1SJPJV7icxofkyV1njuUZKtsqKmtux5&quot;,
  &quot;access&quot;: 26.5,
  &quot;accessTimestamp&quot;: 1614924295,
  &quot;consensus&quot;: 26.5,
  &quot;consensusTimestamp&quot;: 1614924295,
}
</code></pre>
<h3 id="results"><a class="header" href="#results">Results</a></h3>
<table><thead><tr><th align="left">Return field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>shortNodeID</code></td><td align="left">string</td><td align="left">The short ID of a node.</td></tr>
<tr><td align="left"><code>nodeID</code></td><td align="left">string</td><td align="left">The full ID of a node.</td></tr>
<tr><td align="left"><code>access</code></td><td align="left">float64</td><td align="left">The amount of access mana.</td></tr>
<tr><td align="left"><code>accessTimestamp</code></td><td align="left">int64</td><td align="left">The timestamp of access mana updates.</td></tr>
<tr><td align="left"><code>consensus</code></td><td align="left">float64</td><td align="left">The amount of consensus mana.</td></tr>
<tr><td align="left"><code>consensusTimestamp</code></td><td align="left">int64</td><td align="left">The timestamp of consensus mana updates.</td></tr>
</tbody></table>
<h2 id="manaall"><a class="header" href="#manaall"><code>/mana/all</code></a></h2>
<p>Get the mana perception of the node in the network. You can retrieve the full/short node ID, consensus mana, access mana of each node, and the mana updated time.</p>
<h3 id="parameters-28"><a class="header" href="#parameters-28">Parameters</a></h3>
<p>None.</p>
<h3 id="examples-7"><a class="header" href="#examples-7">Examples</a></h3>
<h4 id="curl-1"><a class="header" href="#curl-1">cURL</a></h4>
<pre><code class="language-shell">curl http://localhost:8080/mana/all \
-X GET \
-H 'Content-Type: application/json'
</code></pre>
<h4 id="client-lib---getallmana"><a class="header" href="#client-lib---getallmana">client lib - <code>GetAllMana()</code></a></h4>
<pre><code class="language-go">manas, err := goshimAPI.GetAllMana()
if err != nil {
    // return error
}

// mana updated time
fmt.Println(&quot;access mana updated time: &quot;, manas.AccessTimestamp)
fmt.Println(&quot;consensus mana updated time: &quot;, manas.ConsensusTimestamp)

// get access mana of each node
for _, m := range manas.Access {
    fmt.Println(&quot;full node ID: &quot;, m.NodeID, &quot;short node ID:&quot;, m.ShortNodeID, &quot;access mana: &quot;, m.Mana)
}

// get consensus mana of each node
for _, m := range manas.Consensus {
    fmt.Println(&quot;full node ID: &quot;, m.NodeID, &quot;short node ID:&quot;, m.ShortNodeID, &quot;consensus mana: &quot;, m.Mana)
}
</code></pre>
<h3 id="response-examples-1"><a class="header" href="#response-examples-1">Response examples</a></h3>
<pre><code class="language-shell">{
  &quot;access&quot;: [
      {
          &quot;shortNodeID&quot;: &quot;4AeXyZ26e4G&quot;,
          &quot;nodeID&quot;: &quot;2GtxMQD94KvDH1SJPJV7icxofkyV1njuUZKtsqKmtux5&quot;,
          &quot;mana&quot;: 26.5
      }
  ],
  &quot;accessTimestamp&quot;: 1614924295,
  &quot;consensus&quot;: [
      {
          &quot;shortNodeID&quot;: &quot;4AeXyZ26e4G&quot;,
          &quot;nodeID&quot;: &quot;2GtxMQD94KvDH1SJPJV7icxofkyV1njuUZKtsqKmtux5&quot;,
          &quot;mana&quot;: 26.5
      }
  ],
  &quot;consensusTimestamp&quot;: 1614924295
}
</code></pre>
<h3 id="results-1"><a class="header" href="#results-1">Results</a></h3>
<table><thead><tr><th align="left">Return field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>access</code></td><td align="left">mana.NodeStr</td><td align="left">A list of node that has access mana.</td></tr>
<tr><td align="left"><code>accessTimestamp</code></td><td align="left">int64</td><td align="left">The timestamp of access mana updates.</td></tr>
<tr><td align="left"><code>consensus</code></td><td align="left">mana.NodeStr</td><td align="left">A list of node that has access mana.</td></tr>
<tr><td align="left"><code>consensusTimestamp</code></td><td align="left">int64</td><td align="left">The timestamp of consensus mana updates.</td></tr>
</tbody></table>
<h4 id="mananodestr"><a class="header" href="#mananodestr"><code>mana.NodeStr</code></a></h4>
<table><thead><tr><th align="left">field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>shortNodeID</code></td><td align="left">string</td><td align="left">The short ID of a node.</td></tr>
<tr><td align="left"><code>nodeID</code></td><td align="left">string</td><td align="left">The full ID of a node.</td></tr>
<tr><td align="left"><code>mana</code></td><td align="left">float64</td><td align="left">The amount of mana.</td></tr>
</tbody></table>
<h2 id="manapercentile"><a class="header" href="#manapercentile"><code>/mana/percentile</code></a></h2>
<p>To learn the top percentile the node belongs to relative to the network in terms of mana. The input should be a full node ID.</p>
<h3 id="parameters-29"><a class="header" href="#parameters-29">Parameters</a></h3>
<table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td><strong>Parameter</strong></td><td><code>node ID</code></td></tr>
<tr><td><strong>Required or Optional</strong></td><td>Required</td></tr>
<tr><td><strong>Description</strong></td><td>full node ID</td></tr>
<tr><td><strong>Type</strong></td><td>string</td></tr>
</tbody></table>
<h3 id="examples-8"><a class="header" href="#examples-8">Examples</a></h3>
<h4 id="curl-2"><a class="header" href="#curl-2">cURL</a></h4>
<pre><code class="language-shell">curl http://localhost:8080/mana/percentile?2GtxMQD94KvDH1SJPJV7icxofkyV1njuUZKtsqKmtux5 \
-X GET \
-H 'Content-Type: application/json'
</code></pre>
<h4 id="client-lib---getmanapercentile"><a class="header" href="#client-lib---getmanapercentile">client lib - <code>GetManaPercentile()</code></a></h4>
<pre><code class="language-go">mana, err := goshimAPI.GetManaPercentile(&quot;2GtxMQD94KvDH1SJPJV7icxofkyV1njuUZKtsqKmtux5&quot;)
if err != nil {
    // return error
}

// mana updated time
fmt.Println(&quot;access mana percentile: &quot;, mana.Access, &quot;access mana updated time: &quot;, manas.AccessTimestamp)
fmt.Println(&quot;consensus mana percentile: &quot;, mana.Consensus, &quot;consensus mana updated time: &quot;, manas.ConsensusTimestamp)
</code></pre>
<h3 id="response-examples-2"><a class="header" href="#response-examples-2">Response examples</a></h3>
<pre><code class="language-shell">{
  &quot;shortNodeID&quot;: &quot;4AeXyZ26e4G&quot;,
  &quot;nodeID&quot;: &quot;2GtxMQD94KvDH1SJPJV7icxofkyV1njuUZKtsqKmtux5&quot;,
  &quot;access&quot;: 75,
  &quot;accessTimestamp&quot;: 1614924295,
  &quot;consensus&quot;: 75,
  &quot;consensusTimestamp&quot;: 1614924295,
}
</code></pre>
<h3 id="results-2"><a class="header" href="#results-2">Results</a></h3>
<table><thead><tr><th align="left">Return field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>shortNodeID</code></td><td align="left">string</td><td align="left">The short ID of a node.</td></tr>
<tr><td align="left"><code>nodeID</code></td><td align="left">string</td><td align="left">The full ID of a node.</td></tr>
<tr><td align="left"><code>access</code></td><td align="left">float64</td><td align="left">Access mana percentile of a node.</td></tr>
<tr><td align="left"><code>accessTimestamp</code></td><td align="left">int64</td><td align="left">The timestamp of access mana updates.</td></tr>
<tr><td align="left"><code>consensus</code></td><td align="left">float64</td><td align="left">Access mana percentile of a node.</td></tr>
<tr><td align="left"><code>consensusTimestamp</code></td><td align="left">int64</td><td align="left">The timestamp of consensus mana updates.</td></tr>
</tbody></table>
<h2 id="manaaccessonline"><a class="header" href="#manaaccessonline"><code>/mana/access/online</code></a></h2>
<p>You can get a sorted list of online access mana of nodes, sorted from the highest access mana to the lowest. The highest access mana node has OnlineRank 1, and increases 1 by 1 for the following nodes.</p>
<h3 id="parameters-30"><a class="header" href="#parameters-30">Parameters</a></h3>
<p>None.</p>
<h3 id="examples-9"><a class="header" href="#examples-9">Examples</a></h3>
<h4 id="curl-3"><a class="header" href="#curl-3">cURL</a></h4>
<pre><code class="language-shell">curl http://localhost:8080/mana/access/online \
-X GET \
-H 'Content-Type: application/json'
</code></pre>
<h4 id="client-lib---getonlineaccessmana"><a class="header" href="#client-lib---getonlineaccessmana">client lib - <code>GetOnlineAccessMana()</code></a></h4>
<pre><code class="language-go">// online access mana
accessMana, err := goshimAPI.GetOnlineAccessMana()
if err != nil {
    // return error
}

for _, m := accessMana.Online {
    fmt.Println(&quot;full node ID: &quot;, m.ID, &quot;mana rank: &quot;, m.OnlineRank, &quot;access mana: &quot;, m.Mana)
}
</code></pre>
<h3 id="response-examples-3"><a class="header" href="#response-examples-3">Response examples</a></h3>
<pre><code class="language-shell">{
  &quot;online&quot;: [
      {
        &quot;rank&quot;: 1,
        &quot;shortNodeID&quot;: &quot;4AeXyZ26e4G&quot;,
        &quot;nodeID&quot;: &quot;2GtxMQD94KvDH1SJPJV7icxofkyV1njuUZKtsqKmtux5&quot;,
        &quot;mana&quot;: 75
      }
  ],  
  &quot;timestamp&quot;: 1614924295
}
</code></pre>
<h3 id="results-3"><a class="header" href="#results-3">Results</a></h3>
<table><thead><tr><th align="left">Return field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>online</code></td><td align="left">OnlineNodeStr</td><td align="left">The access mana information of online nodes.</td></tr>
<tr><td align="left"><code>timestamp</code></td><td align="left">int64</td><td align="left">The timestamp of mana updates.</td></tr>
</tbody></table>
<h4 id="onlinenodestr"><a class="header" href="#onlinenodestr"><code>OnlineNodeStr</code></a></h4>
<table><thead><tr><th align="left">Field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>rank</code></td><td align="left">int</td><td align="left">The rank of a node.</td></tr>
<tr><td align="left"><code>shortNodeID</code></td><td align="left">string</td><td align="left">The short ID of a node.</td></tr>
<tr><td align="left"><code>nodeID</code></td><td align="left">string</td><td align="left">The full ID of a node.</td></tr>
<tr><td align="left"><code>mana</code></td><td align="left">float64</td><td align="left">The amount of access mana.</td></tr>
</tbody></table>
<h2 id="manaconsensusonline"><a class="header" href="#manaconsensusonline"><code>/mana/consensus/online</code></a></h2>
<p>You can get a sorted list of online consensus mana of nodes, sorted from the highest consensus mana to the lowest. The highest consensus mana node has OnlineRank 1, and increases 1 by 1 for the following nodes.</p>
<h3 id="parameters-31"><a class="header" href="#parameters-31">Parameters</a></h3>
<p>None.</p>
<h3 id="examples-10"><a class="header" href="#examples-10">Examples</a></h3>
<h4 id="curl-4"><a class="header" href="#curl-4">cURL</a></h4>
<pre><code class="language-shell">curl http://localhost:8080/mana/consensus/online \
-X GET \
-H 'Content-Type: application/json'
</code></pre>
<h4 id="client-lib---getonlineconsensusmana"><a class="header" href="#client-lib---getonlineconsensusmana">client lib - <code>GetOnlineConsensusMana()</code></a></h4>
<pre><code class="language-go">// online access mana
accessMana, err := goshimAPI.GetOnlineConsensusMana()
if err != nil {
    // return error
}

for _, m := accessMana.Online {
    fmt.Println(&quot;full node ID: &quot;, m.ID, &quot;mana rank: &quot;, m.OnlineRank, &quot;consensus mana: &quot;, m.Mana)
}
</code></pre>
<h3 id="response-examples-4"><a class="header" href="#response-examples-4">Response examples</a></h3>
<pre><code class="language-shell">{
  &quot;online&quot;: [
      {
        &quot;rank&quot;: 1,
        &quot;shortNodeID&quot;: &quot;4AeXyZ26e4G&quot;,
        &quot;nodeID&quot;: &quot;2GtxMQD94KvDH1SJPJV7icxofkyV1njuUZKtsqKmtux5&quot;,
        &quot;mana&quot;: 75
      }
  ],  
  &quot;timestamp&quot;: 1614924295
}
</code></pre>
<h3 id="results-4"><a class="header" href="#results-4">Results</a></h3>
<table><thead><tr><th align="left">Return field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>online</code></td><td align="left">OnlineNodeStr</td><td align="left">The consensus mana information of online nodes.</td></tr>
<tr><td align="left"><code>timestamp</code></td><td align="left">int64</td><td align="left">The timestamp of mana updates.</td></tr>
</tbody></table>
<h4 id="onlinenodestr-1"><a class="header" href="#onlinenodestr-1"><code>OnlineNodeStr</code></a></h4>
<table><thead><tr><th align="left">Field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>rank</code></td><td align="left">int</td><td align="left">The rank of a node.</td></tr>
<tr><td align="left"><code>shortNodeID</code></td><td align="left">string</td><td align="left">The short ID of a node.</td></tr>
<tr><td align="left"><code>nodeID</code></td><td align="left">string</td><td align="left">The full ID of a node.</td></tr>
<tr><td align="left"><code>mana</code></td><td align="left">float64</td><td align="left">The amount of consensus mana.</td></tr>
</tbody></table>
<h2 id="manaaccessnhighest"><a class="header" href="#manaaccessnhighest"><code>/mana/access/nhighest</code></a></h2>
<p>You can get the N highest access mana holders in the network, sorted in descending order.
If N=0, all nodes that have access mana are returned sorted.</p>
<h3 id="parameters-32"><a class="header" href="#parameters-32">Parameters</a></h3>
<table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td><strong>Parameter</strong></td><td><code>N</code></td></tr>
<tr><td><strong>Required or Optional</strong></td><td>Required</td></tr>
<tr><td><strong>Description</strong></td><td>The number of highest mana nodes.</td></tr>
<tr><td><strong>Type</strong></td><td>int</td></tr>
</tbody></table>
<h3 id="examples-11"><a class="header" href="#examples-11">Examples</a></h3>
<h4 id="curl-5"><a class="header" href="#curl-5">cURL</a></h4>
<pre><code class="language-shell">curl http://localhost:8080/mana/access/nhighest?number=5 \
-X GET \
-H 'Content-Type: application/json'
</code></pre>
<h4 id="client-lib---getnhighestaccessmana"><a class="header" href="#client-lib---getnhighestaccessmana">client lib - <code>GetNHighestAccessMana()</code></a></h4>
<pre><code class="language-go">// get the top 5 highest access mana nodes
accessMana, err := goshimAPI.GetNHighestAccessMana(5)
if err != nil {
    // return error
}

for _, m := accessMana.Nodes {
    fmt.Println(&quot;full node ID: &quot;, m.NodeID, &quot;access mana: &quot;, m.Mana)
}v
</code></pre>
<h3 id="response-examples-5"><a class="header" href="#response-examples-5">Response examples</a></h3>
<pre><code class="language-shell">{
  &quot;nodes&quot;: [
      {
        &quot;shortNodeID&quot;: &quot;4AeXyZ26e4G&quot;,
        &quot;nodeID&quot;: &quot;2GtxMQD94KvDH1SJPJV7icxofkyV1njuUZKtsqKmtux5&quot;,
        &quot;mana&quot;: 26.5
      }
  ],  
  &quot;timestamp&quot;: 1614924295
}
</code></pre>
<h3 id="results-5"><a class="header" href="#results-5">Results</a></h3>
<table><thead><tr><th align="left">Return field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>nodes</code></td><td align="left">mana.NodeStr</td><td align="left">The N highest access mana nodes.</td></tr>
<tr><td align="left"><code>timestamp</code></td><td align="left">int64</td><td align="left">The timestamp of mana updates.</td></tr>
</tbody></table>
<h4 id="mananodestr-1"><a class="header" href="#mananodestr-1"><code>mana.NodeStr</code></a></h4>
<table><thead><tr><th align="left">field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>shortNodeID</code></td><td align="left">string</td><td align="left">The short ID of a node.</td></tr>
<tr><td align="left"><code>nodeID</code></td><td align="left">string</td><td align="left">The full ID of a node.</td></tr>
<tr><td align="left"><code>mana</code></td><td align="left">float64</td><td align="left">The amount of mana.</td></tr>
</tbody></table>
<h2 id="manaconsensusnhighest"><a class="header" href="#manaconsensusnhighest"><code>/mana/consensus/nhighest</code></a></h2>
<p>You can get the N highest consensus mana holders in the network, sorted in descending order.</p>
<h3 id="parameters-33"><a class="header" href="#parameters-33">Parameters</a></h3>
<table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td><strong>Parameter</strong></td><td><code>N</code></td></tr>
<tr><td><strong>Required or Optional</strong></td><td>Required</td></tr>
<tr><td><strong>Description</strong></td><td>The number of highest consensus mana nodes.</td></tr>
<tr><td><strong>Type</strong></td><td>int</td></tr>
</tbody></table>
<h3 id="examples-12"><a class="header" href="#examples-12">Examples</a></h3>
<h4 id="curl-6"><a class="header" href="#curl-6">cURL</a></h4>
<pre><code class="language-shell">curl http://localhost:8080/mana/consensus/nhighest?number=5 \
-X GET \
-H 'Content-Type: application/json'
</code></pre>
<h4 id="client-lib---getnhighestconsensusmana"><a class="header" href="#client-lib---getnhighestconsensusmana">client lib - <code>GetNHighestConsensusMana()</code></a></h4>
<pre><code class="language-go">// get the top 5 highest consensus mana nodes
consensusMana, err := goshimAPI.GetNHighestConsensusMana(5)
if err != nil {
    // return error
}

for _, m := consensusMana.Nodes {
    fmt.Println(&quot;full node ID: &quot;, m.NodeID, &quot;consensus mana: &quot;, m.Mana)
}v
</code></pre>
<h3 id="response-examples-6"><a class="header" href="#response-examples-6">Response examples</a></h3>
<pre><code class="language-shell">{
  &quot;nodes&quot;: [
      {
        &quot;shortNodeID&quot;: &quot;4AeXyZ26e4G&quot;,
        &quot;nodeID&quot;: &quot;2GtxMQD94KvDH1SJPJV7icxofkyV1njuUZKtsqKmtux5&quot;,
        &quot;mana&quot;: 26.5
      }
  ],  
  &quot;timestamp&quot;: 1614924295
}
</code></pre>
<h3 id="results-6"><a class="header" href="#results-6">Results</a></h3>
<table><thead><tr><th align="left">Return field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>nodes</code></td><td align="left">mana.NodeStr</td><td align="left">The N highest consensus mana nodes.</td></tr>
<tr><td align="left"><code>timestamp</code></td><td align="left">int64</td><td align="left">The timestamp of mana updates.</td></tr>
</tbody></table>
<h4 id="mananodestr-2"><a class="header" href="#mananodestr-2"><code>mana.NodeStr</code></a></h4>
<table><thead><tr><th align="left">field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>shortNodeID</code></td><td align="left">string</td><td align="left">The short ID of a node.</td></tr>
<tr><td align="left"><code>nodeID</code></td><td align="left">string</td><td align="left">The full ID of a node.</td></tr>
<tr><td align="left"><code>mana</code></td><td align="left">float64</td><td align="left">The amount of mana.</td></tr>
</tbody></table>
<h2 id="manapending"><a class="header" href="#manapending"><code>/mana/pending</code></a></h2>
<p>Get the amount of base access mana that would be pledged if the given output was spent.</p>
<h3 id="parameters-34"><a class="header" href="#parameters-34">Parameters</a></h3>
<table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td><strong>Parameter</strong></td><td><code>outputID</code></td></tr>
<tr><td><strong>Required or Optional</strong></td><td>Required</td></tr>
<tr><td><strong>Description</strong></td><td>The requesting output ID.</td></tr>
<tr><td><strong>Type</strong></td><td>string</td></tr>
</tbody></table>
<h3 id="examples-13"><a class="header" href="#examples-13">Examples</a></h3>
<h4 id="curl-7"><a class="header" href="#curl-7">cURL</a></h4>
<pre><code class="language-shell">curl http://localhost:8080/mana/pending?outputid=&quot;4a5KkxVfsdFVbf1NBGeGTCjP8Ppsje4YFQg9bu5YGNMSJK1&quot; \
-X GET \
-H 'Content-Type: application/json'
</code></pre>
<h4 id="client-lib---getpending"><a class="header" href="#client-lib---getpending">client lib - <code>GetPending()</code></a></h4>
<pre><code class="language-go">res, err := goshimAPI.GetPending(&quot;4a5KkxVfsdFVbf1NBGeGTCjP8Ppsje4YFQg9bu5YGNMSJK1&quot;)
if err != nil {
    // return error
}

// get the amount of mana
fmt.Println(&quot;mana be pledged: &quot;, res.Mana)
fmt.Println(&quot;the timestamp of the output (decay duration)&quot;, res.Timestamp)
</code></pre>
<h3 id="response-examples-7"><a class="header" href="#response-examples-7">Response examples</a></h3>
<pre><code class="language-shell">{
  &quot;mana&quot;: 26.5,
  &quot;outputID&quot;: &quot;4a5KkxVfsdFVbf1NBGeGTCjP8Ppsje4YFQg9bu5YGNMSJK1&quot;,  
  &quot;timestamp&quot;: 1614924295
}
</code></pre>
<h3 id="results-7"><a class="header" href="#results-7">Results</a></h3>
<table><thead><tr><th align="left">Return field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>mana</code></td><td align="left">float64</td><td align="left">The amount of access base mana to be pledged.</td></tr>
<tr><td align="left"><code>outputID</code></td><td align="left">string</td><td align="left">The output ID of the request.</td></tr>
<tr><td align="left"><code>timestamp</code></td><td align="left">int64</td><td align="left">The timestamp of mana updates.</td></tr>
</tbody></table>
<h2 id="manaconsensuspast"><a class="header" href="#manaconsensuspast"><code>/mana/consensus/past</code></a></h2>
<p>Get the consensus base mana vector of a time (int64) in the past.</p>
<h3 id="parameters-35"><a class="header" href="#parameters-35">Parameters</a></h3>
<table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td><strong>Parameter</strong></td><td><code>timestamp</code></td></tr>
<tr><td><strong>Required or Optional</strong></td><td>Required</td></tr>
<tr><td><strong>Description</strong></td><td>The timestamp of the request.</td></tr>
<tr><td><strong>Type</strong></td><td>int64</td></tr>
</tbody></table>
<h3 id="examples-14"><a class="header" href="#examples-14">Examples</a></h3>
<h4 id="curl-8"><a class="header" href="#curl-8">cURL</a></h4>
<pre><code class="language-shell">curl http://localhost:8080/mana/consensus/past?timestamp=1614924295 \
-X GET \
-H 'Content-Type: application/json'
</code></pre>
<h4 id="client-lib---getpastconsensusmanavector"><a class="header" href="#client-lib---getpastconsensusmanavector">client lib - <code>GetPastConsensusManaVector()</code></a></h4>
<pre><code class="language-go">res, err := goshimAPI.GetPastConsensusManaVector(1614924295)
if err != nil {
    // return error
}

// the mana vector of each node
for _, m := range res.Consensus {
    fmt.Println(&quot;node ID:&quot;, m.NodeID, &quot;consensus mana: &quot;, m.Mana)
}
</code></pre>
<h3 id="response-examples-8"><a class="header" href="#response-examples-8">Response examples</a></h3>
<pre><code class="language-shell">{
  &quot;consensus&quot;: [
      {
        &quot;shortNodeID&quot;: &quot;4AeXyZ26e4G&quot;,
        &quot;nodeID&quot;: &quot;2GtxMQD94KvDH1SJPJV7icxofkyV1njuUZKtsqKmtux5&quot;,
        &quot;mana&quot;: 26.5 
      }
  ],  
  &quot;timestamp&quot;: 1614924295
}
</code></pre>
<h3 id="results-8"><a class="header" href="#results-8">Results</a></h3>
<table><thead><tr><th align="left">Return field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>consensus</code></td><td align="left">mana.NodeStr</td><td align="left">The consensus mana of nodes.</td></tr>
<tr><td align="left"><code>timestamp</code></td><td align="left">int64</td><td align="left">The timestamp of mana updates.</td></tr>
</tbody></table>
<h4 id="mananodestr-3"><a class="header" href="#mananodestr-3"><code>mana.NodeStr</code></a></h4>
<table><thead><tr><th align="left">field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>shortNodeID</code></td><td align="left">string</td><td align="left">The short ID of a node.</td></tr>
<tr><td align="left"><code>nodeID</code></td><td align="left">string</td><td align="left">The full ID of a node.</td></tr>
<tr><td align="left"><code>mana</code></td><td align="left">float64</td><td align="left">The amount of mana.</td></tr>
</tbody></table>
<h2 id="manaconsensuslogs"><a class="header" href="#manaconsensuslogs"><code>/mana/consensus/logs</code></a></h2>
<p>Get the consensus event logs of the given node IDs.</p>
<h3 id="parameters-36"><a class="header" href="#parameters-36">Parameters</a></h3>
<table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td><strong>Parameter</strong></td><td><code>nodeIDs</code></td></tr>
<tr><td><strong>Required or Optional</strong></td><td>Required</td></tr>
<tr><td><strong>Description</strong></td><td>A list of node ID of the request.</td></tr>
<tr><td><strong>Type</strong></td><td>string array</td></tr>
</tbody></table>
<h3 id="examples-15"><a class="header" href="#examples-15">Examples</a></h3>
<h4 id="curl-9"><a class="header" href="#curl-9">cURL</a></h4>
<pre><code class="language-shell">curl http://localhost:8080/mana/consensus/logs \
-X GET \
-H 'Content-Type: application/json'
-d '{
  &quot;nodeIDs&quot;: [
    &quot;2GtxMQD94KvDH1SJPJV7icxofkyV1njuUZKtsqKmtux5&quot;,
    &quot;2GtxMQD94KvDH1SJPJV7icxofkyV1njuUZKtsqKmtux6&quot;
  ]
}'
</code></pre>
<h4 id="client-lib---getconsensuseventlogs"><a class="header" href="#client-lib---getconsensuseventlogs">client lib - <code>GetConsensusEventLogs()</code></a></h4>
<pre><code class="language-go">res, err := goshimAPI.GetConsensusEventLogs([]string{&quot;2GtxMQD94KvDH1SJPJV7icxofkyV1njuUZKtsqKmtux5&quot;})
if err != nil {
    // return error
}

for nodeID, e := range res.Logs {
    fmt.Println(&quot;node ID:&quot;, nodeID)
    
    // pledge logs
    for _, p := e.Pledge {
        fmt.Println(&quot;mana type: &quot;, p.ManaType)
        fmt.Println(&quot;node ID: &quot;, p.NodeID)
        fmt.Println(&quot;time: &quot;, p.Time)
        fmt.Println(&quot;transaction ID: &quot;, p.TxID)
        fmt.Println(&quot;mana amount: &quot;, p.Amount)
    }

    // revoke logs
    for _, r := e.Revoke {
        fmt.Println(&quot;mana type: &quot;, r.ManaType)
        fmt.Println(&quot;node ID: &quot;, r.NodeID)
        fmt.Println(&quot;time: &quot;, r.Time)
        fmt.Println(&quot;transaction ID: &quot;, r.TxID)
        fmt.Println(&quot;mana amount: &quot;, r.Amount)
        fmt.Println(&quot;input ID: &quot;, r.InputID)
    }
}
</code></pre>
<h3 id="response-examples-9"><a class="header" href="#response-examples-9">Response examples</a></h3>
<pre><code class="language-shell">{
  &quot;logs&quot;: [
      &quot;2GtxMQD94KvDH1SJPJV7icxofkyV1njuUZKtsqKmtux5&quot;: {
          &quot;pledge&quot;: [
              {
                  &quot;manaType&quot;: &quot;Consensus&quot;,
                  &quot;nodeID&quot;: &quot;2GtxMQD94KvDH1SJPJV7icxofkyV1njuUZKtsqKmtux5&quot;,
                  &quot;time&quot;: 1614924295,
                  &quot;txID&quot;: &quot;7oAfcEhodkfVyGyGrobBpRrjjdsftQknpj5KVBQjyrda&quot;,
                  &quot;amount&quot;: 28
               }
          ],
          &quot;revoke&quot;: [
              {
                  &quot;manaType&quot;: &quot;Consensus&quot;,
                  &quot;nodeID&quot;: &quot;2GtxMQD94KvDH1SJPJV7icxofkyV1njuUZKtsqKmtux5&quot;,
                  &quot;time&quot;: 1614924295,
                  &quot;txID&quot;: &quot;7oAfcEhodkfVyGyGrobBpRrjjdsftQknpj5KVBQjyrda&quot;,
                  &quot;amount&quot;: 28,
                  &quot;inputID&quot;: &quot;35P4cW9QfzHNjXJwZMDMCUxAR7F9mfm6FvPbdpJWudK2nBZ&quot;
              }
          ]
      }
  ],  
  &quot;startTime&quot;: 1614924295,
  &quot;endTime&quot;: 1614924300
}
</code></pre>
<h3 id="results-9"><a class="header" href="#results-9">Results</a></h3>
<table><thead><tr><th align="left">Return field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>logs</code></td><td align="left">map[string]*EventLogsJSON</td><td align="left">The consensus mana of nodes. The key of map is node ID.</td></tr>
<tr><td align="left"><code>startTime</code></td><td align="left">int64</td><td align="left">The starting time of collecting logs.</td></tr>
<tr><td align="left"><code>endTime</code></td><td align="left">int64</td><td align="left">The ending time of collecting logs.</td></tr>
</tbody></table>
<h4 id="eventlogsjson"><a class="header" href="#eventlogsjson"><code>EventLogsJSON</code></a></h4>
<table><thead><tr><th align="left">field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>pledge</code></td><td align="left">PledgedEventJSON</td><td align="left">Pledged event logs.</td></tr>
<tr><td align="left"><code>revoke</code></td><td align="left">RevokedEventJSON</td><td align="left">Revoked event logs.</td></tr>
</tbody></table>
<h4 id="pledgedeventjson"><a class="header" href="#pledgedeventjson"><code>PledgedEventJSON</code></a></h4>
<table><thead><tr><th align="left">field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>manaType</code></td><td align="left">string</td><td align="left">Type of mana.</td></tr>
<tr><td align="left"><code>nodeID</code></td><td align="left">string</td><td align="left">The full ID of a node.</td></tr>
<tr><td align="left"><code>time</code></td><td align="left">int64</td><td align="left">The time of transaction.</td></tr>
<tr><td align="left"><code>txID</code></td><td align="left">string</td><td align="left">The transaction ID of pledged mana.</td></tr>
<tr><td align="left"><code>amount</code></td><td align="left">float64</td><td align="left">The amount of pledged mana.</td></tr>
</tbody></table>
<h4 id="revokedeventjson"><a class="header" href="#revokedeventjson"><code>RevokedEventJSON</code></a></h4>
<table><thead><tr><th align="left">field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>manaType</code></td><td align="left">string</td><td align="left">Type of mana.</td></tr>
<tr><td align="left"><code>nodeID</code></td><td align="left">string</td><td align="left">The full ID of a node.</td></tr>
<tr><td align="left"><code>time</code></td><td align="left">int64</td><td align="left">The time of transaction.</td></tr>
<tr><td align="left"><code>txID</code></td><td align="left">string</td><td align="left">The transaction ID of revoked mana.</td></tr>
<tr><td align="left"><code>amount</code></td><td align="left">float64</td><td align="left">The amount of revoked mana.</td></tr>
<tr><td align="left"><code>inputID</code></td><td align="left">string</td><td align="left">The input ID of revoked mana.</td></tr>
</tbody></table>
<h2 id="valueallowedmanapledge"><a class="header" href="#valueallowedmanapledge"><code>/value/allowedManaPledge</code></a></h2>
<p>This returns the list of allowed mana pledge node IDs.</p>
<h3 id="parameters-37"><a class="header" href="#parameters-37">Parameters</a></h3>
<p>None.</p>
<h3 id="examples-16"><a class="header" href="#examples-16">Examples</a></h3>
<h4 id="curl-10"><a class="header" href="#curl-10">cURL</a></h4>
<pre><code class="language-shell">curl http://localhost:8080/value/allowedManaPledge \
-X GET \
-H 'Content-Type: application/json'
</code></pre>
<h4 id="client-lib---getallowedmanapledgenodeids"><a class="header" href="#client-lib---getallowedmanapledgenodeids">client lib - <code>GetAllowedManaPledgeNodeIDs()</code></a></h4>
<pre><code class="language-go">res, err := goshimAPI.GetAllowedManaPledgeNodeIDs()
if err != nil {
    // return error
}

// print the list of nodes that access mana is allowed to be pledged to
for _, id := range res.Access.Allowed {
    fmt.Println(&quot;node ID:&quot;, id)
}

// print the list of nodes that consensus mana is allowed to be pledged to
for _, id := range res.Consensus.Allowed {
    fmt.Println(&quot;node ID:&quot;, id)
}
</code></pre>
<h3 id="response-examples-10"><a class="header" href="#response-examples-10">Response examples</a></h3>
<pre><code class="language-shell">{
  &quot;accessMana&quot;: {
      &quot;isFilterEnabled&quot;: false,
      &quot;allowed&quot;: [
          &quot;2GtxMQD94KvDH1SJPJV7icxofkyV1njuUZKtsqKmtux5&quot;
      ] 
  }
  &quot;consensusMana&quot;: {
      &quot;isFilterEnabled&quot;: false,
      &quot;allowed&quot;: [
          &quot;2GtxMQD94KvDH1SJPJV7icxofkyV1njuUZKtsqKmtux5&quot;
      ] 
  }
}
</code></pre>
<h3 id="results-10"><a class="header" href="#results-10">Results</a></h3>
<table><thead><tr><th align="left">Return field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>accessMana</code></td><td align="left">AllowedPledge</td><td align="left">A list of nodes that allow to pledge access mana.</td></tr>
<tr><td align="left"><code>consensusMana</code></td><td align="left">AllowedPledge</td><td align="left">A list of nodes that allow to pledge consensus mana.</td></tr>
</tbody></table>
<h4 id="allowedpledge"><a class="header" href="#allowedpledge"><code>AllowedPledge</code></a></h4>
<table><thead><tr><th align="left">field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>isFilterEnabled</code></td><td align="left">bool</td><td align="left">A flag shows that if mana pledge filter is enabled.</td></tr>
<tr><td align="left"><code>allowed</code></td><td align="left">[]string</td><td align="left">A list of node ID that allow to be pledged mana.</td></tr>
</tbody></table>
<p>The dRNG module provides API to retrieve both information on the committees as well as the latest randomness.</p>
<pre><code class="language-bash">curl --request GET \
  --url http://&lt;address&gt;:&lt;port&gt;/drng/info/committee
</code></pre>
<p>Should give a similar output:</p>
<pre><code class="language-json">{
  &quot;committees&quot;: [
    {
      &quot;instanceID&quot;: 1339,
      &quot;threshold&quot;: 4,
      &quot;identities&quot;: [
        &quot;GUdTwLDb6t6vZ7X5XzEnjFNDEVPteU7tVQ9nzKLfPjdo&quot;,
        &quot;68vNzBFE9HpmWLb2x4599AUUQNuimuhwn3XahTZZYUHt&quot;,
        &quot;Dc9n3JxYecaX3gpxVnWb4jS3KVz1K1SgSK1KpV1dzqT1&quot;,
        &quot;75g6r4tqGZhrgpDYZyZxVje1Qo54ezFYkCw94ELTLhPs&quot;,
        &quot;CN1XLXLHT9hv7fy3qNhpgNMD6uoHFkHtaNNKyNVCKybf&quot;,
        &quot;7SmttyqrKMkLo5NPYaiFoHs8LE6s7oCoWCQaZhui8m16&quot;,
        &quot;CypSmrHpTe3WQmCw54KP91F5gTmrQEL7EmTX38YStFXx&quot;
      ],
      &quot;distributedPK&quot;: &quot;901b0def227621364c784124cfa54a1e9b582a3867004511e6810307a8985ef84ff02541a9de4f30b8ff2d0b2972735c&quot;
    },
    {
      &quot;instanceID&quot;: 1,
      &quot;threshold&quot;: 3,
      &quot;identities&quot;: [
        &quot;AheLpbhRs1XZsRF8t8VBwuyQh9mqPHXQvthV5rsHytDG&quot;,
        &quot;FZ28bSTidszUBn8TTCAT9X1nVMwFNnoYBmZ1xfafez2z&quot;,
        &quot;GT3UxryW4rA9RN9ojnMGmZgE2wP7psagQxgVdA4B9L1P&quot;,
        &quot;4pB5boPvvk2o5MbMySDhqsmC2CtUdXyotPPEpb7YQPD7&quot;,
        &quot;64wCsTZpmKjRVHtBKXiFojw7uw3GszumfvC4kHdWsHga&quot;
      ],
      &quot;distributedPK&quot;: &quot;884bc65f1d023d84e2bd2e794320dc29600290ca7c83fefb2455dae2a07f2ae4f969f39de6b67b8005e3a328bb0196de&quot;
    }
  ]
}
</code></pre>
<pre><code class="language-bash">curl --request GET \
  --url http://&lt;address&gt;:&lt;port&gt;/drng/info/randomness
</code></pre>
<p>Should give a similar output:</p>
<pre><code class="language-json">{
  &quot;randomness&quot;: [
    {
      &quot;instanceID&quot;: 1,
      &quot;round&quot;: 489295,
      &quot;timestamp&quot;: &quot;2020-10-08T09:40:30.291940965Z&quot;,
      &quot;randomness&quot;: &quot;Dh62wImUx3zQ7sjZ6ulje+NvvPY1DYaUFrTmCP7gOWLQIHHcAF5o9bvRy0tanoHb3q3OlNHKO/DmpDc+SB6A1g==&quot;
    },
    {
      &quot;instanceID&quot;: 1339,
      &quot;round&quot;: 229624,
      &quot;timestamp&quot;: &quot;2020-10-08T09:40:30.253587073Z&quot;,
      &quot;randomness&quot;: &quot;EfQLVEwGlKrHhPAuZPd+JYXl19ZH03MW9m+D07UHjqnO/AuthbCYFY8AsVe4wu0s3P63HQ5N0dv5X+N5kvrIWw==&quot;
    }
  ]
}
</code></pre>
<h1 id="communication-layer-apis"><a class="header" href="#communication-layer-apis">Communication Layer APIs</a></h1>
<p>The communication layer represents the base Tangle layer where so called <code>Messages</code> are gossiped around. A <code>Message</code> contains payloads and it is up to upper layers to interpret and derive functionality out of them.</p>
<p>The API provides three functions to interact with this primitive layer:</p>
<ul>
<li><code>Data(data []byte) (string, error)</code></li>
<li><code>FindMessageByID(base58EncodedIDs []string) (*webapi_message.Response, error)</code></li>
<li><code>SendPayload(payload []byte) (string, error)</code></li>
</ul>
<h4 id="issuing-a-data-message"><a class="header" href="#issuing-a-data-message">Issuing a data message</a></h4>
<p>A data message is simply a <code>Message</code> containing some raw data (literally bytes). This type of message has therefore no real functionality other than that it is retrievable via <code>FindMessageByID</code>.</p>
<p>Example:</p>
<pre><code>messageID, err := goshimAPI.Data([]byte(&quot;Hello GoShimmer World&quot;))
</code></pre>
<p>Note that there is no need to do any additional work, since things like tip-selection, PoW and other tasks are done by the node itself.</p>
<h4 id="retrieve-messages"><a class="header" href="#retrieve-messages">Retrieve messages</a></h4>
<p>Of course messages can then be retrieved via <code>FindMessageByID()</code></p>
<pre><code>foundMsgs, err := goshimAPI.FindMessageByID([]string{base58EncodedMessageID})
if err != nil {
    // return error
}

// this might be nil if the message wasn't available
message := foundMsgs[0]
if message == nil {
    // return error
}

// will print &quot;Hello GoShimmer World&quot;
fmt.Println(string(message.Payload))
</code></pre>
<p>Note that we're getting actual <code>Message</code> objects from this call which represent a vertex in the communication layer Tangle. It does not matter what type of payload the message contains, meaning that <code>FindMessageByID</code> will also return messages which contain value objects or DRNG payloads.</p>
<h4 id="send-payload"><a class="header" href="#send-payload">Send Payload</a></h4>
<p><code>SendPayload()</code> takes a <code>payload</code> object of any type (data, value, drng, etc.) as a byte slice, issues a message with the given payload and returns its <code>messageID</code>. Note, that the payload must be valid, otherwise an error is returned.</p>
<p>Example:</p>
<pre><code class="language-go">helloPayload := payload.NewData([]byte{&quot;Hello Goshimmer World!&quot;})
messageID, err := goshimAPI.SendPayload(helloPayload.Bytes())
</code></pre>
<h1 id="value-layer-apis"><a class="header" href="#value-layer-apis">Value Layer APIs</a></h1>
<p>The value layer builds on top of the communication layer. It encapsulates the functionality of token transfers, ledger representation, conflict state and consensus via FPC.</p>
<p>Note that the value layer operates on <code>Value Objects</code> which is a payload type which is transferred via <code>Messages</code>. A <code>Value Object</code> encapsulates the transaction spending <a href="https://en.wikipedia.org/wiki/Unspent_transaction_output">UTXOs</a> to new outputs and references two other <code>Value Objects</code>. Please refer to <a href="https://github.com/iotaledger/goshimmer/wiki/Concepts-&amp;-Layers">concepts &amp; layers</a> for a more in depth explanation of the value layer.</p>
<p>The API provides multiple functions to interact with the value layer and retrieve/issue the corresponding objects described above.</p>
<h4 id="retrieve-attachmentsvalue-objects"><a class="header" href="#retrieve-attachmentsvalue-objects">Retrieve attachments/value objects</a></h4>
<p>Attachments are <code>Value Objects</code> which reflect a vertex in the value layer Tangle. Note that a transaction can live in multiple <code>Value Objects</code> but one <code>Value Object</code> contains only one transaction.</p>
<p>You can retrieve all the <code>Value Objects</code> which attached a given transaction via <code>GetAttachments()</code>:</p>
<pre><code>attachments, err := goshimAPI.GetAttachments(base58EncodedTxID)
if err != nil {
    // return error
}

// print out the parents of the value object/attachment location
fmt.Println(attachments[0].ParentID0, attachments[0].ParentID1)
</code></pre>
<h4 id="retrieve-transactions"><a class="header" href="#retrieve-transactions">Retrieve transactions</a></h4>
<p>A transaction encapsulates the transfer from unspent transaction outputs to new outputs. </p>
<p>You can use <code>GetTransactionByID</code> to get a given transaction:</p>
<pre><code>tx, err := goshimAPI.GetAttachments(base58EncodedTxID)
if err != nil {
    // return error
}

// print transaction's confirmed state
inclState := tx.InclusionState
fmt.Printf(&quot;confirmation state: %v&quot;, inclState.Confirmed)

// print number of used UTXOs and created outputs
fmt.Println(&quot;inputs:&quot;, len(tx.Transaction.Inputs))
fmt.Println(&quot;outputs:&quot;, len(tx.Transaction.Outputs))
</code></pre>
<h4 id="send-transactions"><a class="header" href="#send-transactions">Send transactions</a></h4>
<p>Sending a transaction involves first creating a transaction object defining the UTXOs to consume and the definition of the outputs. In this example, we create a transaction spending the genesis output onto a new address:</p>
<pre><code>// create the output ID to reference as input in our transaction
genesisSeedBytes, _ := base58.Decode(&quot;7R1itJx5hVuo9w9hjg5cwKFmek4HMSoBDgJZN8hKGxih&quot;)
genesisWallet := wallet.New(genesisSeedBytes)
genesisAddr := genesisWallet.Seed().Address(0)
genesisOutputID := transaction.NewOutputID(genesisAddr, transaction.GenesisID)

// receiver
receiverWallet := wallet.New()
destAddr := receiverWallet.Seed().Address(0)

// create the transaction
tx := transaction.New(
    transaction.NewInputs(genesisOutputID),
    transaction.NewOutputs(map[address.Address][]*balance.Balance{
        destAddr: {
            {Value: genesisBalance, Color: balance.ColorIOTA},
        },
}))

// sign it
tx = tx.Sign(signaturescheme.ED25519(*genesisWallet.Seed().KeyPair(0)))

// issue it
txID, err := goshimAPI.SendTransaction(tx.Bytes())
if err != nil {
    // return error
}

// base58 transaction hash: 9TtYfSP7Y3ipQBQVWVKeunKVMyxgVfGRXLkEZ6kLR1mP
fmt.Println(txID)
</code></pre>
<p>Note that the node will perform tip-selection and therefore decide the attachment location of the <code>Value Object</code> encapsulating the transaction.</p>
<h4 id="retrieve-utxosbalances"><a class="header" href="#retrieve-utxosbalances">Retrieve UTXOs/balances</a></h4>
<p>The balances of an address are made up from the UTXOs residing on that address. A balance is an amount of tokens and their corresponding color. A UTXO may contain multiple balances with different colors.</p>
<p>Lets retrieve the UTXO of the transaction we issued above:</p>
<pre><code>utxos, err := goshimAPI.GetUnspentOutputs([]string{destAddr.String()})
if err != nil {
    // return error
}

// get the balance of the first UTXO
outputs := utxos.UnspentOutputs[0]
output := outputs.OutputIDs[0]
fmt.Printf(&quot;output %s has a balance of %d\n&quot;, output.ID, output.Balances[0].Value)

// UTXOs also have inclusion states
if output.InclusionState.Confirmed {
    fmt.Printf(&quot;the balance of output %s is confirmed\n&quot;, output.ID)
}

</code></pre>
<p>Note that normally you should interact with UTXOs through a higher level of abstraction since most use cases evolve around things like getting the total confirmed balance, spendable inputs etc., which can be cumbersome when  operating directly on UTXOs.</p>
<h4 id="coloring-tokens"><a class="header" href="#coloring-tokens">Coloring tokens</a></h4>
<p>As an issuer of a transaction, you're free to color all the tokens of the inputs you spend to a new color of tokens. Note again, that a balance is an amount of tokens and a color. </p>
<p>In order to color tokens, we declare in our output the color of the balance to be of type <code>balance.ColorNew</code>. When we declare <code>balance.ColorNew</code>, the node is instructed to set the color of the balance to be equal to the hash of the transaction in which the output is created.</p>
<p>Taking the example from above where we spend the genesis output, we just need to make a minor adjustment to create new colored tokens:</p>
<pre><code>tx := transaction.New(
    transaction.NewInputs(genesisOutputID),
    transaction.NewOutputs(map[address.Address][]*balance.Balance{
        destAddr: {
            {Value: genesisBalance, Color: balance.ColorNew},
        },
}))
</code></pre>
<p>The color will then be equivalent to the transaction ID.</p>
<p>Note that coloring tokens doesn't increase/decrease the supply of tokens by any means. It merely colors the tokens and it is up to applications to interpret their intend.</p>
<h1 id="tooling"><a class="header" href="#tooling">Tooling</a></h1>
<h1 id="docker-private-network"><a class="header" href="#docker-private-network">Docker private network</a></h1>
<p>We provide a tool at <code>tools/docker-network</code> with which a local test network can be set up locally with docker. </p>
<p><img src="node-software/goshimmer/docs/tooling/../../images/docker-network.png" alt="Docker network" /></p>
<h2 id="how-to-use-the-tool"><a class="header" href="#how-to-use-the-tool">How to use the tool</a></h2>
<p>In the docker network run for example</p>
<pre><code>./run.sh 5 1
</code></pre>
<p>The command <code>./run.sh</code> spins up a GoShimmer network within Docker as schematically shown in the figure above. The first integer input defines the number of <code>peer_replicas</code> <code>N</code>. The second argument is optional for activating the Grafana dashboard, where </p>
<ul>
<li>default (no argument) or 0: Grafana disabled</li>
<li>1: Grafana enabled</li>
</ul>
<p>More details on how to set up the dashboard can be found <a href="https://github.com/iotaledger/goshimmer/wiki/Setup-up-a-GoShimmer-node-(Joining-the-pollen-testnet)#setting-up-the-grafana-dashboard">here</a>.</p>
<p>The peers can communicate freely within the Docker network 
while the analysis and visualizer dashboard, as well as the <code>master_peer's</code> dashboard and web API are reachable from the host system on the respective ports.</p>
<p>The settings for the different containers (<code>entry_node</code>, <code>peer_master</code>, <code>peer_replica</code>) can be modified in <code>docker-compose.yml</code>.</p>
<h2 id="how-to-use-as-development-tool"><a class="header" href="#how-to-use-as-development-tool">How to use as development tool</a></h2>
<p>Using a standalone throwaway Docker network can be really helpful as a development tool. </p>
<p>Prerequisites: </p>
<ul>
<li>Docker 17.12.0+</li>
<li>Docker compose: file format 3.5</li>
</ul>
<p>Reachable from the host system</p>
<ul>
<li>analysis dashboard (autopeering visualizer): http://localhost:9000</li>
<li><code>master_peer's</code> dashboard: http: http://localhost:8081</li>
<li><code>master_peer's</code> web API: http: http://localhost:8080</li>
</ul>
<p>It is therefore possible to send messages to the local network via the <code>master_peer</code>. Log messages of a specific containter can be followed via </p>
<pre><code>docker logs --follow CONTAINERNAME
</code></pre>
<h2 id="how-to-use-message-approval-check-tool"><a class="header" href="#how-to-use-message-approval-check-tool">How to use message approval check tool</a></h2>
<p><code>get_approval_csv.sh</code> script helps you conveniently trigger the message approval checks on all nodes in the docker
network, and gather their results in the <code>csv</code> folder.</p>
<p>Once the network is up and running, execute the script:</p>
<pre><code>./get_approval_csv.sh
</code></pre>
<p>Example output:</p>
<pre><code>Triggering approval analysis on peer_master and 20 replicas...
Triggering approval analysis on peer_master and 20 replicas... DONE
Copying csv files from peer_master and 20 replicas...
Copying csv files from peer_master and 20 replicas... DONE
Copied files are located at ./csv
</code></pre>
<p>The exported csv files are timestamped to the date of request.</p>
<pre><code>csv
├── 210120_16_34_14-docker-network_peer_replica_10.csv
├── 210120_16_34_14-docker-network_peer_replica_11.csv
├── 210120_16_34_14-docker-network_peer_replica_12.csv
...
</code></pre>
<p>Note, that the record length of the files might differ, since the approval check execution time of the nodes might differ.</p>
<h2 id="spammer-tool"><a class="header" href="#spammer-tool">Spammer tool</a></h2>
<p>The Spammer tool lets you add messages to the tangle when running GoShimmer in a Docker network.
In order to start the spammer, you need to send GET requests to a <code>/spammer</code> API endpoint with the following parameters:</p>
<ul>
<li><code>cmd</code> - one of two possible values: <code>start</code> and <code>shutdown</code>.</li>
<li><code>mpm</code> - messages per minute. Only applicable when <code>cmd=start</code>. </li>
<li><code>imif</code> - (<em>optional</em>) parameter indicating time interval between issued messages. Possible values:
<ul>
<li><code>poisson</code> - emit messages modeled with Poisson point process, whose time intervals are exponential variables with mean 1/rate</li>
<li><code>uniform</code> - issues messages at constant rate</li>
</ul>
</li>
</ul>
<p>Example requests:</p>
<pre><code class="language-bash">http://localhost:8080/spammer?cmd=start&amp;mpm=1000

http://localhost:8080/spammer?cmd=start&amp;mpm=1000&amp;imif=uniform
http://localhost:8080/spammer?cmd=shutdown
</code></pre>
<h2 id="tangle-width"><a class="header" href="#tangle-width">Tangle width</a></h2>
<p>When running GoShimmer locally in a Docker network, the network delay is so small that only 1 tip will be available most of the time. 
In order to artificially create a tangle structure with multiple tips you can add a <code>messageLayer.tangleWidth</code> property to <a href="node-software/goshimmer/docs/tooling/tools/docker-network/config.docker.json">config.docker.json</a>
that specifies the number of tips that nodes should retain. This setting exists only for local testing purposes and should not be used in a distributed testnet.</p>
<p>Here is an example config that can be added: </p>
<pre><code class="language-json">  &quot;messageLayer&quot;: {
    &quot;tangleWidth&quot;: 10
  },
</code></pre>
<h1 id="specification-of-implementation"><a class="header" href="#specification-of-implementation">Specification of Implementation</a></h1>
<h1 id="mana-implementation"><a class="header" href="#mana-implementation">Mana Implementation</a></h1>
<p>This document provides a high level overview of how mana is implemented in GoShimmer.</p>
<h2 id="introduction-2"><a class="header" href="#introduction-2">Introduction</a></h2>
<p>Mana is a reputation system for nodes within the IOTA network.</p>
<p>Reputation is gained by contributing to the network, i.e. creating value transfers.
As time passes, part of the earned mana of a node decays to encourage keeping up the good behavior.</p>
<h2 id="scope-1"><a class="header" href="#scope-1">Scope</a></h2>
<p>The scope of the first implementation of mana into GoShimmer is to verify that mana calculations work,
study base mana calculations 1 &amp; 2, and mana distribution in the test network, furthermore to verify that nodes have
similar view on the network.</p>
<h2 id="mana-calculation"><a class="header" href="#mana-calculation">Mana Calculation</a></h2>
<p>Mana is essentially the reputation score of a node in the IOTA network. Mana is calculated locally in each node, as a
function that takes value transactions as input and produces the Base Mana Vector as output.</p>
<p>Each transaction has an <code>accessMana</code> and <code>consensusMana</code> field that determine which node to pledge these two types
of mana to. Both of these fields denote a <code>nodeID</code>, the receiver of mana. <code>accessMana</code> and <code>consensusMana</code> do not have
to be pledged to the same node, but for simplicity, in the first implementation, they will be.</p>
<p>In addition to the mana fields, a <code>timestamp</code> field is also added to the transactions that will be utilized for calculating
decay and effective mana.</p>
<p>From the pledged mana of a transaction, a node can calculate locally the <code>Base Mana Vector</code> for both <code>Access Mana</code> and
<code>Consensus Mana</code>.</p>
<p>A <code>Base Mana Vector</code> consists of Base Mana 1 and Base Mana 2 and their respective <code>Effective Base Mana</code>.
Given a value transaction, Base Mana 1 and Base Mana 2 are determined as follows:</p>
<ol>
<li>Base Mana 1 is revoked from the node that created the output(s) used as input(s) in the transaction, and is pledged to
the node creating the new output(s). The amount of <code>Base Mana 1</code> revoked and pledged is equal to the balance of the
input.</li>
<li>Base Mana 2 is freshly created at the issuance time of the transaction, awarded to the node, but decays with time.
The amount of <code>Base Mana 2</code> pledged is determined with <code>Pending Mana</code> concept: funds sitting at an address generate
<code>pending mana</code> that grows over time, but bounded.
<ul>
<li><code>Mana_pending = (alpha*S)/gamma*(1-e^(-gamma*t))</code>, where <code>alpha</code> and <code>gamma</code> are chosen parameters, <code>S</code> is the amount
of funds an output transfers to the address, and <code>t</code> is the time since the funds are on that address.</li>
</ul>
</li>
</ol>
<p>An example <code>Base Mana Vector</code> for <code>Access Mana</code> could look like this:</p>
<p>| 		    | Node 1 | Node 2 | ... | Node k
|  ------- | --------- | ---------- | ------ | ---
| Base Mana 1 			|0	| 1 	|...|  100.54
| Effective Base Mana 1	|0	| 0.5 	|...|  120.7
| Base Mana 2 			|0	| 1.2	|...|  0.01
| Effective Base Mana 2	|0	| 0.6 	|...|  0.015</p>
<p><code>Base Mana</code> is pledged or revoked at discrete times, which results in <code>Base Mana</code> being discontinuous function over time.
In order to make mana &quot;smoother&quot; and continuous, an exponential moving average is applied to the <code>Base Mana</code> values,
resulting in <code>Effective Base Mana 1</code> and <code>Effective Base Mana 2</code>.</p>
<p>It is important to note, that consuming a new transaction and pledging its mana happens when the transaction is
confirmed on the node. At the same time, entries of the nodes whose mana is being modified during pledging in the
<code>Base Mana Vector(s)</code> are updated with respect to time. In general, updates due to time happen whenever a node's mana is
being accessed. Except for the aforementioned case, this could be for example a mana related query from an external
module (FPC, Autopeering, DRNG, Rate Control, tools, etc.).</p>
<p>Following figure summarizes how <code>Access Mana</code> and <code>Consensus Mana</code> is derived from a transaction:</p>
<p><img src="https://i.imgur.com/LjfCTm9.png" alt="" /></p>
<p>The reason for having two separate <code>Base Mana Vectors</code> is the fact, that <code>accessMana</code> and <code>consensusMana</code> can be pledged
to different nodes.</p>
<p>The exact mathematical formulas, and their respective parameters will be determined later.</p>
<h2 id="challenges"><a class="header" href="#challenges">Challenges</a></h2>
<h3 id="dependency-on-tangle"><a class="header" href="#dependency-on-tangle">Dependency on Tangle</a></h3>
<p>Since mana is awarded to nodes submitting value transfers, the tangle is needed as input for mana calculation.
Each node calculates mana locally, therefore, it is essential to determine when to consider transactions in the
tangle &quot;final enough&quot; (so that they will not be orphaned).</p>
<p>When a transaction is <code>confirmed</code>, it is a sufficient indicator that it will not be orphaned. However, in current
GoShimmer implementation, confirmation is not yet a properly defined concept. This issue will be addressed in a separate
module.</p>
<p>The Mana module assumes, that the (value) tangle's <code>TransactionConfirmed</code> event is the trigger condition to update the
mana state machine (base mana vectors for access and consensus mana). Once the concept of transaction finality is
introduced for the tangle, the trigger conditions for access and consensus mana calculations can be adjusted.</p>
<h3 id="transaction-layout"><a class="header" href="#transaction-layout">Transaction Layout</a></h3>
<p>A new field should be added to <code>Transaction</code> denoting <code>PledgedNodeID</code> for <code>Access Mana</code> and <code>Consensus Mana</code>.
This is also beneficial to implement mana donation feature, that is, to donate the mana of a certain transaction to an
arbitrary node.</p>
<h2 id="limitations"><a class="header" href="#limitations">Limitations</a></h2>
<p>The first implementation of mana in GoShimmer will:</p>
<ul>
<li>not have voted timestamps on value transactions,</li>
<li>lack proper <code>TransactionConfirmed</code> mechanism to trigger mana update,</li>
<li>lack integration into rate control/autopeering/fpc/etc.</li>
</ul>
<h2 id="detailed-design"><a class="header" href="#detailed-design">Detailed Design</a></h2>
<p>In this section, detailed GoShimmer implementation design considerations will be outlined about the mana module.
In short, changes can be classified into 3 categories:</p>
<ol>
<li>Transaction related changes,</li>
<li>Mana module functionality,</li>
<li>and related tools/utilities, such as API, visualization, analytics.</li>
</ol>
<h3 id="transaction-2"><a class="header" href="#transaction-2">Transaction</a></h3>
<p>As described above, 3 new fields will be added to the transaction layout:</p>
<ol>
<li><code>Timestamp</code> time.time</li>
<li><code>AccessManaNodeID</code> []bytes</li>
<li><code>ConsensusManaNodeID</code> []bytes</li>
</ol>
<p>By adding these fields to the signed transaction, <code>valuetransfers/packages/transaction</code> should be modified.</p>
<ul>
<li>The three new fields should be added to the transaction essence.</li>
<li>Marshalling and unmarshalling of a transaction should be modified.</li>
<li>For calculating <code>Base Mana 1</code> values, <code>mana module</code> should be able to derive from a transaction the nodes which received
pledged <code>Base Mana 1</code> as a consequence of the consumed inputs of the transaction. Therefore, a lookup function should
be exposed from the value tangle that given an <code>input</code>, returns the <code>pledgedNodeID</code> of the transaction creating the input.</li>
</ul>
<p><code>Timestamp</code> is part of the signed transaction, therefore, a client sending a transaction to the node should already
define it. In this case, this <code>Timestamp</code> will not be the same as the timestamp of the message containing the
transaction and value payload, since the message is created on the node.
A solution to this is that upon receiving a <code>transaction</code> from a client, the node checks if the timestamp is within
a predefined time window, for example <code>t_current - delta</code>, where <code>delta</code> could be couple seconds. If true, then the node
constructs the message, which must have a greater timestamp, than the transaction.</p>
<p><code>AccessManaNodeID</code> and <code>ConsensusManaNodeID</code> are also part of the signed transaction, so a client should fill them out.
Node owners are free to choose to whom they pledge mana to with the transaction, so there should be a mechanism that
lets the client know, what <code>AccessManaNodeID</code> and <code>ConsensusManaNodeID</code> are allowed. This could be a new API endpoint
that works like this:</p>
<ol>
<li>Client asks node what nodeIDs can be included for pledging  a certain type (access, consensus) mana.</li>
<li>Node answers with either:</li>
</ol>
<ul>
<li>Don't care. Any node IDs are valid.</li>
<li>List of nodeIDs that are allowed for each type.</li>
</ul>
<ol start="3">
<li>If a client sends back the transaction with invalid or empty mana fields, the transaction is considered invalid.</li>
</ol>
<p>This way node owners can decide who their transactions are pledging mana to. It could be only their node, or they could
provide mana pledging as a service. They could delegate access mana to others, but hold own to consensus mana, or the
other way around.</p>
<h3 id="initialization"><a class="header" href="#initialization">Initialization</a></h3>
<p>Mana state machine is an extension of the ledger state, hence its calculation depends on the ledger state perception
of the node. Snapshotting is the mechanism that saves the ledger states and prunes unnecessary transactions. Together
with the ledger state, base mana vectors are also saved, since a certain ledger state reflects a certain mana distribution
in the network. In future, when snapshotting is implemented in GoShimmer, nodes joining the network will be able to query
for snapshot files that will contain initial base mana vectors as well.</p>
<p>Until this functionality is implemented, mana calculation solely relies on transactions getting confirmed. That is, when
a node joins the network and starts gathering messages and transactions from peers, it builds its own ledger state through
solidification process. Essentially, the node requests all messages down to the genesis from the current tips of its neighbors.
Once the genesis is found, messages are solidified bottom up. For the value tangle, this means that for each solidified
and liked transaction, <code>TransactionConfirmed</code> event is triggered, updating the base mana vectors.</p>
<p>In case of a large database, initial synching and solidification is a computationally heavy task due to the sheer amount
of messages in the tangle. Mana calculation only adds to this burden. It will be determined through testing if additional
&quot;weight lifting&quot; mechanism is needed (for example delaying mana calculation).</p>
<p>In Pollen test network, all funds are initially held by the faucet node, therefore all mana present at bootstrap belong
to this node. Whenever a transaction is requested from the faucet, it pledges mana to the requesting node, helping other
nodes to increase their mana.</p>
<h3 id="mana-package"><a class="header" href="#mana-package">Mana Package</a></h3>
<p>The functionality of the mana module should be implemented in a <code>mana</code> package. Then, a <code>mana plugin</code> can use the package
structs and methods to connect the dots, for example execute <code>BookMana</code> when <code>TransactionConfirmed</code> event is triggered
in the value tangle.</p>
<p><code>BaseMana</code> is a struct that holds the different mana values for a given node.
Note that except for <code>Base Mana 1</code> calculation, we need the time when <code>BaseMana</code> values were updated, so we store it in the struct:</p>
<pre><code class="language-go">type BaseMana struct {
 BaseMana1 float
 EffectiveBaseMana1 float
 BaseMana2 float
 EffectiveBaseMana2 float
 LastUpdated time
}
</code></pre>
<p><code>BaseManaVector</code> is a data structure that maps <code>nodeID</code>s to <code>BaseMana</code>. It also has a <code>Type</code> that denotes the type
of mana this vector deals with (Access, Consensus, etc.).</p>
<pre><code class="language-go">type BaseManaVector struct {
	vector     map[identity.ID]*BaseMana
	vectorType Type
}
</code></pre>
<h4 id="methods"><a class="header" href="#methods">Methods</a></h4>
<p><code>BaseManaVector</code> should have the following methods:</p>
<ul>
<li><code>BookMana(transaction)</code>: Book mana of a transaction. Trigger <code>ManaBooked</code> event. Note, that this method updates
<code>BaseMana</code> with respect to time and to new <code>Base Mana 1</code> and <code>Base Mana 2</code> values.</li>
<li><code>GetWeightedMana(nodeID, weight) mana</code>: Return <code>weight</code> *<code> Effective Base Mana 1</code> + (1-<code>weight</code>)+<code>Effective Base Mana 2</code>.
<code>weight</code> is a number in [0,1] interval. Notice, that <code>weight</code> = 1  results in only returning <code>Effective Base Mana 1</code>,
and the other way around. Note, that this method also updates <code>BaseMana</code> of the node with respect to time.</li>
<li><code>GetMana(nodeID) mana</code>: Return 0.5*<code>Effective Base Mana 1</code> + 0.5*<code>Effective Base Mana 2</code> of a particular node. Note, that
this method also updates <code>BaseMana</code> of the node with respect to time.</li>
<li><code>update(nodeID, time)</code>: update <code>Base Mana 2</code>, <code>Effective Base Mana 1</code> and <code>Effective Base Mana 2</code> of a node with respect <code>time</code>.</li>
<li><code>updateAll(time)</code>: update <code>Base Mana 2</code>, <code>Effective Base Mana 1</code> and <code>Effective Base Mana 2</code> of all nodes with respect to <code>time</code>.</li>
</ul>
<p><code>BaseMana</code> should have the following methods:</p>
<ul>
<li><code>pledgeAndUpdate(transaction)</code>: update <code>BaseMana</code> fields and pledge mana with respect to <code>transaction</code>.</li>
<li><code>revokeBaseMana1(amount, time)</code>:  update <code>BaseMana</code> values with respect to <code>time</code> and revoke <code>amount</code> <code>BaseMana1</code>.</li>
<li><code>update(time)</code>: update all <code>BaseMana</code> fields with respect to <code>time</code>.</li>
<li><code>updateEBM1(time)</code>: update <code>Effective Base Mana 1</code> wrt to <code>time</code>.</li>
<li><code>updateBM2(time)</code>: update <code>Base Mana 2</code> wrt to <code>time</code>.</li>
<li><code>updateEBM2(time)</code>: update <code>Effective Base Mana 2</code> wrt to <code>time</code>.</li>
</ul>
<h4 id="base-mana-calculation"><a class="header" href="#base-mana-calculation">Base Mana Calculation</a></h4>
<p>There are two cases when the values within <code>Base Mana Vector</code> are updated:</p>
<ol>
<li>A confirmed transaction pledges mana.</li>
<li>Any module accesses the <code>Base Mana Vector</code>, and hence its values are updated with respect to <code>access time</code>.</li>
</ol>
<p>First, let's explore the former.</p>
<h5 id="a-confirmed-transaction-pledges-mana"><a class="header" href="#a-confirmed-transaction-pledges-mana">A confirmed transaction pledges mana</a></h5>
<p>For simplicity, we only describe mana calculation for one of the Base Mana Vectors, namely, the Base Access Mana Vector.</p>
<p>First, a <code>TransactionConfirmed</code> event is triggered, therefore <code>BaseManaVector.BookMana(transaction)</code> is executed:</p>
<pre><code class="language-go">func (bmv *BaseManaVector) BookMana(tx *transaction) {
    pledgedNodeID := tx.accessMana

    for input := range tx.inputs {
        // search for the nodeID that the input's tx pledged its mana to
        inputNodeID := loadPledgedNodeIDFromInput(input)
        // save it for proper event trigger
        oldMana := bmv[inputNodeID]
        // revoke BM1
        bmv[inputNodeID].revokeBaseMana1(input.balance, tx.timestamp)

        // trigger events
        Events.ManaRevoked.Trigger(&amp;ManaRevokedEvent{inputNodeID, input.balance, tx.timestamp, AccessManaType})
        Events.ManaUpdated.Tigger(&amp;ManaUpdatedEvent{inputNodeID, oldMana, bmv[inputNodeID], AccessManaType})
    }

    // save it for proper event trigger
    oldMana :=  bmv[pledgedNodeID]
    // actually pledge and update
    bm1Pledged, bm2Pledged := bmv[pledgedNodeID].pledgeAndUpdate(tx)

    // trigger events
    Events.ManaPledged.Trigger(&amp;ManaPledgedEvent{pledgedNodeID, bm1Pledged, bm2Pledged, tx.timestamp, AccessManaType})
    Events.ManaUpdated.Trigger(&amp;ManaUpdatedEvent{pledgedNodeID, oldMana, bmv[pledgedNodeID], AccessManaType})
}
</code></pre>
<p><code>Base Mana 1</code> is being revoked from the nodes that pledged mana for inputs that the current transaction consumes.
Then, the appropriate node is located in <code>Base Mana Vector</code>, and mana is pledged to its <code>BaseMana</code>.
<code>Events</code> are essential to study what happens within the module from the outside.</p>
<p>Note, that <code>revokeBaseMana1</code> accesses the mana entry of the nodes within <code>Base Mana Vector</code>, therefore all values are
updated with respect to <code>t</code>. Notice the two branches after the condition. When <code>Base Mana</code> values had been updated before
the transaction's timestamp, a regular update is carried out. However, if <code>t</code> is older, than the transaction timestamp,
an update in the &quot;past&quot; is carried out and values are updated up to <code>LastUpdated</code>.</p>
<pre><code class="language-go">func (bm *BaseMana) revokeBaseMana1(amount float64, t time.Time) {
	if t.After(bm.LastUpdated) {
		// regular update
		n := t.Sub(bm.LastUpdated)
		// first, update EBM1, BM2 and EBM2 until `t`
		bm.updateEBM1(n)
		bm.updateBM2(n)
		bm.updateEBM2(n)

		bm.LastUpdated = t
		// revoke BM1 at `t`
		bm.BaseMana1 -= amount
	} else {
		// update in past
		n := bm.LastUpdated.Sub(t)
		// revoke BM1 at `t`
		bm.BaseMana1 -= amount
		// update EBM1 to `bm.LastUpdated`
		bm.EffectiveBaseMana1 -= amount*(1-math.Pow(math.E,-EMA_coeff_1*n))
	}
}
</code></pre>
<p>The same regular and past update scheme is applied to pledging mana too:</p>
<pre><code class="language-go">func (bm *BaseMana) pledgeAndUpdate(tx *transaction) (bm1Pledged int, bm2Pledged int){
	t := tx.timestamp
	bm1Pledged = sum_balance(tx.inputs)

	if t.After(bm.LastUpdated) {
		// regular update
		n := t.Sub(bm.LastUpdated)
		// first, update EBM1, BM2 and EBM2 until `t`
		bm.updateEBM1(n)
		bm.updateBM2(n)
		bm.updateEBM2(n)
		bm.LastUpdated = t
		bm.BaseMana1 += bm1Pledged
		// pending mana awarded, need to see how long funds sat
		for input := range tx.inputs {
			// search for the timestamp of the UTXO that generated the input
			t_inp := LoadTxTimestampFromOutputID(input)
			bm2Add := input.balance * (1 - math.Pow(math.E, -decay*(t-t_inp)))
			bm.BaseMana2 += bm2Add
			bm2Pledged += bm2Add
		}
	} else {
		// past update
		n := bm.LastUpdated.Sub(t)
		// update BM1 and BM2 at `t`
		bm.BaseMana1 += bm1Pledged
		oldMana2 = bm.BaseMana2
		for input := range tx.inputs {
			// search for the timestamp of the UTXO that generated the input
			t_inp := LoadTxTimestampFromOutputID(input)
			bm2Add := input.balance * (1-math.Pow( math.E,-decay*(t-t_inp) ) ) * math.Pow(math.E, -decay*n)
			bm.BaseMana2 += bm2Add
			bm2Pledged += bm2Add
		}
		// update EBM1 and EBM2 to `bm.LastUpdated`
		bm.EffectiveBaseMana1 += amount*(1-math.Pow(math.E,-EMA_coeff_1*n))
		if EMA_coeff_2 != decay {
			bm.EffectiveBaseMana2 += (bm.BaseMana2 - oldMana2) *EMA_coeff_2*(math.Pow(math.E,-decay*n)-
                math.Pow(math.E,-EMA_coeff_2*n))/(EMA_coeff_2-decay) / math.Pow(math.E, -decay*n)
		} else {
			bm.EffectiveBaseMana2 += (bm.BaseMana2 - oldMana2) * decay * n
		}
}
	return bm1Pledged, bm2Pledged
}
</code></pre>
<p>Notice, that in case of <code>EMA_coeff_2 = decay</code>, a simplified formula can be used to calculate <code>EffectiveBaseMana2</code>.
The same approach is applied in <code>updateEBM2()</code>.</p>
<pre><code class="language-go">func (bm *BaseMana) updateEBM1(n time.Duration) {
    bm.EffectiveBaseMana1 = math.Pow(math.E, -EMA_coeff_1 * n) * bm.EffectiveBaseMana1 +
                                 (1-math.Pow(math.E, -EMA_coeff_1 * n)) * bm.BaseMana1
}
</code></pre>
<pre><code class="language-go">func (bm *BaseMana) updateBM2(n time.Duration) {
    bm.BaseMana2 = bm.BaseMana2 * math.Pow(math.E, -decay*n)
}
</code></pre>
<pre><code class="language-go">func (bm *BaseMana) updateEBM2(n time.Duration) {
	if EMA_coeff_2 != decay {
		bm.EffectiveBaseMana2 = math.Pow(math.E, -emaCoeff2 * n) * bm.EffectiveBaseMana2 +
			(math.Pow(math.E, -decay * n) - math.Pow(math.E, -EMA_coeff_2 * n)) /
				(EMA_coeff_2 - decay) * EMA_coeff_2 / math.Pow(math.E, -decay * n)*bm.BaseMana2
	} else {
		bm.EffectiveBaseMana2 = math.Pow(math.E, -decay * n)*bm.EffectiveBaseMana2 +
			decay * n * bm.BaseMana2
	}
}
</code></pre>
<h5 id="any-module-accesses-the-base-mana-vector"><a class="header" href="#any-module-accesses-the-base-mana-vector">Any module accesses the Base Mana Vector</a></h5>
<p>In this case, the accessed entries within <code>Base Mana Vector</code> are updated via the method:</p>
<pre><code class="language-go">func (bmv *BaseManaVector) update(nodeID ID, t time.Time ) {
    oldMana :=  bmv[nodeID]
    bmv[nodeID].update(t)
    Events.ManaUpdated.Trigger(&amp;ManaUpdatedEvent{nodeID, oldMana, bmv[nodeID], AccessManaType})
}
</code></pre>
<p>where <code>t</code> is the access time.</p>
<pre><code class="language-go">func (bm *BaseMana) update(t time.Time ) {
    n := t - bm.LastUpdated
    bm.updateEBM1(n)
    bm.updateBM2(n)
    bm.updateEBM2(n)

    bm.LastUpdated = t
}
</code></pre>
<h4 id="events-1"><a class="header" href="#events-1">Events</a></h4>
<p>The mana package should have the following events:</p>
<ul>
<li><code>Pledged</code> when mana (<code>BM1</code> and <code>BM2</code>) was pledged for a node due to new transactions being confirmed.</li>
</ul>
<pre><code class="language-go">type PledgedEvent struct {
    NodeID []bytes
    AmountBM1 int
    AmountBM2 int
    Time time.Time
    Type ManaType // access or consensus
}
</code></pre>
<ul>
<li><code>Revoked</code> when mana (<code>BM1</code>) was revoked from a node.</li>
</ul>
<pre><code class="language-go">type RevokedEvent struct {
    NodeID []bytes
    AmountBM1 int
    Time time.Time
    Type ManaType // access or consensus
}
</code></pre>
<ul>
<li><code>Updated</code> when mana was updated for a node due to it being accessed.</li>
</ul>
<pre><code class="language-go">type UpdatedEvent struct {
    NodeID []bytes
    OldMana BaseMana
    NewMana BaseMana
    Type    ManaType // access or consensus
}
</code></pre>
<h4 id="testing"><a class="header" href="#testing">Testing</a></h4>
<ul>
<li>Write unit tests for all methods.</li>
<li>Test all events and if they are correctly triggered.</li>
<li>Benchmark calculations in tests to see how heavy it is to calculate EMAs and decays.</li>
</ul>
<h3 id="mana-plugin"><a class="header" href="#mana-plugin">Mana Plugin</a></h3>
<p>The <code>mana plugin</code> is responsible for:</p>
<ul>
<li>calculating mana from value transactions,</li>
<li>keeping a log of the different mana values of all nodes,</li>
<li>updating mana values,</li>
<li>responding to mana related queries from other modules,</li>
<li>saving base mana vectors in database when shutting down the node,</li>
<li>trying to load base mana vectors from database when starting the node.</li>
</ul>
<p>The proposed mana plugin should keep track of the different mana values of nodes and handle calculation
updates. Mana values are mapped to <code>nodeID</code>s and stored in a <code>map</code> data structure. The vector also stores information on
what <code>Type</code> of mana it handles.</p>
<pre><code class="language-go">type BaseManaVector struct {
	vector     map[identity.ID]*BaseMana
	vectorType Type
}
</code></pre>
<p><code>Access Mana</code> and <code>Consensus Mana</code> should have their own respective <code>BaseManaVector</code>.</p>
<pre><code class="language-go">accessManaVector := BaseManaVector{vectorType: AccesMana}
consensusManaVector :=  BaseManaVector{vectorType: ConsensusMana}
</code></pre>
<p>In the future, it should be possible to combine <code>Effective Base Mana 1</code> and <code>Effective Base Mana 2</code> from a <code>BaseManaVector</code>
in arbitrary proportions to arrive at a final mana value that other modules use. The <code>mana package</code> has these methods
in place. Additionally, a parameter could be passed to the <code>getMana</code> type of exposed functions to set the proportions.</p>
<h4 id="methods-1"><a class="header" href="#methods-1">Methods</a></h4>
<p>The mana plugin should expose utility functions to other modules:</p>
<ul>
<li><code>GetHighestManaNodes(type, n) [n]NodeIdManaTuple</code>: return the <code>n</code> highest <code>type</code> mana nodes (<code>nodeID</code>,<code>manaValue</code>) in
ascending order. Should also update their mana value.</li>
<li><code>GetManaMap(type) map[nodeID]manaValue</code>: return <code>type</code> mana perception of the node.</li>
<li><code>GetAccessMana(nodeID) mana</code>: access <code>Base Mana Vector</code> of <code>Access Mana</code>, update its values with respect to time,
and return the amount of <code>Access Mana</code> (either <code>Effective Base Mana 1</code>, <code>Effective Base Mana 2</code>, or some combination
of the two). Trigger <code>ManaUpdated</code> event.</li>
<li><code>GetConsensusMana(nodeID) mana</code>: access <code>Base Mana Vector</code> of <code>Consensus Mana</code>, update its values with respect to time,
and returns the amount of <code>Consensus Mana</code> (either <code>Effective Base Mana 1</code>, <code>Effective Base Mana 2</code>, or some combination
of the two). Trigger <code>ManaUpdated</code> event.</li>
<li><code>GetNeighborsMana(type)</code>: returns the <code>type</code> mana of the nodes neighbors</li>
<li><code>GetAllManaVectors()</code> Obtaining the full mana maps for comparison with the perception of other nodes.</li>
<li><code>GetWeightedRandomNodes(n)</code>: returns a weighted random selection of <code>n</code> nodes. <code>Consensus Mana</code> is used for the weights.</li>
<li>Obtaining a list of currently known peers + their mana, sorted. Useful for knowing which high mana nodes are online.</li>
<li><code>OverrideMana(nodeID, baseManaVector)</code>: Sets the nodes mana to a specific value. Can be useful for debugging, setting faucet mana, initialization, etc.. Triggers <code>ManaUpdated</code></li>
</ul>
<p>Such utility functions could be used for example to visualize mana distribution in node dashboard, or send neighbor
mana data to the analysis server for further processing.</p>
<h4 id="booking-mana"><a class="header" href="#booking-mana">Booking Mana</a></h4>
<p>Mana is booked when a transaction is confirmed.</p>
<pre><code class="language-go">on TransactionConfirmed (tx):
 bookAccessMana()
 bookConsensusMana()
</code></pre>
<h4 id="synchronization-and-mana-calculation"><a class="header" href="#synchronization-and-mana-calculation">Synchronization and Mana Calculation</a></h4>
<p>The mana plugin is responsible to determine when to start calculating mana locally.
Since mana state is an extension to ledger state, it can only depict realistic mana values once the node is in sync.
During syncing, ledger state is constructed from messages coming from neighbors as described further above.</p>
<p>In this first iteration, mana plugin relies on <code>TransactionConfirmed</code> event of the value transfers plugin, and has no
explicit rules on when to start and stop mana calculation.</p>
<p>In future, initial mana state (together with the initial ledger state) will be derived from a snapshot file.</p>
<h3 id="mana-toolkit"><a class="header" href="#mana-toolkit">Mana Toolkit</a></h3>
<p>In this section, all tools and utility functions for mana will be outlined.</p>
<h4 id="mana-related-api-endpoints"><a class="header" href="#mana-related-api-endpoints">Mana Related API endpoints</a></h4>
<ul>
<li><code>/info</code>: Add own mana in node info response.</li>
<li><code>value/allowedManaPledge</code>: Endpoint that clients can query to determine which nodeIDs are allowed as part of
<code>accessMana</code> and <code>consensusMana</code> fields in a transaction.</li>
<li><code>value/sendTransactionByJson</code>: Add <code>accessMana</code>, <code>consensusMana</code> and <code>timestamp</code> fields to the JSON request.</li>
</ul>
<p>Add a new <code>mana</code> endpoint route:</p>
<ul>
<li><code>/mana</code>: Return access and consensus mana of the node.</li>
<li><code>/mana/all</code>: Return whole mana map (mana perception of the node).</li>
<li><code>/mana/access/nhighest</code>: Return <code>n</code> highest access mana holder <code>nodeIDs</code> and their access mana values.</li>
<li><code>/mana/consensus/nhighest</code>: Return <code>n</code> highest consensus mana holder <code>nodeIDs</code> and their consensus mana values.</li>
<li><code>/mana/percentile</code>: Return the top percentile the node belongs to relative to the network. For example, if there are 100 nodes in the
network owning mana, and a node is the 13th richest, it means that is part of the top 13% of mana holders, but not the
top 12%.</li>
</ul>
<h4 id="metrics-collection"><a class="header" href="#metrics-collection">Metrics collection</a></h4>
<p>To study the mana module, following metrics could be gathered:</p>
<ul>
<li>Amount of consensus and access mana present in the network. (amount varies because of <code>Base Mana 2</code>).</li>
<li>Amount of mana each node holds.</li>
<li>Number of (and amount of mana) a node was pledged with mana in the last <code>t</code> interval.</li>
<li>Mana development of a particular node over time.</li>
<li>Mana percentile development of a node over time.</li>
<li>Average pledge amount of a node. (how much mana it receives on average with one pledge)</li>
<li>Mean and median mana holdings of nodes in the network. Shows how even mana distribution is.</li>
<li>Average mana of neighbors.</li>
</ul>
<h4 id="visualization"><a class="header" href="#visualization">Visualization</a></h4>
<p>Each node calculates mana locally, not only for themselves, but for all nodes in the network that it knows. As a result,
mana perception of nodes may not be exactly the same at all times (due to network delay, processing capabilities), but
should converge to the same state. A big question for visualization is which node's viewpoint to base mana visualization on? </p>
<p>When running a node, operators will be shown the mana perception of their own node, but it also makes sense to
display the perception of high mana nodes as the global mana perception. First, let's look at how local mana perception
is visualized for a node:</p>
<h5 id="local-perception"><a class="header" href="#local-perception">Local Perception</a></h5>
<p>There are two ways to visualize mana in GoShimmer:</p>
<ol>
<li>Node Local Dashboard</li>
<li>Grafana Dashboard</li>
</ol>
<p>While <code>Local Dashboard</code> gives flexibility in what and how to visualize, <code>Grafana Dashboard</code> is better at storing historic
data but can only visualize time series. Therefore, both of these ways will be utilized, depending on which suits the best.</p>
<p><code>Local Dashboard</code> visualization:</p>
<ul>
<li>Histogram of mana distribution within the network.</li>
<li>List of <code>n</code> richest mana nodes, ordered.</li>
<li>Mana rank of node.</li>
</ul>
<p><code>Grafana Dashboard</code> visualization:</p>
<ul>
<li>Mana of a particular node with respect to time.</li>
<li>Amount of mana in the network.</li>
<li>Average pledge amount of a node.</li>
<li>Mean and median mana holdings of nodes.</li>
<li>Mana rank of the node over time.</li>
<li>Average mana of neighbors.</li>
</ul>
<h5 id="global-perception"><a class="header" href="#global-perception">Global Perception</a></h5>
<p>Additionally, the Pollen Analyzer (analysis server) could be updated:</p>
<ul>
<li>Autopeering node graph, where size of a node corresponds to its mana value.</li>
<li>Some previously described metrics could be visualized here as well, to give the chance to people without
a node to take a look. As an input, a high mana node's perception should be used.</li>
</ul>
<h1 id="markers"><a class="header" href="#markers">Markers</a></h1>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>In order to know whether a message in the Tangle is orphaned or not, we introduce <strong>grades of finality</strong> to interpret the status of a message. The higher grade of finality is determined by the <strong>approval weight</strong>, which is the proportion of active consensus mana approving a given message.</p>
<p>In order to compute the approval weight of a given message  we need to traverse the Tangle from the message to the tips and sum up the active consensus mana of all the messages in its future cone. A <strong>marker</strong> is a tool to efficiently estimate the approval weight of a message and that reduces the portion of the Tangle we need to walk, and which finally results in the grade of finality.</p>
<p><strong>Note</strong>: <em>Markers</em> is not a core module of the Coordicide project.</p>
<h2 id="motivation-1"><a class="header" href="#motivation-1">Motivation</a></h2>
<p><em>Markers</em> is a tool to infer knowledge about the structure of the Tangle in terms of:
+ past/future cone membership;
+ approximate approval weight of any message;
+ tagging sections of the Tangle (e.g., branches) without having to traverse each message individually.</p>
<h2 id="dependency"><a class="header" href="#dependency">Dependency</a></h2>
<p>Active Consensus Mana</p>
<h2 id="definitions"><a class="header" href="#definitions">Definitions</a></h2>
<p>Let's define the terms related to markers:</p>
<ul>
<li><strong>Sequence:</strong> A Sequence is a sequence of markers. Each Sequence corresponds to a UTXO branch, which help us to track the structure independently. </li>
<li><strong>Sequence Identifier (<code>SID</code>):</strong> A Sequence Identifier is the unique identifier of a Sequence.</li>
<li><strong>Marker Index (<code>MI</code>):</strong> A Marker Index is the marker rank in the marker DAG. Throughout the code the marker rank will be called index. </li>
<li><strong>marker:</strong> A marker is a pair of numbers: <code>SID</code> and <code>MI</code> associated to a given message. Markers carrying the same <code>SID</code> belong to the same Sequence.</li>
<li><strong>future marker (<code>FM</code>):</strong> A future marker of a message is the first marker in its future cone from different sequences; this field in the message metadata is updated when the new marker is generated in the future, following the rules defined in <a href="node-software/goshimmer/docs/specification/003-markers.html#future-markers">Future Markers</a>.</li>
<li><strong>past marker (<code>PM</code>):</strong> A past marker of a message is a marker in its past cone. For a given sequence it is set to the newest past marker of its parents, that is the one that has the largest <code>MI</code>. The past marker of a marker is set to itself.</li>
<li><strong>sequence rank:</strong> The rank of a sequence will be simply called rank throughout this code. Bear in mind that for clarity the marker rank is called index.</li>
</ul>
<h2 id="design-1"><a class="header" href="#design-1">Design</a></h2>
<h3 id="the-markers"><a class="header" href="#the-markers">The Markers</a></h3>
<p>Markers are messages selected from the tip set periodically and assigned unique identifiers, in the form of $[SID, MI]$. </p>
<h4 id="marker-structure"><a class="header" href="#marker-structure">Marker Structure</a></h4>
<table>
    <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
    </tr>
    <tr>
        <td>SequenceID</td>
        <td>uint64</td>
        <td>The Sequence identifier of the marker.</td>
    </tr>
    <tr>
        <td>Index</td>
        <td>uint64</td>
        <td>The index of the marker in the sequence.</td>
    </tr>
</table>
<h4 id="create-markers"><a class="header" href="#create-markers">Create Markers</a></h4>
<p>A new marker is created when:</p>
<ol>
<li>the default conditions are met, which will be one of these options:
<ul>
<li><strong>every x messsages</strong>;</li>
</ul>
<ul>
<li><strong>every t seconds</strong>;</li>
<li>a mix of the first two!
<ul>
<li>Upperbound given by the messages</li>
<li>Lower temporal bound given by the time</li>
</ul>
</li>
<li>every x messages that reference (directly or indirectly) the previous marker
<ul>
<li>Lower bound given by rank (e.g., how far you are in terms of steps) -&gt; &gt;= 10 or something</li>
<li>Upper bound given by the amount of messages referencing the previous one -&gt; ~ 200 msgs</li>
</ul>
</li>
</ul>
</li>
<li>A new sequence is created. </li>
</ol>
<blockquote>
<p>:mega: to be confirmed here.</p>
</blockquote>
<p>A new marker is selected from the strong tips set randomly, and selected from the weak tips set if there's no strong tip. A new pair of $[SID, MI]$ is assigned to the new marker. </p>
<blockquote>
<p>:mega:  to be confirmed here.</p>
</blockquote>
<p>The <code>SID</code> is set according to the following rules:</p>
<ul>
<li>Inherit the <code>SID</code> from parents if the new marker references the latest marker of a sequence and meets the requirement to set up a new marker without initiating a new MS.</li>
<li>Create a new <code>SID</code> if it is the first marker of a new sequence.</li>
</ul>
<p>The <code>MI</code> is set to $MI = 1+ max(referencedMI)$, which complies to the rule:</p>
<ul>
<li>Marker indexes (<code>MI</code>s) are monotonically increasing such that $\forall x \in fc(y)$ =&gt; $MI_x &gt; MI_y$, where $fc(y)$ is the future cone of $y$ and $x$ is any message in that future cone.</li>
</ul>
<h3 id="markers-in-messages"><a class="header" href="#markers-in-messages">Markers in Messages</a></h3>
<p>Each message keeps its associated marker information in two lists:</p>
<ul>
<li>past markers </li>
<li>future markers </li>
</ul>
<p>These lists for past markers and future markers are used to determine whether a message is in the past cone of the other, and the list for future markers also helps us to efficiently estimate the approval weight of a message.</p>
<h4 id="structuredetails-structure"><a class="header" href="#structuredetails-structure">StructureDetails Structure</a></h4>
<p>StructureDetails is a structure that will be in the message metadata containing marker information.</p>
<table>
    <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
    </tr>
    <tr>
        <td>Rank</td>
        <td>uint64</td>
        <td>The rank of the message.</td>
    </tr>
    <tr>
        <td>IsPastMarker</td>
        <td>bool</td>
        <td>A flag to indicate whether a message is a marker.</td>
    </tr>
    <tr>
        <td>PastMarkers</td>
        <td>map[SequenceID]Index</td>
        <td><b>PM list</b>, a list of PMs from different sequences.</td>
    </tr>
    <tr>
        <td>FutureMarkers</td>
        <td>map[SequenceID]Index</td>
        <td><b>FM list</b>, a list of FMs from different sequences.</td>     
    </tr>
</table>
<h5 id="past-markers"><a class="header" href="#past-markers">Past Markers</a></h5>
<ul>
<li>The <code>PM</code> list of a marker contains the marker itself only.</li>
<li>The <code>PM</code> list of non-marker messages is inherited from its <strong>strong</strong> parents, with 2 steps:
<ol>
<li>for a given sequence select only the nearest marker (i.e. the markers with the highest <code>MI</code>). Thus for every sequence from the parents there will be exactly one marker.</li>
<li>remove those that have been referenced by other markers from this set. </li>
</ol>
</li>
</ul>
<h5 id="future-markers"><a class="header" href="#future-markers">Future Markers</a></h5>
<p>The <code>FM</code> list of a message is empty at start and gets updated when a new marker directly or indirectly references it. The propagation of a <code>FM</code> to its past cone (i.e. the update of the <code>FutureMarkers</code> field in the encountered messages) does not continue beyond a message if:</p>
<ol>
<li>the <code>FM</code> list of a message includes a previous marker of the same sequence;</li>
<li>the message is the marker in the different sequence, we update the <code>FM</code> list of that marker only.</li>
</ol>
<h3 id="the-sequence"><a class="header" href="#the-sequence">The Sequence</a></h3>
<p>Sequences are used to track the UTXO DAG branches, each branch corresponds to a sequence with a unique <code>SID</code>, and the sequences form a DAG as well.</p>
<h4 id="sequence-structure"><a class="header" href="#sequence-structure">Sequence Structure</a></h4>
<table>
    <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
    </tr>
    <tr>
        <td>id</td>
        <td>uint64</td>
        <td>The sequence identifier of the sequence.</td>
    </tr>
    <tr>
        <td>parentReferences</td>
        <td>map[uint64]Thresholdmap</td>
        <td>The marker referenced map of each parent marker.</td>
    </tr>
    <tr>
        <td>rank</td>
        <td>uint64</td>
        <td>The rank of the sequence in the marker DAG.</td>
    </tr>
    <tr>
        <td>highestIndex</td>
        <td>uint64</td>
        <td>The highest MI of the marker sequence.</td>
    </tr>
    <tr>
        <td>lowestIndex</td>
        <td>uint64</td>
        <td>The lowest MI of the sequence.</td>
    </tr>
</table>
<h4 id="create-sequence"><a class="header" href="#create-sequence">Create Sequence</a></h4>
<p>A new sequence is created when:</p>
<ol>
<li>there's a conflict in a UTXO branch.</li>
<li>the UTXO branches are aggregated.</li>
<li>UTXO branches are merged.</li>
</ol>
<p>Each new sequence starts from a new marker.</p>
<h4 id="sequences"><a class="header" href="#sequences">Sequences</a></h4>
<p>For whatever reason a sequence is created, we assign a new $SID = 1+max(referenceSequencesIdentifiers)$. To prevent assigning a new <code>SID</code> when combining same sequences again, we build parents-child relation in a map if a new sequence is created. </p>
<h4 id="sequence-rank"><a class="header" href="#sequence-rank">Sequence Rank</a></h4>
<p>The rank of a sequence graph is the number of sequences from the starting point to itself. The sequence ranks are shown in the figure above.</p>
<h2 id="example-1"><a class="header" href="#example-1">Example 1</a></h2>
<p>Here is an example of how the markers and sequences structures would look in the Tangle:
The purple colored messages are markers.</p>
<p><img src="https://i.imgur.com/GENej3O.png" alt="" /></p>
<h2 id="example-2-test-for-the-mapping-interaction-with-the-booker"><a class="header" href="#example-2-test-for-the-mapping-interaction-with-the-booker">Example 2: Test for the Mapping interaction with the Booker</a></h2>
<p>The Marker tool implementation is tested for correct Marker and Booker mapping. A transaction-by-transaction discussion of the test can be found <a href="node-software/goshimmer/docs/specification/./../../packages/tangle/images/TestBookerMarkerMappings.html">here</a> and can be viewed by opening the file locally in a browser. Transactions arrive in the order of the their transaction number. The end result and the values in the various fields is shown in the following figures:</p>
<p><img src="https://imgur.com/h6Hs3xG.png" alt="" /></p>
<p><img src="https://imgur.com/sCkXXrG.png" alt="" /></p>
<h2 id="implementation-details-5"><a class="header" href="#implementation-details-5">Implementation details</a></h2>
<p>In the following we describe some of the functions in more detail.</p>
<h3 id="normalization-of-the-referenced-pms-and-sequences"><a class="header" href="#normalization-of-the-referenced-pms-and-sequences">Normalization of the referenced PMs and Sequences</a></h3>
<p>Messages can have markers from different sequences in <code>PM</code> list and <code>FM</code> list, the order and referenced relationship among sequences are important for example when it comes to inheriting the <code>PM</code> list from parents. Thus, we need to track these sequences.</p>
<p>When a new sequence is created we check the parent marker' sequences with the function <code>normalizeMarkers()</code> in order from high to low rank. In this function, we remove those <code>PM</code>s that it's belonging sequence is referenced by others.</p>
<p>An example is <strong>msg 10</strong> in the figure above, $[0,2], [1,1], [2,3]$ are <code>PM</code>s to be considered to inherit. $[2,3]$ is the first marker to check, since it has the highest sequence rank. We select the parent sequences of $[2,3]$, which are $0$ and $1$, and the referenced <code>PM</code>s therein. Next any <code>PM</code>s that are already referenced can be removed. This results in that the PMs of <strong>msg 10</strong> is $[2,3]$ only.</p>
<p>In the following we show the implementation of  <code>normalizeMarkers()</code>, which returns the markers and sequences that will be inherited from a message.</p>
<pre><code class="language-go">// normalizeMarkers takes a set of Markers and removes each Marker that is already referenced by another Marker in the
// same set (the remaining Markers are the &quot;most special&quot; Markers that reference all Markers in the set grouped by the
// rank of their corresponding Sequence). In addition, the method returns all SequenceIDs of the Markers that were not
// referenced by any of the Markers (the tips of the Sequence DAG).
func (m *Manager) normalizeMarkers(markers *Markers) (normalizedMarkersByRank *markersByRank, normalizedSequences SequenceIDs) {
	rankOfSequencesCache := make(map[SequenceID]uint64)

	normalizedMarkersByRank = newMarkersByRank()
	normalizedSequences = make(SequenceIDs)
	// group markers with same sequence rank
	markers.ForEach(func(sequenceID SequenceID, index Index) bool {
		normalizedSequences[sequenceID] = types.Void
		normalizedMarkersByRank.Add(m.rankOfSequence(sequenceID, rankOfSequencesCache), sequenceID, index)

		return true
	})
	markersToIterate := normalizedMarkersByRank.Clone()

	//iterate from highest sequence rank to lowest
	for i := markersToIterate.HighestRank() + 1; i &gt; normalizedMarkersByRank.LowestRank(); i-- {
		currentRank := i - 1
		markersByRank, rankExists := markersToIterate.Markers(currentRank)
		if !rankExists {
			continue
		}

		// for each marker from the current sequence rank check if we can remove a marker in normalizedMarkersByRank,
		// and add the parent markers to markersToIterate if necessary
		if !markersByRank.ForEach(func(sequenceID SequenceID, index Index) bool {
			if currentRank &lt;= normalizedMarkersByRank.LowestRank() {
				return false
			}

			if !(&amp;CachedSequence{CachedObject: m.sequenceStore.Load(sequenceID.Bytes())}).Consume(func(sequence *Sequence) {
				// for each of the parentMarkers of this particular index
				sequence.HighestReferencedParentMarkers(index).ForEach(func(referencedSequenceID SequenceID, referencedIndex Index) bool {
					// of this marker delete the referenced sequences since they are no sequence tips anymore in the sequence DAG
					delete(normalizedSequences, referencedSequenceID)

					rankOfReferencedSequence := m.rankOfSequence(referencedSequenceID, rankOfSequencesCache)
					// check whether there is a marker in normalizedMarkersByRank that is from the same sequence
					if index, indexExists := normalizedMarkersByRank.Index(rankOfReferencedSequence, referencedSequenceID); indexExists {
						if referencedIndex &gt;= index {
							// this referencedParentMarker is from the same sequence as a marker in the list but with higher index - hence remove the index from the Marker list
							normalizedMarkersByRank.Delete(rankOfReferencedSequence, referencedSequenceID)

							// if rankOfReferencedSequence is already the lowest rank of the original markers list,
							// no need to add it since parents of the referencedMarker cannot delete any further elements from the list
							if rankOfReferencedSequence &gt; normalizedMarkersByRank.LowestRank() {
								markersToIterate.Add(rankOfReferencedSequence, referencedSequenceID, referencedIndex)
							}
						}

						return true
					}

					// if rankOfReferencedSequence is already the lowest rank of the original markers list,
					// no need to add it since parents of the referencedMarker cannot delete any further elements from the list
					if rankOfReferencedSequence &gt; normalizedMarkersByRank.LowestRank() {
						markersToIterate.Add(rankOfReferencedSequence, referencedSequenceID, referencedIndex)
					}

					return true
				})
			}) {
				panic(fmt.Sprintf(&quot;failed to load Sequence with %s&quot;, sequenceID))
			}

			return true
		}) {
			return
		}
	}

	return
}
</code></pre>
<h3 id="markers-application-past-cone-check"><a class="header" href="#markers-application-past-cone-check">Markers Application: Past Cone Check</a></h3>
<p>By comparing the past and future markers of messages, we can easily tell if one is in another's past cone. The function returns a <code>TriBool</code> representing the three possible statuses: <code>True</code>, <code>False</code> and <code>Maybe</code>. If <code>Maybe</code> is returned, then we need to perform a search of the Tangle by walking by means of e.g. a Breadth-First Search.</p>
<p>In the following we show the implementation of the past cone check: </p>
<pre><code class="language-go">// IsInPastCone checks if the earlier Markers are directly or indirectly referenced by the later Markers.
func (m *Manager) IsInPastCone(earlierMarkers *MarkersPair, laterMarkers *MarkersPair) (referenced TriBool) {
	// fast check: if earlier Markers have larger highest Indexes they can't be in the past cone
	if earlierMarkers.PastMarkers.HighestIndex() &gt; laterMarkers.PastMarkers.HighestIndex() {
		return False
	}

	// fast check: if earlier Marker is a past Marker and the later ones reference it we can return early
	if earlierMarkers.IsPastMarker {
		earlierMarker := earlierMarkers.PastMarkers.FirstMarker()
		if earlierMarker == nil {
			panic(&quot;failed to retrieve Marker&quot;)
		}

		if laterIndex, sequenceExists := laterMarkers.PastMarkers.Get(earlierMarker.sequenceID); sequenceExists {
			if laterIndex &gt;= earlierMarker.index {
				return True
			}

			return False
		}

		if laterMarkers.PastMarkers.HighestIndex() &lt;= earlierMarker.index {
			return False
		}
	}

	if laterMarkers.IsPastMarker {
		laterMarker := laterMarkers.PastMarkers.FirstMarker()
		if laterMarker == nil {
			panic(&quot;failed to retrieve Marker&quot;)
		}

		// if the earlier Marker inherited an Index of the same Sequence that is higher than the later we return false
		if earlierIndex, sequenceExists := earlierMarkers.PastMarkers.Get(laterMarker.sequenceID); sequenceExists &amp;&amp; earlierIndex &gt;= laterMarker.index {
			return False
		}

		// if the earlier Markers are referenced by a Marker of the same Sequence that is larger, we are not in the past cone
		if earlierFutureIndex, earlierFutureIndexExists := earlierMarkers.FutureMarkers.Get(laterMarker.sequenceID); earlierFutureIndexExists &amp;&amp; earlierFutureIndex &gt; laterMarker.index {
			return False
		}

		// if the earlier Markers were referenced by the same or a higher future Marker we are not in the past cone
		// (otherwise we would be the future marker)
		if !laterMarkers.FutureMarkers.ForEach(func(sequenceID SequenceID, laterIndex Index) bool {
			earlierIndex, similarSequenceExists := earlierMarkers.FutureMarkers.Get(sequenceID)
			return !similarSequenceExists || earlierIndex &lt; laterIndex
		}) {
			return False
		}

		if earlierMarkers.PastMarkers.HighestIndex() &gt;= laterMarker.index {
			return False
		}
	}

	// if the highest Indexes of both past Markers are the same ...
	if earlierMarkers.PastMarkers.HighestIndex() == laterMarkers.PastMarkers.HighestIndex() {
		// ... then the later Markers should contain exact copies of all of the highest earlier Markers because parent
		// Markers get inherited and if they would have been captured by a new Marker in between then the highest
		// Indexes would no longer be the same
		if !earlierMarkers.PastMarkers.ForEach(func(sequenceID SequenceID, earlierIndex Index) bool {
			if earlierIndex == earlierMarkers.PastMarkers.HighestIndex() {
				laterIndex, sequenceExists := laterMarkers.PastMarkers.Get(sequenceID)
				return sequenceExists &amp;&amp; laterIndex != earlierIndex
			}

			return true
		}) {
			return False
		}
	}

	if earlierMarkers.FutureMarkers.HighestIndex() == laterMarkers.FutureMarkers.HighestIndex() &amp;&amp; false {
		// the earlier future markers need to contain all later ones because if there would be another marker in between that shadows them the later future Marker would have a higher index
		if !laterMarkers.FutureMarkers.ForEach(func(sequenceID SequenceID, laterIndex Index) bool {
			if laterIndex == laterMarkers.FutureMarkers.highestIndex {
				earlierIndex, sequenceExists := earlierMarkers.FutureMarkers.Get(sequenceID)
				return sequenceExists &amp;&amp; earlierIndex == laterIndex
			}

			return true
		}) {
			return False
		}
	}

	// detailed check: earlier marker is referenced by something that the later one references
	if m.markersReferenceMarkers(laterMarkers.PastMarkers, earlierMarkers.FutureMarkers, false) {
		return True
	}

	// detailed check: the
	if m.markersReferenceMarkers(earlierMarkers.FutureMarkers, laterMarkers.PastMarkers, true) {
		return Maybe
	}

	return False
}

</code></pre>
<h3 id="markers-application-approval-weight-estimation"><a class="header" href="#markers-application-approval-weight-estimation">Markers Application: Approval Weight Estimation</a></h3>
<p>To approximate the approval weight of a message, we simply retrieve the approval weight of its <code>FM</code> list. Since the message is in the past cone of its <code>FM</code>s, the approval weight and the finality will be at least the same as its <code>FM</code>s. This will of course be a lower bound (which is the “safe” bound), but if the markers are set frequently enough, it should be a good approximation.</p>
<p>Details of managing approval weight of each marker and approval weight calculation of each messages refer to the Approval Weight Spec.
&gt;:mega: Add link here. </p>
<h1 id="concepts"><a class="header" href="#concepts">Concepts</a></h1>
<h1 id="glossary-1"><a class="header" href="#glossary-1">Glossary</a></h1>
<h4 id="application-layer"><a class="header" href="#application-layer">APPLICATION LAYER</a></h4>
<p>The IOTA Protocol allows for a host of applications to run on the message tangle. Anybody can design an application, and users can decide which applications to run on their nodes. These applications will all use the communication layer to broadcast and store data.</p>
<h3 id="approval-switch"><a class="header" href="#approval-switch">APPROVAL SWITCH</a></h3>
<p>When selecting a message as a parent, we can select from the strong or weak tip pool. This mechanism is called approval switch. </p>
<h3 id="approval-weight"><a class="header" href="#approval-weight">APPROVAL WEIGHT</a></h3>
<p>A message gains mana weight, by messages approving it directly or indirectly. However, only strong parents can propagate the mana weight to the past, while weak parents obtain the weight from its weak children but don't propagate it.d</p>
<h4 id="blockchain-bottleneck"><a class="header" href="#blockchain-bottleneck">BLOCKCHAIN BOTTLENECK</a></h4>
<p>As more transactions are issued, the block rate and size become a bottleneck in the system. It can no longer include all incoming transactions promptly. Attempts to speed up block rates will introduce more orphan blocks (blocks being left behind) and reduce the security of the blockchain.</p>
<h4 id="consensus"><a class="header" href="#consensus">CONSENSUS</a></h4>
<p>Agreement on a specific datum or value in distributed multi-agent systems, in the presence of faulty processes.</p>
<h4 id="core-applications"><a class="header" href="#core-applications">CORE APPLICATIONS</a></h4>
<p>Applications that are necessary for the protocol to operate. These include for example:</p>
<ul>
<li>The value transfer application</li>
<li>The distributed random number generator (DRNG for short)</li>
<li>The Fast Probabilistic Consensus (FPC) protocol</li>
</ul>
<h4 id="communication-layer"><a class="header" href="#communication-layer">COMMUNICATION LAYER</a></h4>
<p>This layer stores and communicates information. This layer contains the “distributed ledger” or the tangle. The rate control and timestamps are in this layer too.</p>
<h4 id="coordinator-1"><a class="header" href="#coordinator-1">COORDINATOR</a></h4>
<p>A trusted entity that issues milestones to guarantee finality and protect the Tangle against attacks.</p>
<h4 id="eclipse-attack"><a class="header" href="#eclipse-attack">ECLIPSE ATTACK</a></h4>
<p>A cyber-attack that aims to isolate and attack a specific user, rather than the whole network.</p>
<h3 id="epoch"><a class="header" href="#epoch">EPOCH</a></h3>
<p>A time interval that is used for a certain type of consensus mana. At the end of each epoch a snapshot of the state of mana distribution in the network is taken. Since this tool employs the timestamp of messages every node can reach consensus on a epoch's mana distibution eventually.</p>
<h4 id="faucet"><a class="header" href="#faucet">FAUCET</a></h4>
<p>A test application issuing funds on request.</p>
<h4 id="finality"><a class="header" href="#finality">FINALITY</a></h4>
<p>The property that once a transaction is completed there is no way to revert or alter it. This is the moment when the parties involved in a transfer can consider the deal done. Finality can be deterministic or probabilistic.</p>
<h4 id="history"><a class="header" href="#history">HISTORY</a></h4>
<p>The list of transactions directly or indirectly approved by a given transaction.</p>
<h4 id="local-modifiers"><a class="header" href="#local-modifiers">LOCAL MODIFIERS</a></h4>
<p>Custom conditions that nodes can take into account during tip selection. In IOTA, nodes do not necessarily have the same view of the Tangle; various kinds of information only locally available to them can be used to strengthen security.</p>
<h4 id="mana-1"><a class="header" href="#mana-1">MANA</a></h4>
<p>The reputation of a node is based on a virtual token called mana. This reputation, working as a Sybil protection mechanism, is important for issuing more transactions (see Module 3) and having a higher influence during the voting process (see Module 5).</p>
<h3 id="markers-1"><a class="header" href="#markers-1">MARKERS</a></h3>
<p>A tool that exists only locally and allows to perform certain calcuations more efficiently. Such as approval weight calculation or the existence of certain messages in the past or future cone of another message.</p>
<h4 id="message-5"><a class="header" href="#message-5">MESSAGE</a></h4>
<p>The object that is gossiped between neighbors. All gossiped information is included in a message. The most basic unit of information of the IOTA Protocol. Each message has a type and size and contains data.</p>
<h4 id="message-overhead"><a class="header" href="#message-overhead">MESSAGE OVERHEAD</a></h4>
<p>The additional information (metadata) that needs to be sent along with the actual information (data). This can contain signatures, voting, heartbeat signals, and anything that is transmitted over the network but is not the transaction itself.</p>
<h4 id="milestones"><a class="header" href="#milestones">MILESTONES</a></h4>
<p>Milestones are transactions signed and issued by the Coordinator. Their main goal is to help the Tangle to grow healthily and to guarantee finality. When milestones directly or indirectly approve a transaction in the Tangle, nodes mark the state of that transaction and its entire history as confirmed.</p>
<h4 id="mining-races"><a class="header" href="#mining-races">MINING RACES</a></h4>
<p>In PoW-based DLTs, competition between nodes to obtain mining rewards and transaction fees are known as mining races. These are undesirable as they favor more powerful nodes, especially those with highly optimized hardware like ASICs. As such, they block participation by regular or IoT hardware and are harmful for the environment.</p>
<h4 id="nakamoto-consensus"><a class="header" href="#nakamoto-consensus">NAKAMOTO CONSENSUS</a></h4>
<p>Named after the originator of Bitcoin, Satoshi Nakamoto, Nakamoto consensus describes the replacement of voting/communication between known agents with a cryptographic puzzle (Proof-of-Work). Completing the puzzle determines which agent is the next to act.</p>
<h4 id="neighbors"><a class="header" href="#neighbors">NEIGHBORS</a></h4>
<p>Network nodes that are directly connected and can exchange messages without intermediate nodes.</p>
<h4 id="network-layer"><a class="header" href="#network-layer">NETWORK LAYER</a></h4>
<p>This layer manages the lower layers of internet communication like TCP. It is the most technical, and in some ways the least interesting. In this layer, the connections between nodes are managed by the autopeering and peer discovery modules and the gossip protocol.</p>
<h4 id="node-2"><a class="header" href="#node-2">NODE</a></h4>
<p>A machine which is part of the IOTA network. Its role is to issue new transactions and to validate existing ones.</p>
<h4 id="orphan"><a class="header" href="#orphan">ORPHAN</a></h4>
<p>A transaction (or block) that is not referenced by any succeeding transaction (or block). An orphan is not considered confirmed and will not be part of the consensus.</p>
<h4 id="peering"><a class="header" href="#peering">PEERING</a></h4>
<p>The procedure of discovering and connecting to other network nodes.</p>
<h4 id="proof-of-work"><a class="header" href="#proof-of-work">PROOF-OF-WORK</a></h4>
<p>Data which is difficult (costly, time-consuming) to produce but easy for others to verify.</p>
<h4 id="reattachment"><a class="header" href="#reattachment">REATTACHMENT</a></h4>
<p>Resending a transaction by redoing tip selection and referencing newer tips by redoing PoW.</p>
<h4 id="small-world-network"><a class="header" href="#small-world-network">SMALL-WORLD NETWORK</a></h4>
<p>A network in which most nodes can be reached from every other node by a small number of intermediate steps.</p>
<h4 id="solidification-time"><a class="header" href="#solidification-time">SOLIDIFICATION TIME</a></h4>
<p>The solidification time is the point at which the entire history of a transaction has been received by a node.</p>
<h4 id="splitting-attacks"><a class="header" href="#splitting-attacks">SPLITTING ATTACKS</a></h4>
<p>An attack in which a malicious node attempts to split the Tangle into two branches. As one of the branches grows the attacker publishes transactions on the other branch to keep both alive.Splitting attacks attempt to slow down the consensus process or conduct a double spend.</p>
<h4 id="subtangle"><a class="header" href="#subtangle">SUBTANGLE</a></h4>
<p>A consistent section of the Tangle (i.e. a subset of messages), such that each included message also includes its referenced messages.</p>
<h4 id="sybil-attack"><a class="header" href="#sybil-attack">SYBIL ATTACK</a></h4>
<p>An attempt to gain control over a peer-to-peer network by forging multiple fake identities.</p>
<h3 id="parent"><a class="header" href="#parent">PARENT</a></h3>
<p>A message approved by another message is called a parent to the latter. A parent can be selected as strong or weak parent. If the past cone of the parent is liked the parent is set as strong parent. If the message is liked but its past cone is disliked it is set as a weak parent. This mechanism is called approval switch.</p>
<h4 id="payload-3"><a class="header" href="#payload-3">PAYLOAD</a></h4>
<p>A field in a message which determines the type. Examples are:</p>
<ul>
<li>Value payload (type TransactionType)</li>
<li>FPC Opinion payload (type StatementType)</li>
<li>dRNG payload</li>
<li>Salt declaration payload</li>
<li>Generic data payload</li>
</ul>
<h4 id="tangle"><a class="header" href="#tangle">TANGLE</a></h4>
<p>An append only message data structure where each message references (at least) two other messages.</p>
<h4 id="transaction-3"><a class="header" href="#transaction-3">TRANSACTION</a></h4>
<p>A message with payload of type TransactionType. It contains the information of a transfer of funds.</p>
<h4 id="tip"><a class="header" href="#tip">TIP</a></h4>
<p>A message that has not yet been approved.</p>
<h4 id="tip-selection"><a class="header" href="#tip-selection">TIP SELECTION</a></h4>
<p>The process of selecting previous messages to be referenced by a new message. These references are where a message attaches to the existing data structure. IOTA only enforces that a message approves (at least) two other messages, but the tip selection strategy is left up to the user (with a good default provided by IOTA).</p>
<h4 id="utxo"><a class="header" href="#utxo">UTXO</a></h4>
<p>Unspent transaction output.</p>
<h4 id="value-transfer-application"><a class="header" href="#value-transfer-application">VALUE TRANSFER APPLICATION</a></h4>
<p>The application which maintains the ledger state.</p>
<h1 id="layers"><a class="header" href="#layers">Layers</a></h1>
<blockquote>
<p>DISCLAIMER: The described layers describe how things are implemented in GoShimmer. They might not reflect final Coordicide specification or implementations.</p>
</blockquote>
<p>GoShimmer abstracts node functionalities into different layers. Similar to other architectures, upper layers build on the provided functionality of the layers below them. A layer is merely the concept of creating a clear separation of concerns.</p>
<p>Layers operate on payloads and it is up to the layer to react to the wanted payload types.</p>
<h2 id="communication-layer-1"><a class="header" href="#communication-layer-1">Communication Layer</a></h2>
<p>The communication layer is the most primitive layer, as its job is to simply form a graph made out of messages which contain payloads. As the name implies, messages are communicated/gossiped throughout the entire network. Think of it as the &quot;physical layer&quot; in the OSI-model. This layer forms a DAG made up from messages as a each message references two previous messages.</p>
<h3 id="message-6"><a class="header" href="#message-6">Message</a></h3>
<p>A message is a core data type which reflects a vertex in the communication layer <a href="https://en.wikipedia.org/wiki/Directed_acyclic_graph">DAG</a>.</p>
<p>It contains following properties:</p>
<ul>
<li>References to other messages</li>
<li>Issuer's public key</li>
<li>The issuance time of the message</li>
<li>The message sequence number from the node which issued the message</li>
<li>Payload which might be interpreted by upper layers</li>
<li>The nonce which lets the message fulfill the PoW requirement</li>
<li>A Signature signing all of the above fields.</li>
</ul>
<p>A message is gossiped only when it becomes solid, meaning that its past history is known to the node. Messages currently must become solid within a 30 seconds time period, otherwise they are discarded.</p>
<p>Messages must also fulfill a PoW requirement currently which involves finding a nonce so that the hash of the fields of the message (minus the signature) has a certain amount of leading zeros. The PoW currently operates on <code>BLAKE2b_512</code>. Later the PoW requirement will be substituted by the actual Coordicide rate control mechanisms.</p>
<p>A message's byte layout is defined as:</p>
<pre><code>parent_0&lt;64bytes&gt;
parent_1&lt;64bytes&gt;
issuer_public_key&lt;32bytes&gt;
issuance_time&lt;int64,8bytes&gt;
sequence_number&lt;uint64,8bytes&gt;
payload&lt;variable-size, max 64KBs&gt;
nonce&lt;uint64,8bytes&gt;
signature&lt;64bytes&gt;
</code></pre>
<h3 id="payloads"><a class="header" href="#payloads">Payloads</a></h3>
<p>As described above, a message contains a payload. In GoShimmer, there are 3 defined payload types, however, <a href="https://github.com/iotaledger/goshimmer/wiki/How-to-create-a-simple-dApp">more such types can be defined by developers seeking to implement their own application on top of the communication layer</a>.</p>
<table><thead><tr><th>Type ID</th><th>Name</th><th>Purpose</th></tr></thead><tbody>
<tr><td>0</td><td>Data</td><td>Holds raw bytes without any further meaning</td></tr>
<tr><td>1</td><td>Value Object</td><td>Represents a value object on the value layer</td></tr>
<tr><td>111</td><td>DRNG Object</td><td>Represents a DRNG object for the DRNG layer</td></tr>
</tbody></table>
<p>A payload's byte layout is defined as:</p>
<pre><code>type&lt;uint32-4bytes&gt;
length&lt;uint32-4bytes&gt;
data&lt;length bytes&gt;
</code></pre>
<p>It is a upper layer's concern to listen for messages which hold specific payload types up on which the layer operates on.</p>
<h3 id="tip-selection-1"><a class="header" href="#tip-selection-1">Tip-Selection</a></h3>
<p>Since on the communication layer the payloads do not impose any restriction on the validity of a message, the tip-selection can simply operate on a pool of recent solid tips. However, in the future the tip-selector might impose certain restrictions such as below-max-depth checks and so on.</p>
<h2 id="value-layer"><a class="header" href="#value-layer">Value Layer</a></h2>
<p>The value layer operates solely on payloads of type value object. This layer has multiple responsibilities:</p>
<ul>
<li>Forming the ledger state</li>
<li>Processing, validating and issuing transactions</li>
<li>Conflict detection</li>
<li>Conflict resolution via FPC</li>
<li>Forming a DAG made up from value objects</li>
<li>Tip-selection (on value object tips)</li>
</ul>
<h3 id="value-object"><a class="header" href="#value-object">Value Object</a></h3>
<p>A value object is an object derived from a message containing a value object payload. It references two other value objects and contains one transaction.</p>
<p>The two references express vouching for the referenced value objects, meaning that they are seen as valid from the PoV of the value object which references them.</p>
<p>A value object is solid when its past cone is known and the contained transaction's inputs are known.</p>
<p>A transaction can occur in multiple value objects. In that case we speak of reattachments.</p>
<p>A value object's byte layout is defined as:</p>
<pre><code>type&lt;uint32-4bytes&gt;
length&lt;uint32-4bytes&gt;
parent_0_reference&lt;32bytes&gt;
parent_1_reference&lt;32bytes&gt;
transaction&lt;variable size&gt;
</code></pre>
<h3 id="utxo-1"><a class="header" href="#utxo-1">UTXO</a></h3>
<p>GoShimmer uses unspent transaction outputs (UTXOs) as inputs for transactions. Meaning that inputs reference a specific UTXO ID which was generated by a previous transaction. The UTXO ID is made up from the destination address plus the hash of the transaction creating the output.</p>
<h4 id="inputs"><a class="header" href="#inputs">Inputs</a></h4>
<p>As just described, an input is merely a reference to another transaction's output to a given address. GoShimmer currently works on addresses and unlike other cryptocurrencies does not yet have any concept of other unlocking mechanisms.</p>
<p>Addresses are BLAKE2b hashes of the corresponding Ed25519 and BLS public keys.</p>
<h4 id="outputs-1"><a class="header" href="#outputs-1">Outputs</a></h4>
<p>An output encapsulates a destination address and a list of balances. A balance is an amount of tokens and a color.</p>
<h5 id="color--coloring"><a class="header" href="#color--coloring">Color &amp; Coloring</a></h5>
<p>The color of a balance is simply an array of 32 bytes and per default, tokens have a color of type &quot;IOTA&quot;, where all 32 bytes are zero.</p>
<p>Creating a new color involves specifying the special color type &quot;New&quot; in a transaction output, where each byte in the color array is set to 255. Doing this will instruct GoShimmer to then color the specific balance on the specific address of the given output to the hash of the transaction creating the output. New colors therefore simply equal the transaction hash of the transaction creating the output (and are therefore unique).</p>
<p>Coloring tokens does neither increase or decrease the token supply. It is up to merchants and other systems to provide meaning to the colors of tokens.</p>
<p>Because of the way the coloring works, any holder of colored tokens can &quot;shrink&quot; the circulating amount of the specific colored token by simply creating outputs again with the special color type &quot;New&quot;. Of course doing so will only effect the actual holder of the colored tokens but it is something to keep in mind when developing a system around colored tokens.</p>
<h3 id="transaction-4"><a class="header" href="#transaction-4">Transaction</a></h3>
<p>A transaction defines a transfer from UTXOs to new outputs.</p>
<p>It contains following properties:</p>
<ul>
<li>Inputs</li>
<li>Outputs</li>
<li>Payload</li>
<li>Signatures</li>
</ul>
<p>These properties minus the signatures make up the &quot;essence&quot; bytes of the transaction. Each signature signs the essence data. Therefore, if a transaction contains multiple inputs consuming UTXOs from an address, only one signature for that address needs to be provided.</p>
<p>A transaction is marked as solid when all of its referenced inputs are known.</p>
<p>A transactions’s byte layout is defined as:</p>
<pre><code>inputs_count&lt;uint32-4bytes&gt;
 (per input)-&gt;
     address&lt;33bytes&gt;
     utxo_id&lt;32bytes&gt;
     
outputs_count&lt;uint32-4bytes&gt;
 (per output)-&gt;
     address&lt;33bytes&gt;
     balances_count&lt;uint32-4bytes&gt;
      (per balance)-&gt;
          value&lt;int64-8bytes&gt;
          color&lt;32bytes&gt;
          
payload_length&lt;int32-8bytes&gt;
payload&lt;payload_length bytes&gt;

(signatures (multiple occurrences in any order))-&gt;
    (ED25519)-&gt;
        signature_type(1 byte, value = 1)
        public_key&lt;32bytes&gt;
        signature&lt;64bytes&gt;
    (BLS)-&gt;
        signature_type(1byte, value = 2)
        public_key&lt;128bytes&gt;
        signature&lt;64bytes&gt;
signature_block_end&lt;1byte, value 0&gt;
</code></pre>
<p>The payload length inside the transaction can be max 65KBs.</p>
<h3 id="parallel-reality-based-ledger-state"><a class="header" href="#parallel-reality-based-ledger-state">Parallel reality based ledger state</a></h3>
<p>GoShimmer uses the parallel reality based ledger state <a href="https://medium.com/@hans_94488/a-new-consensus-the-tangle-multiverse-part-1-da4cb2a69772">introduced by Hans in his blogpost series</a>. Unlike the blogpost however, conflict resolution is done via <a href="https://blog.iota.org/consensus-in-the-iota-tangle-fpc-b98e0f1e8fa">FPC</a>. There is also no notion of mana as of yet or 'partial liking' other opinion realities.</p>
<p>Note that the reason the ledger state is implemented this way is to make it easier to extend it for the multiverse consensus in case it becomes a viable choice.</p>
<h4 id="branches--realities"><a class="header" href="#branches--realities">Branches / Realities</a></h4>
<p>Realities are called branches in GoShimmer. A branch's ID is defined as a 32 byte long array. The master branch's ID is a 32 byte array where the first byte has the value 1.</p>
<p>Branches are created every time a conflict arises. The created branches have the IDs of the transactions which inflict/create the conflict.</p>
<p>Branches are in some sense a performance optimization as they allow to group transactions reflecting the same &quot;reality&quot; of ledger mutations as a group.</p>
<h5 id="conflict-detection"><a class="header" href="#conflict-detection">Conflict detection</a></h5>
<p>As mentioned, transactions use UTXO as inputs. Every time a transaction consumes a given output, the consumer count on the output is incremented. If the consumer count goes above 1, a conflict arises, since multiple transactions are trying to consume/use the same UTXO (double spend).</p>
<p>Note that in the case that there is yet no finalized/confirmed consumer of the UTXO, the transactions forming the conflict set each spawn their own branch. Likewise, if a transaction is the first consumer of an output, it doesn't create a new branch (may however generate an aggregated branch).</p>
<h5 id="aggregated-branches"><a class="header" href="#aggregated-branches">Aggregated Branches</a></h5>
<p>Since transactions are assigned to branches, transactions consuming outputs from transactions (which are non-conflicting) which reside in different branches, can create new so called aggregated branches. An aggregated branch is a virtual branch which reflects the change set of mutations of the ledger aggregated out of different branches.</p>
<h4 id="balances"><a class="header" href="#balances">Balances</a></h4>
<p>Making up the balances of a given address involves querying the node for UTXOs which have as a target the given address.</p>
<h3 id="consensus-1"><a class="header" href="#consensus-1">Consensus</a></h3>
<h4 id="fpc--fcob"><a class="header" href="#fpc--fcob">FPC &amp; FCoB</a></h4>
<p>We define a conflict as consuming (i.e., spending) more than once an (unspent) output. </p>
<p>Initially a node likes a transaction <code>v</code> that solidified at time <code>t</code> if in the interval <code>(−∞, t + avgNetworkDelay]</code> there are no spends from the same output (used as input).</p>
<p>If a conflicting transaction solidifies after that, we initially dislike it and add both (initially liked and initially disliked) conflicting transactions to the unresolved conflict set.</p>
<p>If no conflicting transactions solidify in the interval <code>(−∞, t + (2* avgNetworkDelay)]</code> we confirm (definitively like) <code>v</code>.</p>
<p>If <code>v_1,...,v_k</code> are all re-attachments of the same transaction, we either like all or none following the rule above.</p>
<p>Every <code>T</code> seconds a “Fast Probabilistic Consensus” (FPC) voting round is applied to every unresolved conflicting transaction in the Tangle:</p>
<ul>
<li>each node queries a set of randomly chosen nodes about its unresolved conflicting transactions; </li>
<li>the queried nodes send back their opinions on the requested transactions;</li>
</ul>
<p>After the FPC is done the values <code>g(v)</code> of several transactions may change and then it stays the same forever. 
That is, after the vote a transaction is either confirmed (definitely liked) or rejected (definitely disliked) by a node, and this value will never change. Further discussion about monotonicity appears below.</p>
<h4 id="monotonicity"><a class="header" href="#monotonicity">Monotonicity</a></h4>
<p>If <code>u</code> approves <code>v</code>, then <code>g(v) ≥ g(u)</code>, that is, if a node likes u then it likes any transaction <code>u</code> approves, and if the node dislikes <code>v</code> then it dislikes any transaction that approve <code>v</code>. </p>
<p>Another way of saying it is that if we like <code>v</code> then we like all of its past cone, and if we dislike <code>v</code> we dislike all of its future cone.
The votes of any node will follow the monotonicity rule.</p>
<h1 id="team-resources"><a class="header" href="#team-resources">Team resources</a></h1>
<h1 id="how-to-do-a-release"><a class="header" href="#how-to-do-a-release">How to do a release</a></h1>
<ol>
<li>Create a PR into <code>develop</code> updating the banner version (<code>plugins/banner.AppVersion</code>) and mentioning the changes in <code>CHANGELOG.md</code></li>
<li>Create a PR merging <code>develop</code> into <code>master</code></li>
<li>Create a release via the release page with the same changelog entries as in <code>CHANGELOG.md</code> for the given version tagging the <code>master</code> branch</li>
<li>Pray that the CI gods let the build pass</li>
<li>Check that the binaries are working</li>
<li>Stop the entry-node</li>
<li>Delete DB</li>
<li>Update version in docker-compose</li>
<li>Pull newest image</li>
<li>Start the node</li>
</ol>
<h1 id="code-guidelines"><a class="header" href="#code-guidelines">Code guidelines</a></h1>
<h2 id="general-guidelines"><a class="header" href="#general-guidelines">General guidelines</a></h2>
<ul>
<li>Don’t use <code>log.Fatal()</code> or <code>os.Exit()</code> outside of the main. It immediately terminates the program and all defers are ignored and no graceful shutdown is possible. It can lead to inconsistencies. Propagate the error up to the main and let the main function exit instead. Avoid panics as well, almost always use errors. <a href="https://github.com/iotaledger/goshimmer/blob/f75ce47eeaa3bf930b368754ac24b72f768a5964/plugins/autopeering/autopeering.go#L135">Example</a>.</li>
<li>Don’t duplicate code, reuse it. In tests too. Example: <a href="https://github.com/iotaledger/goshimmer/blob/f75ce47eeaa3bf930b368754ac24b72f768a5964/packages/ledgerstate/branch_dag.go#L969">duplicate1</a> and <a href="https://github.com/iotaledger/goshimmer/blob/f75ce47eeaa3bf930b368754ac24b72f768a5964/packages/ledgerstate/branch_dag.go#L1053">duplicate2</a></li>
<li>Unhandled errors can cause bugs and make it harder to diagnose problems. Try to handle all errors: propagate them to the caller or log them. Even if the function call is used with a defer, and it’s inconvenient to handle the error it returns, still handle it. Wrap the function call in an anonymous function assign error to the upper error  like that:</li>
</ul>
<pre><code class="language-go">    defer func() {
        cerr := f.Close()
        if err == nil {
            err = xerrors.Errorf(&quot;failed to close file: %w&quot;, cerr)
        }
    }()
</code></pre>
<ul>
<li>Wrap errors with <code>xerrors.Errorf()</code> when returning them to the caller. It adds the stack trace and a custom message to the error. Without that information investigating an issue is very hard.</li>
<li>Use <code>xerrors.Is()</code> instead of direct errors comparison. This function unwraps errors recursively. <a href="https://github.com/iotaledger/goshimmer/pull/1113/files#diff-05fdc081489a8d5a61224d812f9bbd7bc77edf9769ed00d95ea024d2a44a699aL62">Example</a>.</li>
<li>Propagate <code>ctx</code> and use APIs that accept <code>ctx</code>, start exposing APIs that accept <code>ctx</code>. Context is a native way for timeouts/cancellation in Go. It allows writing more resilient and fault tolerant code. <a href="https://github.com/iotaledger/goshimmer/pull/1113/files#diff-f2820ed0d3d4d9ea05b78b1dd3978dbcf9401c8caaa8cc40cc1c0342a55379fcL35">Example</a>.</li>
<li>Don’t shadow builtin functions like copy, len, new etc. <a href="https://github.com/iotaledger/goshimmer/pull/1113/files#diff-f07268750a44da26386469c1b1e93574a678c3d418fce9e1f186d5f1991a92eaL14">Example</a>.</li>
<li>Don’t shadow imported packages. <a href="https://github.com/iotaledger/goshimmer/blob/f75ce47eeaa3bf930b368754ac24b72f768a5964/plugins/webapi/value/sendtransactionbyjson.go#L172">Example</a>.</li>
<li>Don’t do <code>[:]</code> on a slice. It has no effect. <a href="https://github.com/iotaledger/goshimmer/pull/1113/files#diff-299a1ac5fa09739ea07b7c806ee2785d83eea110f8af143dbc853a25e4819116L133">Example</a>.</li>
<li>Avoid naked returns if the function isn’t very small. It makes the code more readable.</li>
<li>Define explicit constants for strings that are used 3 times or more. It makes the code more maintainable.</li>
<li>Define explicit constants for all numbers. It makes the code more readable.</li>
<li>Don’t write really long and complex functions. Split them into smaller ones.</li>
<li>Treat comments as regular text/documentation. Start with a capital letter, set space after <code>//</code> and end them with a dot. It’s a good habit since Go package docs are generated automatically from the comments and displayed on the godoc site.</li>
</ul>
<h2 id="error-handling"><a class="header" href="#error-handling">Error handling</a></h2>
<p>We use the new error wrapping API and behavior introduced with Go 1.13 but we use the &quot;golang.org/x/xerrors&quot; drop-in replacement which follows the Go 2 design draft and which enables us to have a stack trace for every &quot;wrapping&quot; of the error.</p>
<p>Errors should always be wrapped an annotated with an additional message at each step. The following example shows how errors are wrapped and turned into the corresponding sentinel errors.</p>
<pre><code class="language-go">package example

import (
    &quot;errors&quot;
    &quot;3rdPartyLibrary&quot;

    &quot;golang.org/x/xerrors&quot;
)

// define error variables to make errors identifiable (sentinel errors)
var ErrSentinel = errors.New(&quot;identifiable error&quot;)

// turn anonymous 3rd party errors into identifiable ones
func SentinelErrFrom3rdParty() (result interface{}, err error)
    if result, err = 3rdPartyLibrary.DoSomething(); err != nil {
        err = xerrors.Errorf(&quot;failed to do something (%v): %w&quot;, err, ErrSentinel)
        return
    }

    return
}

// wrap recursive errors at each step
func WrappedErrFromInternalCall() error {
    return xerrors.Errorf(&quot;wrapped internal error: %w&quot;, SentinelErrFrom3rdParty())
}

// create &quot;new&quot; identifiable internal errors that are not originating in 3rd party libs
func ErrFromInternalCall() error {
    return xerrors.Errorf(&quot;internal error: %w&quot;, ErrSentinel)
}

// main function
func main() {
    err1 := WrappedErrFromInternalCall()
    if xerrors.Is(err1, ErrSentinel) {
        fmt.Printf(&quot;%v\n&quot;, err1)
    }

    err2 := ErrFromInternalCall()
    if xerrors.Is(err2 , ErrSentinel) {
        fmt.Printf(&quot;%v\n&quot;, err2 )
    }
}
</code></pre>
<h1 id="golangci-lint"><a class="header" href="#golangci-lint">golangci-lint</a></h1>
<h2 id="overview-10"><a class="header" href="#overview-10">Overview</a></h2>
<p>We use golangci-lint v1.38.0 to run various types of linters on our codebase. All settings are stored in the <code>.golangci.yml</code> file.
golangci-lint is very flexible and customizable. Check the docs to see how configuration works https://golangci-lint.run/usage/configuration/</p>
<h2 id="how-to-run"><a class="header" href="#how-to-run">How to run</a></h2>
<ol>
<li>Install the golangci-lint program https://golangci-lint.run/usage/install/</li>
<li>In the project root: <code>golangci-lint run</code></li>
</ol>
<h2 id="dealing-with-errors"><a class="header" href="#dealing-with-errors">Dealing with errors</a></h2>
<p>Most of the errors that golangci-lint reports are errors from formatting linters like <code>gofmt</code>, <code>goimports</code> and etc. You can easily auto-fix them with:</p>
<pre><code>golangci-lint run --fix
</code></pre>
<p>Here is the full list of linters that support the auto-fix feature: <code>gofmt</code>, <code>gofumpt</code>, <code>goimports</code>, <code>misspell</code>, <code>whitespace</code>.</p>
<p>In case it's not a formatting error, do your best to fix it first. If you think it's a false alarm there are a few ways how to disable that check in golangci-lint:</p>
<ul>
<li>Exclude the check by the error text regexp. Example: <code>'Error return value of .((os\.)?std(out|err)\..*|.*Close|.*Flush|os\.Remove(All)?|.*print(f|ln)?|os\.(Un)?Setenv). is not checked'</code>.</li>
<li>Exclude the entire linter for that file type. Example: don't run <code>errcheck</code> in Go test files.</li>
<li>Change linter settings to make it more relaxed. </li>
<li>Disable that particular error occurrence: use a comment with a special <code>nolint</code> directive next to the place in code with the error. Example: <code>// nolint: errcheck</code>.</li>
</ul>
<h1 id="docker-2"><a class="header" href="#docker-2">Docker</a></h1>
<h2 id="building-image"><a class="header" href="#building-image">Building image</a></h2>
<p>We use the new buildkit docker engine to build <code>iotaledger/goshimmer</code> image. 
The minimum required docker version that supports this feature is <code>18.09</code>. 
To enable buildkit engine in your local docker add the following to the docker configuration json file:</p>
<pre><code class="language-json">{ &quot;features&quot;: { &quot;buildkit&quot;: true } }
</code></pre>
<p>Check this <a href="https://docs.docker.com/develop/develop-images/build_enhancements/#to-enable-buildkit-builds">article</a> for details on how to do that.</p>
<h3 id="troubleshooting-7"><a class="header" href="#troubleshooting-7">Troubleshooting</a></h3>
<p>If you are getting an error like that during the docker build:</p>
<pre><code class="language-dockerfile">Step 10/17 : RUN --mount=target=.     --mount=type=cache,target=/root/.cache/go-build     CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build     -ldflags='-w -s -extldflags &quot;-static&quot;'     -o /go/bin/goshimmer;     ./check_static.sh
 ---&gt; Running in ecdae1c9339d
no Go files in /goshimmer
/bin/sh: 1: ./check_static.sh: not found
The command '/bin/sh -c CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build     -ldflags='-w -s -extldflags &quot;-static&quot;'     -o /go/bin/goshimmer;     ./check_static.sh' returned a non-zero code: 127
</code></pre>
<p>It means that buildkit feature doesn't work in your docker. 
If you already enabled it in the configuration json file as described above and docker version is <code>18.09</code> or higher, 
try to set the following env variables when building the docker image:</p>
<pre><code>DOCKER_BUILDKIT=1 COMPOSE_DOCKER_CLI_BUILD=1 docker build -t iotaledger/goshimmer .
</code></pre>
<h1 id="welcome-to-the-iscp-documentation"><a class="header" href="#welcome-to-the-iscp-documentation">Welcome to the ISCP Documentation</a></h1>
<p>{{ #include ../README.md:4: }}</p>
<h1 id="exploring-iota-smart-contracts"><a class="header" href="#exploring-iota-smart-contracts">Exploring IOTA Smart Contracts</a></h1>
<h2 id="purpose"><a class="header" href="#purpose">Purpose</a></h2>
<p>The document is an introductory tutorial of the IOTA Smart Contract 
platform (ISCP) for developers. </p>
<p>The level of the document is technical. The target audience is software engineers who want 
to understand ISCP and the direction it is taking, in order to develop their own dApps 
and/or contribute to the development of the ISCP and the Wasp node. </p>
<p>The approach in this tutorial is to introduce to main concepts through writing
unit tests of example smart contracts. 
We use Go testing package codenamed <a href="node-software/wasp/docs/tutorial/../../packages/solo/readme.html"><em>Solo</em></a> in all examples of the tutorial.</p>
<p>The knowledge of Go programming and basics of Rust programming is a prerequisite. </p>
<h2 id="chapters"><a class="header" href="#chapters">Chapters</a></h2>
<ul>
<li><a href="node-software/wasp/docs/tutorial/01.html">The <em>Solo</em> package</a></li>
<li><a href="node-software/wasp/docs/tutorial/01.html#first-example">First example</a></li>
<li><a href="node-software/wasp/docs/tutorial/02.html#tokens-and-the-value-tangle">Tokens and the Value Tangle</a></li>
<li><a href="node-software/wasp/docs/tutorial/03.html#creating-a-chain-core-contracts">Creating a chain. Core contracts</a></li>
<li><a href="node-software/wasp/docs/tutorial/03.html#writing-and-compiling-first-rust-smart-contract">Writing and compiling first Rust smart contract</a></li>
<li><a href="node-software/wasp/docs/tutorial/04.html#deploying-and-running-rust-smart-contract">Deploying and running Rust smart contract</a></li>
<li><a href="node-software/wasp/docs/tutorial/05.html#structure-of-the-smart-contract">Structure of the smart contract</a>
<ul>
<li><a href="node-software/wasp/docs/tutorial/05.html#state">State</a></li>
<li><a href="node-software/wasp/docs/tutorial/05.html#entry-points">Entry points</a></li>
</ul>
</li>
<li><a href="node-software/wasp/docs/tutorial/05.html#panic-exception-handling">Panic. Exception handling</a></li>
<li><a href="node-software/wasp/docs/tutorial/06.html">Invoking a smart contract</a>
<ul>
<li><a href="node-software/wasp/docs/tutorial/06.html">Sending a request</a></li>
<li><a href="node-software/wasp/docs/tutorial/07.html">Calling a view</a></li>
</ul>
</li>
<li><a href="node-software/wasp/docs/tutorial/08.html">Sending and receiving funds by example</a>
<ul>
<li><a href="node-software/wasp/docs/tutorial/08.html#sending-and-receiving-tokens-with-the-address">Sending and receiving tokens with the address</a></li>
<li><a href="node-software/wasp/docs/tutorial/09.html#sending-tokens-to-the-smart-contract">Sending tokens to the smart contract</a></li>
<li><a href="node-software/wasp/docs/tutorial/10.html#return-of-tokens-in-case-of-failure">Return of tokens in case of failure</a></li>
<li><a href="node-software/wasp/docs/tutorial/11.html">Sending iotas from smart contract to address</a> </li>
</ul>
</li>
<li><a href="node-software/wasp/docs/tutorial/iscp_accounts.html">ISCP on-chain accounts. Controlling token balances</a></li>
</ul>
<h2 id="annexes"><a class="header" href="#annexes">Annexes</a></h2>
<ul>
<li><a href="node-software/wasp/docs/tutorial/root.html"><code>root</code> contract</a></li>
<li><a href="node-software/wasp/docs/tutorial/accounts.html"><code>accounts</code> contract</a></li>
<li><a href="node-software/wasp/docs/tutorial/blob.html"><code>blob</code> contract</a></li>
<li><a href="node-software/wasp/docs/tutorial/eventlog.html"><code>eventlog</code> contract</a></li>
</ul>
<h1 id="exploring-iota-smart-contracts-1"><a class="header" href="#exploring-iota-smart-contracts-1">Exploring IOTA Smart Contracts</a></h1>
<h2 id="the-solo-package"><a class="header" href="#the-solo-package">The <em>Solo</em> package</a></h2>
<p>Solo is a Go package to write tests for IOTA smart contracts. 
It allows the deployment of ISCP chains and smart contracts. It also provides a toolkit for interaction 
with smart contracts, for manipulation of tokens and ledger accounts in an environment that is almost 
identical to the distributed multi-chain environment of the ISCP. </p>
<p>The <code>Solo</code> package and its <code>GoDoc</code> link <a href="node-software/wasp/docs/tutorial/../../packages/solo/readme.html">can be found here</a>. 
The GoDocs provides a reference to all Solo calls which can be used in tests (not necessarily covered in this tutorial). </p>
<p>Smart contracts are notoriously isolated from the outside world. 
The effect of the user interaction with a smart contract is normally only observed in its state change. 
The approach in this tutorial is to explain all main concepts of ISCP development through 
loading smart contracts into the <em>Solo</em> tests, invoking its functions and examining state changes.</p>
<p>ISCP is currently in active development, so things change and are less than perfect. 
In the current stage the ISCP software is experimental. 
We expect feedback from the community about hands-on experience. 
We also expect contribution to the development of ISCP itself, including Rust/Wasm development environment 
or, possibly, alternative VM implementations. </p>
<p><em>Solo</em> is not a toy environment. It allows developers to develop and test real smart contracts and 
entire inter-chain protocols before deploying them on the distributed network.</p>
<p>Please follow <a href="node-software/wasp/docs/tutorial/install.html">the link</a> for installation instructions.</p>
<h2 id="first-example"><a class="header" href="#first-example">First example</a></h2>
<p>The following is an example of a <em>Solo</em> test. 
It deploys a new chain and invokes a function in the <code>root</code> contract. </p>
<p>The <code>root</code> contract always exists on any chain. 
So for this example there is no need to deploy any new contract.
The test log to the testing output the main parameters of the chain, lists names and IDs of all four core contracts.</p>
<pre><code class="language-go">func TestTutorial1(t *testing.T) {
	env := solo.New(t, false, false)
	chain := env.NewChain(nil, &quot;ex1&quot;)

	chainInfo, coreContracts := chain.GetInfo()   // calls view root::GetInfo
	require.EqualValues(t, 4, len(coreContracts)) // 4 core contracts deployed by default

	t.Logf(&quot;chainID: %s&quot;, chainInfo.ChainID)
	t.Logf(&quot;chain owner ID: %s&quot;, chainInfo.ChainOwnerID)
	for hname, rec := range coreContracts {
		t.Logf(&quot;    Core contract '%s': %s&quot;, rec.Name, coretypes.NewContractID(chain.ChainID, hname))
	}
}
</code></pre>
<p>The output of the test will be something like this:</p>
<pre><code>=== RUN   TestTutorial1
18:47.411	INFO	TestTutorial1	solo/solo.go:160	deploying new chain 'ex1'
18:47.415	INFO	TestTutorial1.ex1	vmcontext/runreq.go:179	eventlog -&gt; '[req] [0]CziZYb8ZkqwgftQ9Am8sz2GTM3EEevWHGSVfuzx74Wan: Ok'
18:47.416	INFO	TestTutorial1.ex1	solo/run.go:82	state transition #0 --&gt; #1. Requests in the block: 1. Posted: 0
18:47.416	INFO	TestTutorial1	solo/clock.go:44	ClockStep: logical clock advanced by 1ms
18:47.416	INFO	TestTutorial1.ex1	solo/solo.go:240	chain 'ex1' deployed. Chain ID: Qu74LELWVfhFD8QroZoZDicVNWQ1WudWhU7PS9Serkuf
18:47.416	INFO	TestTutorial1.ex1	solo/req.go:172	callView: root::getChainInfo
    tutorial_test.go:21: chainID: Qu74LELWVfhFD8QroZoZDicVNWQ1WudWhU7PS9Serkuf
    tutorial_test.go:22: chain owner ID: A/MRVBJxYjreRDiEaAYNKaoHMS8y4DPZKHHJNxf2fP7zxb
    tutorial_test.go:24:     Core contract 'eventlog': Qu74LELWVfhFD8QroZoZDicVNWQ1WudWhU7PS9Serkuf::661aa7d8
    tutorial_test.go:24:     Core contract 'blob': Qu74LELWVfhFD8QroZoZDicVNWQ1WudWhU7PS9Serkuf::fd91bc63
    tutorial_test.go:24:     Core contract 'root': Qu74LELWVfhFD8QroZoZDicVNWQ1WudWhU7PS9Serkuf::cebf5908
    tutorial_test.go:24:     Core contract 'accounts': Qu74LELWVfhFD8QroZoZDicVNWQ1WudWhU7PS9Serkuf::3c4b5e02
--- PASS: TestTutorial1 (0.01s)
</code></pre>
<p>The 4 core contracts listed in the log (<code>root</code>, <code>accounts</code>, <code>blob</code>, <code>eventlog</code>) 
are automatically deployed on each new chain. You can see them listed in the test log together with their <em>contract IDs</em>.</p>
<p>The output fragment in the log <code>state transition #0 --&gt; #1</code> means the state of the chain has changed from block 
index 0 (the origin index of the empty state) to block index 1. 
The state #0 is the empty origin state, the #1 always contains all core smart contracts deployed on the chain as well as other 
variables of chain, such as <em>chainID</em> and <em>chain owner ID</em>.</p>
<p>The <em>chainID</em> and <em>chain owner ID</em> are respectively ID of the deployed 
chain <code>Ygtcnzs4zHF3Ao9i5FytNT5oYykUvYtuJSSANuxohcoo</code> and the address (in the form of <em>agent ID</em>) 
from which the chain was deployed: <code>A/RxRUJAcHajNX1A3bFBdECxQVkNwELTnPfU7aNboEz9hN</code>
(the prefix <code>A/</code> indicates that the chain owner is an address, not a smart contract).</p>
<p>Next: <a href="node-software/wasp/docs/tutorial/02.html">Tokens and the Value Tangle</a></p>
<h1 id="exploring-iota-smart-contracts-2"><a class="header" href="#exploring-iota-smart-contracts-2">Exploring IOTA Smart Contracts</a></h1>
<p>Previous: <a href="node-software/wasp/docs/tutorial/01.html">Exploring IOTA Smart Contracts</a></p>
<h2 id="tokens-and-the-value-tangle"><a class="header" href="#tokens-and-the-value-tangle">Tokens and the Value Tangle</a></h2>
<p>The Pollen release of the Goshimmer node implements the <em>Value Tangle</em>, 
a distributed ledger of tokens. We won't go into the detail of the Value Tangle. The introduction 
of it can be found <a href="node-software/wasp/docs/tutorial/../intro/utxo.html">here</a>. We only have to know that Value Tangle contains
balances of colored tokens locked in addresses, like this: </p>
<pre><code>Address: Yk85765qdrwheQ4udj6RihxtPxudTSWF9qYe4NsAfp6K
   IOTA: 1000
   Red: 15
   Green: 200
</code></pre>
<p>where <code>IOTA</code> is the color code of IOTA tokens and <code>Red</code> and <code>Green</code> are other color codes 
(<a href="https://github.com/iotaledger/goshimmer/blob/87d0cbb172c1b3432b1dddcbabacd76cad66f1f3/dapps/valuetransfers/packages/balance/color.go#L10">color codes are 32-byte hashes, as defined by Goshimmer</a>). 
Tokens can only be moved on the <em>Value Tangle</em> by the private key of the corresponding address. </p>
<p>(In this tutorial we will use <code>private key</code>, <code>signature scheme</code> and <code>wallet</code> as synonyms).</p>
<p>The <code>Solo</code> environment implements in-memory Value Tangle ledger to the finest details. 
For example, you can only move tokens in the <em>Solo</em> environment by creating and submitting valid and signed transaction. 
You can also create new wallets on the Value Tangle and request iotas from the faucet to your wallet.</p>
<p>The following code shows how to do it:</p>
<pre><code class="language-go">func TestTutorial2(t *testing.T) {
	env := solo.New(t, false, false)
	userWallet := env.NewSignatureSchemeWithFunds() // create new wallet with 1337 iotas
	userAddress := userWallet.Address()
	t.Logf(&quot;Address of the userWallet is: %s&quot;, userAddress)
	numIotas := env.GetAddressBalance(userAddress, balance.ColorIOTA) // how many iotas contains the address
	t.Logf(&quot;balance of the userWallet is: %d iota&quot;, numIotas)
	env.AssertAddressBalance(userAddress, balance.ColorIOTA, 1337) // assert the address has 1337 iotas
}
</code></pre>
<p>The output of the test:</p>
<pre><code>=== RUN   TestTutorial2
    tutorial_test.go:32: Address of the userWallet is: RPfqfAKuBFc5dLMqDtshTbRXPJcuyBYLo9WnqMkf6PaU
    tutorial_test.go:34: balance of the userWallet is: 1337 iota
--- PASS: TestTutorial2 (0.00s)
</code></pre>
<p>The token ledger of the Value Tangle in <em>Solo</em> &quot;lives&quot; in the global environment <code>env</code>
of the test. It is shared among all chains, deployed on that environment. 
It serves as a medium for transactions between smart contracts on different chains. 
The way <em>Solo</em> makes it possible to test transacting between chains.</p>
<p>Note that in the test above we didn’t deploy any chains: the Value Tangle exists 
outside of any chains.</p>
<p>Next: <a href="node-software/wasp/docs/tutorial/03.html">Creating a chain. Core contracts</a></p>
<h1 id="exploring-iota-smart-contracts-3"><a class="header" href="#exploring-iota-smart-contracts-3">Exploring IOTA Smart Contracts</a></h1>
<p>Previous: <a href="node-software/wasp/docs/tutorial/02.html">Tokens and the Value Tangle</a></p>
<h2 id="creating-a-chain-core-contracts"><a class="header" href="#creating-a-chain-core-contracts">Creating a chain. Core contracts</a></h2>
<p>In a test we can deploy one or several chains, deploy smart contracts in it and invoke them. </p>
<p>In the above example <code>TestTutorial1</code>, the statement <code>chain := env.NewChain(nil, &quot;ex1&quot;)</code> 
creates and deploys a new chain <code>ex1</code> in the environment of the test. 
Several chain may be deployed on the test.</p>
<p>Deploying a chain automatically means deployment of all 4 core smart contracts on it.
The core contracts are responsible for the vital functions of the chain and provide infrastructure 
for all other smart contracts:</p>
<ul>
<li>
<p><code>root</code> <a href="node-software/wasp/docs/tutorial/root.html">contract</a>. 
Responsible for the initialization of the chain, maintains the global parameters 
and the registry of deployed contracts.
It also handles fees and performs other functions. </p>
</li>
<li>
<p><code>accounts</code> <a href="node-software/wasp/docs/tutorial/accounts.html">contract</a>. 
Responsible for the on-chain ledger of accounts. 
The on-chain accounts contain colored tokens, which are controlled by smart 
contracts and addresses on the Value Tangle. </p>
</li>
<li>
<p><code>blob</code> <a href="node-software/wasp/docs/tutorial/blob.html">contract</a>. 
Responsible for the immutable registry of binary objects of arbitrary size. 
One blob is a collection of named binary chunks of data. 
For example, a blob can be used to store a collections of <em>wasm</em> binaries, needed to deploy <em>WebAssembly</em> smart contracts. 
Each blob in the registry is referenced by its hash which is deterministically calculated from data. </p>
</li>
<li>
<p><code>eventlog</code> <a href="node-software/wasp/docs/tutorial/eventlog.html">contract</a>. 
Keeps an immutable log of events in the chain. Each event is a message, a string, 
emitted by smart contracts with the <code>Event()</code> sandbox call. 
The events are published over the Wasp node publisher for consumption of outside subscribers. 
Each events is also immutably stored in the <code>eventlog</code> on the chain with the timestamp and id 
of the smart contract which emitted the event. 
Important events such as the deployment of a new smart contract or processing 
of a request are emitted as events by the chain's core. </p>
</li>
</ul>
<h2 id="writing-and-compiling-first-rust-smart-contract"><a class="header" href="#writing-and-compiling-first-rust-smart-contract">Writing and compiling first Rust smart contract</a></h2>
<p>In this section we will create a new smart contract. 
We will write its code in Rust then will use the <code>wasplib</code> <a href="node-software/wasp/docs/tutorial/../../contracts/rust/wasmlib">library</a> and <code>wasm-pack</code> 
to compile it into WebAssembly (<em>wasm</em>) binary. </p>
<p>Note that this tutorial is not a tutorial of the ISCP smart contract development environment: 
for that we will provide other tutorials. 
The only goal of these examples is an introduction to fundamental principles of ISCP smart contracts.</p>
<p>We assume you already have Rust and <code>wasm-pack</code> <a href="https://rustwasm.github.io/wasm-pack/installer/">installed</a>. </p>
<p>We will be using the examples located in the <code>wasp repository</code> at 
<a href="node-software/wasp/docs/tutorial/example-tutorial">articles/tutorial/example-tutorial</a> directory. </p>
<p>The <code>example-tutorial</code> smart contract is a simple smart contract which stores a string in its state upon request and allows to 
retrieve the stored string by calling a view. The smart contract also implements an entry point which allows the creator
of the smart contract instance to withdraw all iotas contained in the smart contract's account on the chain.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use wasmlib::*;

const PARAM_STRING: &amp;str = &quot;paramString&quot;;
const VAR_STRING: &amp;str = &quot;storedString&quot;;

#[no_mangle]
fn on_load() {
    // declare entry points of the smart contract
    let exports = ScExports::new();
    exports.add_call(&quot;storeString&quot;, store_string);
    exports.add_view(&quot;getString&quot;, get_string);
    exports.add_call(&quot;withdrawIota&quot;, withdraw_iota);
}

// storeString entry point stores a string provided as parameters
// in the state as a value of the key 'storedString'
// panics if parameter is not provided
fn store_string(ctx: &amp;ScFuncContext) {
    // take parameter paramString
    let par = ctx.params().get_string(PARAM_STRING);
    // require parameter exists
    ctx.require(par.exists(), &quot;string parameter not found&quot;);

    // store the string in &quot;storedString&quot; variable
    ctx.state().get_string(VAR_STRING).set_value(&amp;par.value());
    // log the text
    let msg = &quot;Message stored: &quot;.to_string() + &amp;par.value();
    ctx.log(&amp;msg);
}

// getString view returns the string value of the key 'storedString'
// The call return result as a key/value dictionary.
// the returned value in the result is under key 'paramString'
fn get_string(ctx: &amp;ScViewContext) {
    // take the stored string
    let s = ctx.state().get_string(VAR_STRING).value();
    // return the string value in the result dictionary
    ctx.results().get_string(PARAM_STRING).set_value(&amp;s);
}

// withdraw_iota sends all iotas contained in the contract's account
// to the caller's L1 address.
// Panics of the caller is not an address
// Panics if the address is not the creator of the contract is the caller
// The caller will be address only if request is sent from the wallet on the L1, not a smart contract
fn withdraw_iota(ctx: &amp;ScFuncContext) {
    let creator = ctx.contract_creator();
    let caller = ctx.caller();

    ctx.require(creator.equals(&amp;caller), &quot;not authorised&quot;);
    ctx.require(caller.is_address(), &quot;caller must be an address&quot;);

    let bal = ctx.balances().balance(&amp;ScColor::IOTA);
    if bal &gt; 0 {
        ctx.transfer_to_address(&amp;caller.address(), &amp;ScTransfers::new(&amp;ScColor::IOTA, bal))
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Running the <code>wasm-pack build</code> command will produce something like this:</p>
<pre><code>[INFO]: Checking for the Wasm target...
[INFO]: Compiling to Wasm...
    Finished release [optimized] target(s) in 0.07s
[INFO]: License key is set in Cargo.toml but no LICENSE file(s) were found; Please add the LICENSE file(s) to your project directory
[INFO]: Installing wasm-bindgen...
[INFO]: Optimizing wasm binaries with `wasm-opt`...
[INFO]: :-) Done in 1.75s
[INFO]: :-) Your wasm pkg is ready to publish at [...]]\github.com\iotaledger\wasplib\rust\contracts\examples\example1\pkg.
</code></pre>
<p>The 30KB file <code>example_tutorial_bg.wasm</code> is the binary of the smart contract. We will be using it in further examples. 
The file contains everything needed to deploy the smart contract on a chain run by the Wasp network.</p>
<p>Next: <a href="node-software/wasp/docs/tutorial/04.html">Deploying and running Rust smart contract</a></p>
<h1 id="exploring-iota-smart-contracts-4"><a class="header" href="#exploring-iota-smart-contracts-4">Exploring IOTA Smart Contracts</a></h1>
<p>Previous: <a href="node-software/wasp/docs/tutorial/03.html"> Creating a chain. Core contracts. Writing and compiling first Rust smart contract</a></p>
<h2 id="deploying-and-running-rust-smart-contract"><a class="header" href="#deploying-and-running-rust-smart-contract">Deploying and running Rust smart contract</a></h2>
<p>The following <em>Solo</em> test deploys <em>wasm</em> contract on the chain.
Then it invokes it: first it posts a request <code>storeString</code> to set the string value,
then it calls the view 'getString' to retrieve the value and checks it.</p>
<pre><code class="language-go">func TestTutorial3(t *testing.T) {
	env := solo.New(t, false, false)
	chain := env.NewChain(nil, &quot;ex3&quot;)
	// deploy the contract on chain
	err := chain.DeployWasmContract(nil, &quot;example1&quot;, &quot;../pkg/example_tutorial_bg.wasm&quot;)
	require.NoError(t, err)

	// call contract to store string
	req := solo.NewCallParams(&quot;example1&quot;, &quot;storeString&quot;, &quot;paramString&quot;, &quot;Hello, world!&quot;)
	_, err = chain.PostRequest(req, nil)
	require.NoError(t, err)

	// call the contract to extract value of the 'paramString' and check
	res, err := chain.CallView(&quot;example1&quot;, &quot;getString&quot;)
	require.NoError(t, err)
	returnedString, exists, err := codec.DecodeString(res.MustGet(&quot;paramString&quot;))
	require.NoError(t, err)
	require.True(t, exists)
	require.EqualValues(t, &quot;Hello, world!&quot;, returnedString)
}
</code></pre>
<p>Running the test will produce the following output:</p>
<pre><code>=== RUN   TestTutorial3
30:13.101	INFO	TestTutorial1	solo/solo.go:160	deploying new chain 'ex3'
30:13.108	INFO	TestTutorial1.ex3	vmcontext/runreq.go:179	eventlog -&gt; '[req] [0]9fx8mFGHNpXToAdR9QyA3vf56Z4kVV7EuvnfPXSJHYAK: Ok'
30:13.109	INFO	TestTutorial1.ex3	solo/run.go:82	state transition #0 --&gt; #1. Requests in the block: 1. Posted: 0
30:13.109	INFO	TestTutorial1	solo/clock.go:44	ClockStep: logical clock advanced by 1ms
30:13.109	INFO	TestTutorial1.ex3	solo/solo.go:240	chain 'ex3' deployed. Chain ID: SYDRcNaotG6sHYFxAN7px6qvkjwiyLyekHHPjGJMkueT
30:13.113	INFO	TestTutorial1.ex3	solo/req.go:172	callView: blob::getBlobInfo
30:13.114	INFO	TestTutorial1.registry.registry	registry/blobcache.go:43	data blob has been stored. size: 30293 bytes, hash: EUZHCU4fEXT7obcMVj5EjMsrCyyRC4ZaWK6LkyFNL1UN
30:13.114	INFO	TestTutorial1	solo/solo.go:382	Solo::PutBlobDataIntoRegistry: len = 30293, hash = EUZHCU4fEXT7obcMVj5EjMsrCyyRC4ZaWK6LkyFNL1UN
30:13.114	INFO	TestTutorial1.ex3	solo/req.go:172	callView: root::getFeeInfo
30:13.114	INFO	TestTutorial1.ex3	solo/req.go:147	PostRequest: blob::storeBlob -- [0]Gq8zyjz3rj9keZf3LvNjkWscGRVBhV1U1enJwYv7Jsig
30:13.115	INFO	TestTutorial1.ex3	vmcontext/log.go:4	eventlog::fd91bc63 -&gt; '[blob] hash: B7urmUQfoovMwJ8Vu82w1hVFjLX62iqMTFFYwYAYkAHe, field sizes: [30293 10]'
30:13.115	INFO	TestTutorial1.ex3	vm/event.go:24	SYDRcNaotG6sHYFxAN7px6qvkjwiyLyekHHPjGJMkueT::fd91bc63/event [blob] hash: B7urmUQfoovMwJ8Vu82w1hVFjLX62iqMTFFYwYAYkAHe, field sizes: [30293 10]
30:13.115	INFO	TestTutorial1.ex3	vmcontext/runreq.go:179	eventlog -&gt; '[req] [0]Gq8zyjz3rj9keZf3LvNjkWscGRVBhV1U1enJwYv7Jsig: Ok'
30:13.118	INFO	TestTutorial1.ex3	solo/run.go:82	state transition #1 --&gt; #2. Requests in the block: 1. Posted: 0
30:13.118	INFO	TestTutorial1	solo/clock.go:44	ClockStep: logical clock advanced by 1ms
30:13.119	INFO	TestTutorial1.ex3	solo/req.go:147	PostRequest: root::deployContract -- [0]CAkqvTb7S9H8VP5T8aHrcTCQuin2VzmNj8M2BaZqFD8S
30:13.219	INFO	TestTutorial1.ex3	vmcontext/log.go:4	eventlog::cebf5908 -&gt; '[deploy] name: example1 hname: ffb07aeb, progHash: B7urmUQfoovMwJ8Vu82w1hVFjLX62iqMTFFYwYAYkAHe, dscr: 'N/A''
30:13.219	INFO	TestTutorial1.ex3	vm/event.go:24	SYDRcNaotG6sHYFxAN7px6qvkjwiyLyekHHPjGJMkueT::cebf5908/event [deploy] name: example1 hname: ffb07aeb, progHash: B7urmUQfoovMwJ8Vu82w1hVFjLX62iqMTFFYwYAYkAHe, dscr: 'N/A'
30:13.219	INFO	TestTutorial1.ex3	vmcontext/runreq.go:179	eventlog -&gt; '[req] [0]CAkqvTb7S9H8VP5T8aHrcTCQuin2VzmNj8M2BaZqFD8S: Ok'
30:13.221	INFO	TestTutorial1.ex3	solo/run.go:82	state transition #2 --&gt; #3. Requests in the block: 1. Posted: 0
30:13.222	INFO	TestTutorial1	solo/clock.go:44	ClockStep: logical clock advanced by 1ms
30:13.223	INFO	TestTutorial1.ex3	solo/req.go:147	PostRequest: example1::storeString -- [0]DAE2wTgPP36jeQk6EWCqpHhenZzEbjiZRgkSXcEVK5ak
30:13.227	INFO	TestTutorial1.ex3	vmcontext/log.go:4	Message stored: Hello, world!
30:13.228	INFO	TestTutorial1.ex3	vmcontext/runreq.go:179	eventlog -&gt; '[req] [0]DAE2wTgPP36jeQk6EWCqpHhenZzEbjiZRgkSXcEVK5ak: Ok'
30:13.229	INFO	TestTutorial1.ex3	solo/run.go:82	state transition #3 --&gt; #4. Requests in the block: 1. Posted: 0
30:13.229	INFO	TestTutorial1	solo/clock.go:44	ClockStep: logical clock advanced by 1ms
30:13.229	INFO	TestTutorial1.ex3	solo/req.go:172	callView: example1::getString
--- PASS: TestTutorial3 (0.13s)
</code></pre>
<p>The final state of the chain is <code>#4</code>. The chain changes its state in response to the requests.</p>
<p><code>state transition #0 --&gt; #1</code> settles initial state of the chain (see <a href="node-software/wasp/docs/tutorial/01.html">First example</a>).</p>
<p>The <code>state transition #1 --&gt; #2</code> and <code>state transition #2 --&gt; #3</code> are result of the <code>Solo</code> 
call <code>err := chain.DeployWasmContract(nil, &quot;example1&quot;, &quot;../pkg/example_tutorial_bg.wasm&quot;)</code>:</p>
<ul>
<li>First state transition corresponds to the storing the <em>wasm</em> binary file as a binary object into the chain.</li>
<li>Second is the deployment of the smart contract based on this binary object (which is already on the chain).</li>
</ul>
<p>The <code>state transition #3 --&gt; #4</code> corresponds to sending the string <code>Hello, world!</code> by posting a <code>storeString</code> request to 
the newly deployed smart contract.</p>
<p>The test then calls the view <code>getString</code> of the smart contract and asserts the returned string is <code>Hello, world!</code>.
Note that calling the view state transition doesn't occur.</p>
<p>Next: <a href="node-software/wasp/docs/tutorial/05.html">Structure of the smart contract</a></p>
<h1 id="exploring-iota-smart-contracts-5"><a class="header" href="#exploring-iota-smart-contracts-5">Exploring IOTA Smart Contracts</a></h1>
<p>Previous: <a href="node-software/wasp/docs/tutorial/04.html">Deploying and running Rust smart contract</a></p>
<h2 id="structure-of-the-smart-contract"><a class="header" href="#structure-of-the-smart-contract">Structure of the smart contract</a></h2>
<p>Smart contracts are programs immutably stored in the chain. 
In the example above the binary file with the code of the smart contract with binary <em>example_tutorial_bg.wasm</em> will 
be immutably stored in the chain state.</p>
<p>The logical structure of an ISCP smart contract is independent of the VM type we use, 
be it a <em>Wasm</em> smart contract or any other. </p>
<p><img src="node-software/wasp/docs/tutorial/SC-structure.png" alt="" /></p>
<p>Each smart contract on the chain is identified by its name hashed into 4 bytes and interpreted as <code>uint32</code> value: 
the so called <code>hname</code>. For example, the <code>hname</code> of the root contract is <em>0xcebf5908</em>, the 
unique identifier of the <code>root</code> contract in every chain.</p>
<p>Each smart contract instance has a program with a collection of entry points and a state. 
An entry point is a function of the program through which the program can be invoked. 
The <code>example1</code> contract above has three entry points: <code>storeString</code>, <code>getString</code> and <code>withdrawIota</code>.</p>
<p>There are several ways to invoke an entry point: a request, a call and a view call, 
depending on the type of the entry point.</p>
<p>The smart contract program can access its state and account through an interface layer called the <em>Sandbox</em>. </p>
<h3 id="state"><a class="header" href="#state">State</a></h3>
<p>The smart contract state is its data, with each update stored on the chain. 
The state can only be modified by the smart contract program itself. There are two parts of the state:</p>
<ul>
<li>A collection of key/value pairs called the <code>data state</code>. 
Each key and value are byte arrays of arbitrary size (there are practical limits set by the database, of course). 
The value of the key/value pair is always retrieved by its key.</li>
<li>A collection of <code>color: balance</code> pairs called the <code>account</code>. The account represents the balances of tokens 
of specific colors controlled by the smart contract. 
Receiving and spending tokens into/from the account means changing the account's balances.</li>
</ul>
<p>Only the smart contract program can change its data state and spend from its account. 
Tokens can be sent to the smart contract account by any other agent on the ledger, 
be it a wallet with an address or another smart contract. </p>
<p>See <a href="node-software/wasp/docs/tutorial/accounts.html">Accounts</a> for more info on sending and receiving tokens.</p>
<h3 id="entry-points"><a class="header" href="#entry-points">Entry points</a></h3>
<p>There are two types of entry points:</p>
<ul>
<li><em>Full entry points</em> or just <em>entry points</em>. These functions can modify (mutate) the state of the smart contract.</li>
<li><em>View entry points</em> or <em>views</em>. These are read-only functions. 
They are used only to retrieve the information from the smart contract state. 
They can’t modify the state, i.e. are read-only calls.</li>
</ul>
<p>The <code>example1</code> program has three entry points: </p>
<ul>
<li>
<p><code>storeString</code> a full entry point. 
It first checks if parameter called <code>paramString</code> exist. 
If so, it stores the string value of the parameter into the state variable <code>storedString</code>.
If parameter <code>paramString</code> is missing, the program panics. </p>
</li>
<li>
<p><code>getCounter</code> is a view entry point that returns the value of the variable <code>storedString</code>.</p>
</li>
<li>
<p><code>withdrawIota</code> full entry point checks if the caller is and address and if the caller is equal to 
the creator of smart contract. If not, it panics. If it passes the validation, the program sends all of iotas
contained in the account to the caller.</p>
</li>
</ul>
<p>Note that in <code>example1</code> the Rust function associated with the full entry point takes parameters of type <code>ScFuncContext</code>.
It gives full (read-write) access to the state. 
In contrast, <code>getCounter</code> is a view entry point and its associated function has type <code>ScViewContext</code>. 
The view is not allowed to mutate the state.</p>
<h2 id="panic-exception-handling"><a class="header" href="#panic-exception-handling">Panic. Exception handling</a></h2>
<p>The following test posts a request to <code>example1</code> smart contract without expected parameter <code>paramString</code>.
The statement <code>ctx.require(par.exists(), &quot;string parameter not found&quot;);</code> makes 
smart contract panic if the condition is not satisfied.</p>
<pre><code class="language-go">func TestTutorial4(t *testing.T) {
	env := solo.New(t, false, false)
	chain := env.NewChain(nil, &quot;ex4&quot;)
	// deploy the contract on chain
	err := chain.DeployWasmContract(nil, &quot;example1&quot;, &quot;../pkg/example_tutorial_bg.wasm&quot;)
	require.NoError(t, err)

	// call contract incorrectly
	req := solo.NewCallParams(&quot;example1&quot;, &quot;storeString&quot;)
	_, err = chain.PostRequest(req, nil)
	require.Error(t, err)
}
</code></pre>
<p>The fragment in the output of the test:</p>
<pre><code>30:13.315	PANIC	TestTutorial1.ex4	vmcontext/log.go:12	string parameter not found
30:13.319	ERROR	TestTutorial1.ex4	vmcontext/runreq.go:172	recovered from panic in VM: string parameter not found
30:13.319	INFO	TestTutorial1.ex4	vmcontext/runreq.go:179	eventlog -&gt; '[req] [0]4ert8Wkqf8vVY8Px9QEXABFewh2zgi2ksFeiL4X8xCWm: recovered from panic in VM: string parameter not found'
30:13.322	INFO	TestTutorial1.ex4	solo/run.go:82	state transition #3 --&gt; #4. Requests in the block: 1. Posted: 0
</code></pre>
<p>It shows the panic occured indeed. The test passes because error was expected.</p>
<p>Note that this test ends with the state <code>#4</code>, despite the fact that last request to the smart contract failed.
This is important: <strong>whatever happens during the run of the smart contract's entry point, 
processing of each request always results in the state transition</strong>. </p>
<p>The VM context catches exceptions (panics) in the program. 
Consequences of it are recorded in the state of the chain during the fallback processing, no matter if the panics
was called by the logic of the smart contract or another runtime error occured. </p>
<p>In the case of <code>example1</code> the error event was recorded in the immutable event log of the chain, 
but the data state of the smart contract wasn't modified.<br />
In other cases the fallback actions may be more complex.</p>
<p>Next: <a href="node-software/wasp/docs/tutorial/06.html">Invoking smart contract. Sending a request</a></p>
<h1 id="exploring-iota-smart-contracts-6"><a class="header" href="#exploring-iota-smart-contracts-6">Exploring IOTA Smart Contracts</a></h1>
<p>Previous: <a href="node-software/wasp/docs/tutorial/05.html#panic-exception-handling">Deploying and running Rust smart contract</a></p>
<p>(see also <a href="node-software/wasp/docs/tutorial/invoking.html">General scheme of invoking the entry point</a>)</p>
<h2 id="invoking-smart-contract-sending-a-request"><a class="header" href="#invoking-smart-contract-sending-a-request">Invoking smart contract. Sending a request</a></h2>
<p>The statements</p>
<pre><code>	req := solo.NewCallParams(&quot;example1&quot;, &quot;storeString&quot;, &quot;paramString&quot;, &quot;Hello, world!&quot;)
	_, err = chain.PostRequest(req, nil)
</code></pre>
<p>In the above example <code>TestTutorial3</code> invokes the <code>storeString</code> entry point of the <code>example1</code> smart contract 
by posting a request to it. It passes the parameter named <code>paramString</code> with the string value &quot;Hello, world!&quot;.
The <em>Solo</em> test itself is outside of the chain where smart contract is invoked, not &quot;on-chain&quot;.</p>
<p><code>NewCallParams</code> creates a call object <code>req</code> which wraps all call parameters into a single object. This is syntactic sugar 
just for convenience. In this case the call object only wraps target smart contract name, target entry point's name 
together with one named parameter <code>paramString</code>. In other cases it could contain many parameters and transferred tokens. </p>
<p><code>PostRequest</code> sends the request to the chain. Let’s describe in detail what is going on here.</p>
<p><img src="node-software/wasp/docs/tutorial/send_request.png" alt="" /></p>
<p>The diagram above depicts the generic process of posting a request to the smart contract. 
The same picture is valid for the <em>Solo</em> environment and for any other requester which sends a request to 
the smart contract, for example ISCP wallet or another chain.</p>
<p>Posting the request always consists of steps below. 
Note that in Solo all 7 steps are carried out by the single call to <code>PostRequest</code>.</p>
<ol>
<li>Creating the smart contract transaction which wraps the request with 
metadata and moves tokens. Each request transaction is a value transaction, it always moves at least one token. 
Therefore, each request transaction must be signed by the private key of the owner of the tokens: 
the requester. It makes each requester securely identified in ISCP. 
In Solo the transaction is signed by the private key provided in the second parameter of the 
<code>PostRequest</code> call (see below);</li>
<li>Posting the request transaction to the Tangle and confirming it. 
In <em>Solo</em> it is just adding the transaction to the <code>UTXODB ledger</code>, the emulated Value Tangle, 
so it is confirmed immediately and synchronously. 
The confirmed transaction on the ledger becomes part of the backlog of requests to the chain. 
In the real Value Tangle the sender would have to wait until the ledger confirms the transaction;</li>
<li>The chain picks the request from the backlog and runs the request on the VM;</li>
<li>The VM calls the target entry point of the smart contract program. The program updates the state;</li>
<li>The VM produces a state update transaction (anchor); </li>
<li>Chain signs the transaction with the private key. In the <em>Solo</em> environment it is <code>ChainSigScheme</code> property of the chain.<br />
In the real Wasp environment it is the threshold signature of the committee;</li>
<li>The chain posts the resulting transaction to the Tangle and confirms it. 
In the <em>Solo</em> environment it adds it to the UTXODB ledger. </li>
</ol>
<p>The following lines in the log corresponds to the step 7:</p>
<pre><code>30:13.219	INFO	TestTutorial1.ex3	vmcontext/runreq.go:179	eventlog -&gt; '[req] [0]CAkqvTb7S9H8VP5T8aHrcTCQuin2VzmNj8M2BaZqFD8S: Ok'
30:13.221	INFO	TestTutorial1.ex3	solo/run.go:82	state transition #2 --&gt; #3. Requests in the block: 1. Posted: 0
</code></pre>
<p>the chain adds record about successfully processed request <code>[0]3U4weXHjSRzAi57hXCDp2X3ej7t8ZRtkVAWkAn2XTZLe</code> 
to the immutable on-chain log.</p>
<p>The statement <code>_, err = chain.PostRequest(req, nil)</code> 
in the Solo test uses <code>nil</code> for the default signature scheme of the requester. 
The <code>OriginatorSigScheme</code>, the one which deployed the chain, is used as the default requester. 
In the <em>Solo</em> environment you can create other identities of requesters (“wallets”) with <code>NewSignatureSchemeWithFunds</code>.</p>
<p>Next: <a href="node-software/wasp/docs/tutorial/07.html">Invoking smart contract. Calling a view</a></p>
<h1 id="exploring-iota-smart-contracts-7"><a class="header" href="#exploring-iota-smart-contracts-7">Exploring IOTA Smart Contracts</a></h1>
<p>Previous: <a href="node-software/wasp/docs/tutorial/06.html">Invoking smart contract. Sending a request</a></p>
<h2 id="calling-a-view-from-the-solo-environment"><a class="header" href="#calling-a-view-from-the-solo-environment">Calling a view from the Solo environment</a></h2>
<p>The statement in the above example calls a view entry point <code>getString</code> of the smart contract <code>example1</code> without parameters:</p>
<pre><code>res, err := chain.CallView(&quot;example1&quot;, &quot;getString&quot;)
</code></pre>
<p>The call returns a result res, a collection of key/value pairs and error (if not <code>nil</code>).</p>
<p><img src="node-software/wasp/docs/tutorial/call_view.png" alt="" /></p>
<p>The basic principle of calling a view is similar to the sending a request to the smart contract. 
The essential difference is that calling a view is not a transaction but just a synchronous call 
to the view entry point function, exposed by the smart contract.</p>
<p>Naturally, calling a view doesn't involve any token transfer. 
Sending a request (a transaction) to a view entry point will result in an exception. It will return 
all attached tokens back to the sender (minus fees, if any).</p>
<p>Views are used to retrieve information about the state of the smart contract, 
for example to display it on a website. Certain <em>Solo</em> methods such as <code>chain.GetInfo</code>, 
<code>chain.GetFeeInfo</code> and <code>chain.GetTotalAssets</code> call views of the core smart contracts behind scenes 
to retrieve the information about the chain or a specific smart contract.</p>
<h3 id="decoding-results-returned-by-postrequest-and-callview"><a class="header" href="#decoding-results-returned-by-postrequest-and-callview">Decoding results returned by <em>PostRequest</em> and <em>CallView</em></a></h3>
<p>The following is the technicality of the Go environment of <em>Solo</em>.</p>
<p>The result returned by the call to the entry point from the <em>Solo</em> environment is in the form of key/value pairs, 
the <code>dict.Dict</code> type. 
It is an extended interface and alias of the <code>map[string][]byte</code>. 
The <a href="https://github.com/iotaledger/wasp/blob/master/packages/kv/dict/dict.go">dict.Dict</a> package implements 
<code>kv.KVStore</code> interface and provides a lot of useful functions to handle this form of key/value storage.</p>
<p>In normal operation of smart contracts one can only retrieve results returned by view calls, 
since view calls are synchronous. 
On the other hand, sending a request to a smart contract is an asynchronous operation, and 
the caller cannot retrieve the result. 
However, in the <em>Solo</em> environment, the call to <code>PostRequest</code> is synchronous, and the caller can inspect 
the result: this is a convenient difference between the mocked <em>Solo</em> environment and a 
distributed Value Tangle ledger used by Wasp nodes. 
It can be used to make assertions on the result of the call in the test.</p>
<p>The example <code>res</code> is a dictionary where keys and values are binary slices. The statement</p>
<pre><code>counter, exists, err := codec.DecodeInt64(res.MustGet(&quot;counter&quot;)) 
</code></pre>
<p>takes the value of the key <code>counter</code> from the key value store and attempts to decode it as <code>int64</code>.
The decoding returns a possible error value, existence flag and the value itself.</p>
<p>Next: <a href="node-software/wasp/docs/tutorial/08.html">Sending and receiving tokens with the address</a> </p>
<h1 id="exploring-iota-smart-contracts-8"><a class="header" href="#exploring-iota-smart-contracts-8">Exploring IOTA Smart Contracts</a></h1>
<p>Previous: <a href="node-software/wasp/docs/tutorial/07.html">Calling a view from the Solo environment</a></p>
<p>For general description of ISCP account system see <a href="node-software/wasp/docs/tutorial/iscp_accounts.html">ISCP accounts. Controlling token balances</a>.</p>
<h2 id="sending-and-receiving-tokens-with-the-address"><a class="header" href="#sending-and-receiving-tokens-with-the-address">Sending and receiving tokens with the address</a></h2>
<p>Multiple chains in ISCP adds another dimension to the ledger: smart contract can exchange assets between themselves
on different chains as well as with addresses on the Value Tangle, the <code>L1</code>. 
We will skip explaining the whole picture for time being and will concentrate on one specific use case.</p>
<p>Let's say we are a wallet, we have private key (the address) and some tokens on it. 
The use case is about sending tokens to and receiving from a smart contract on a chain.</p>
<p>Here we explore the concept of <code>on-chain account</code> or just <code>account</code>. 
On the Value Tangle ledger the private key is represented by the address (the hash of the public key). 
That address holds balances of colored tokens. Those tokens are &quot;controlled&quot; by the private key.</p>
<p>In ISCP we extend the concept of <em>address</em> with the concept of <code>account</code>. <code>account</code> contains colored tokens just like 
and <code>address</code>.
The <code>account</code> is located on some chain and it is controlled by the same private key (an address). 
So, address can control token on the Value Tangle (<code>L1</code>) and on each of chains (<code>L2</code>).</p>
<p>The chain essentially is a custodian of the tokens deposited on it's <code>accounts</code>.</p>
<p>The following test demonstrates how a wallet can deposit tokens on chain account and then withdraw it back.</p>
<pre><code class="language-go">func TestTutorial5(t *testing.T) {
	env := solo.New(t, false, false)
	chain := env.NewChain(nil, &quot;ex5&quot;)

	// create wallet with 1337 iotas.
	// wallet has address and it is globally identified through
	// universal identifier: the agent ID
	userWallet := env.NewSignatureSchemeWithFunds()
	userAddress := userWallet.Address()
	userAgentID := coretypes.NewAgentIDFromAddress(userAddress)

	env.AssertAddressBalance(userAddress, balance.ColorIOTA, 1337) // 1337 on address
	chain.AssertAccountBalance(userAgentID, balance.ColorIOTA, 0)  // empty on-chain

	t.Logf(&quot;Address of the userWallet is: %s&quot;, userAddress)
	numIotas := env.GetAddressBalance(userAddress, balance.ColorIOTA)
	t.Logf(&quot;balance of the userWallet is: %d iota&quot;, numIotas)
	env.AssertAddressBalance(userAddress, balance.ColorIOTA, 1337)

	// send 42 iotas from wallet to own account on-chain, controlled by the same wallet
	req := solo.NewCallParams(accounts.Name, accounts.FuncDeposit).
		WithTransfer(balance.ColorIOTA, 42)
	_, err := chain.PostRequest(req, userWallet)
	require.NoError(t, err)

	// check address balance: must be 43 (!) iotas less
	env.AssertAddressBalance(userAddress, balance.ColorIOTA, 1337-43)
	// check the on-chain account. Must contain 43 (!) iotas
	chain.AssertAccountBalance(userAgentID, balance.ColorIOTA, 43)

	// withdraw back all iotas
	req = solo.NewCallParams(accounts.Name, accounts.FuncWithdrawToAddress)
	_, err = chain.PostRequest(req, userWallet)
	require.NoError(t, err)

	// we are back to initial situation: IOTA is fee-less!
	env.AssertAddressBalance(userAddress, balance.ColorIOTA, 1337)
	chain.AssertAccountBalance(userAgentID, balance.ColorIOTA, 0) // empty
}
</code></pre>
<p>The example above creates a chain, then creates a wallet with 1337 iotas and sends (deposits) 42 iotas
to the corresponding on-chain account by posting a <code>deposit</code> request to the <code>accounts</code> core contract on that chain. 
That account will contain 43 iotas (1 iota more for technical reasons which 
we skip here). The address on the Value Tangle will contain 43 iotas less, of course.</p>
<p>In the next step the same wallet (<code>userWallet</code>) will withdraw all 43 iotas back to the address by sending <code>withdraw</code>
request to the <code>accounts</code> contract on the same chain. </p>
<p>If the same request would be posted from another user wallet (another private key), the <code>withdraw</code> request would fail.
Try it! Only owner of the address can move those funds from the on-chain account.</p>
<p>Next: <a href="node-software/wasp/docs/tutorial/09.html">Sending tokens to the smart contract</a></p>
<h1 id="exploring-iota-smart-contracts-9"><a class="header" href="#exploring-iota-smart-contracts-9">Exploring IOTA Smart Contracts</a></h1>
<p>Previous: <a href="node-software/wasp/docs/tutorial/08.html">Sending and receiving tokens with address</a></p>
<h2 id="sending-tokens-to-the-smart-contract"><a class="header" href="#sending-tokens-to-the-smart-contract">Sending tokens to the smart contract</a></h2>
<p>Let's send some tokens to the smart contract. The following example deploys familiar <code>example1</code> 
Rust/Wasm smart contract on the chain and sends 42 iota to it.</p>
<pre><code class="language-go">func TestTutorial6(t *testing.T) {
	env := solo.New(t, false, false)
	chain := env.NewChain(nil, &quot;ex6&quot;)

	err := chain.DeployWasmContract(nil, &quot;example1&quot;, &quot;../pkg/example_tutorial_bg.wasm&quot;)
	require.NoError(t, err)

	// global ID of the deployed contract
	contractID := coretypes.NewContractID(chain.ChainID, coretypes.Hn(&quot;example1&quot;))
	// contract id in the form of the agent ID
	contractAgentID := coretypes.NewAgentIDFromContractID(contractID)

	userWallet := env.NewSignatureSchemeWithFunds()
	userAddress := userWallet.Address()
	userAgentID := coretypes.NewAgentIDFromAddress(userWallet.Address())

	env.AssertAddressBalance(userAddress, balance.ColorIOTA, 1337)
	chain.AssertAccountBalance(contractAgentID, balance.ColorIOTA, 0) // empty on-chain
	chain.AssertAccountBalance(userAgentID, balance.ColorIOTA, 0)     // empty on-chain

	req := solo.NewCallParams(&quot;example1&quot;, &quot;storeString&quot;, &quot;paramString&quot;, &quot;Hello, world!&quot;).
		WithTransfer(balance.ColorIOTA, 42)
	_, err = chain.PostRequest(req, userWallet)
	require.NoError(t, err)

	chain.AssertAccountBalance(contractAgentID, balance.ColorIOTA, 42)
	chain.AssertAccountBalance(userAgentID, balance.ColorIOTA, 1)
	env.AssertAddressBalance(userAddress, balance.ColorIOTA, 1337-43)
}
</code></pre>
<p>The statement</p>
<pre><code>	req := solo.NewCallParams(&quot;example1&quot;, &quot;storeString&quot;, &quot;paramString&quot;, &quot;Hello, world!&quot;).WithTransfer(balance.ColorIOTA, 42)
</code></pre>
<p>attaches 42 iotas to the usual call to <code>storeString</code> entry point. 
<code>PostRequest</code> sends a request with all iotas to the smart contract. 
The 42 iotas appear in the account controlled by the smart contract on its chain.
<code>userAgent</code> has 1 iota controlled by it on the chain (for a reason we skip here). </p>
<p>So, what <code>example1</code> smart contract does with these 42 iotas? Nothing! However, the creator (and nobody else) 
of the smart contract may withdraw those iotas to it's own address by sending a request <code>withdrawIotas</code>.</p>
<p>What if we send some other colored tokens, not iotas to the <code>example1</code> smart contract? 
They will be effectively lost, because programmer of the <code>example1</code> smart contract didn't implement methods 
to deal with colored tokens. </p>
<p>Next: <a href="node-software/wasp/docs/tutorial/10.html">Return of tokens in case of failure</a></p>
<h1 id="exploring-iota-smart-contracts-10"><a class="header" href="#exploring-iota-smart-contracts-10">Exploring IOTA Smart Contracts</a></h1>
<p>Previous: <a href="node-software/wasp/docs/tutorial/09.html">Sending atokens to the smart contract</a></p>
<h2 id="return-of-tokens-in-case-of-failure"><a class="header" href="#return-of-tokens-in-case-of-failure">Return of tokens in case of failure</a></h2>
<p>Natural question: what if I attach tokens to the request, send it to the smart contract and smart contract fails (panics)?
The panics may occur for whatever reason: it may be due to wrong parameters or it may be a runtime error, a bug. 
What will happen with my tokens?</p>
<p>The following test demonstrates the situation when the request results in the panic in the smart contract.</p>
<pre><code class="language-go">func TestTutorial7(t *testing.T) {
	env := solo.New(t, false, false)
	chain := env.NewChain(nil, &quot;ex7&quot;)

	err := chain.DeployWasmContract(nil, &quot;example1&quot;, &quot;../pkg/example_tutorial_bg.wasm&quot;)
	require.NoError(t, err)

	// global ID of the deployed contract
	contractID := coretypes.NewContractID(chain.ChainID, coretypes.Hn(&quot;example1&quot;))
	// contract id in the form of the agent ID
	contractAgentID := coretypes.NewAgentIDFromContractID(contractID)

	userWallet := env.NewSignatureSchemeWithFunds()
	userAddress := userWallet.Address()
	userAgentID := coretypes.NewAgentIDFromAddress(userWallet.Address())

	env.AssertAddressBalance(userAddress, balance.ColorIOTA, 1337)
	chain.AssertAccountBalance(contractAgentID, balance.ColorIOTA, 0) // empty on-chain
	chain.AssertAccountBalance(userAgentID, balance.ColorIOTA, 0)     // empty on-chain

	// missing parameter, will panic
	req := solo.NewCallParams(&quot;example1&quot;, &quot;storeString&quot;).
		WithTransfer(balance.ColorIOTA, 42)
	_, err = chain.PostRequest(req, userWallet)
	require.Error(t, err)

	chain.AssertAccountBalance(contractAgentID, balance.ColorIOTA, 0)
	chain.AssertAccountBalance(userAgentID, balance.ColorIOTA, 1)
	env.AssertAddressBalance(userAddress, balance.ColorIOTA, 1337-1)
}
</code></pre>
<p>The programmer forgets the parameter <code>paramString</code> and the program panics:</p>
<pre><code>30:13.501	PANIC	TestTutorial1.ex7	vmcontext/log.go:12	string parameter not found
30:13.501	ERROR	TestTutorial1.ex7	vmcontext/runreq.go:172	recovered from panic in VM: string parameter not found
30:13.501	INFO	TestTutorial1.ex7	vmcontext/runreq.go:179	eventlog -&gt; '[req] [0]Ge4WLPVN7dGfW7uViwDLYQh8FVpvWsZG2GkYKYdtezA8: recovered from panic in VM: string parameter not found'
30:13.508	INFO	TestTutorial1.ex7	solo/run.go:82	state transition #3 --&gt; #4. Requests in the block: 1. Posted: 0
</code></pre>
<p>We can see that all sent 42 tokens are returned to the sender's address. The 1 iota token is accrued 
to the sender (<code>userWallet</code>) on the chain. </p>
<p>In case of panic for whatever reason, the fallback logic of the VM context of ISCP returns all 
tokens (less fees) to the sender's location (to the sender's address the example above). </p>
<p>Next: <a href="node-software/wasp/docs/tutorial/11.html">Sending iotas from smart contract to address</a> </p>
<h1 id="exploring-iota-smart-contracts-11"><a class="header" href="#exploring-iota-smart-contracts-11">Exploring IOTA Smart Contracts</a></h1>
<p>Previous: <a href="node-software/wasp/docs/tutorial/10.html">Return of tokens in case of failure</a> </p>
<h2 id="sending-iotas-from-smart-contract-to-address"><a class="header" href="#sending-iotas-from-smart-contract-to-address">Sending iotas from smart contract to address</a></h2>
<p>The programmer of the <code>example</code> smart contract implemented entry point <code>withdrawIota</code>. What it is for?
If not this method, any tokens sent to the smart contract will be essentially lost: there's no other 
way to withdraw tokens back to address. </p>
<p>The entry point require from the caller to be an address and to be equal to <code>creator</code> of the instance of the 
contract. The <code>creator</code> (its <code>agentID</code>) is always contained in the registry of contracts. If conditions
are not satisfied, the call panics.</p>
<p>If condition satisfied, the contract calls the <code>transfer_to_address</code> sandbox function to send all iotas, owned by the
contract to the caller, the address.</p>
<p>What if we send some other colored tokens, not ordinary iotas, to the smart contract? Those will stay there 
forever, because in this contract we can only withdraw iotas.</p>
<p>The following <em>Solo</em> test demonstrates how it works:</p>
<pre><code class="language-go">func TestTutorial8(t *testing.T) {
	// create solo environment
	env := solo.New(t, false, false)
	// deploy new chain
	chain := env.NewChain(nil, &quot;ex8&quot;)

	// create a user's wallet (private key) and request 1337 iotas from the faucet.
	// It corresponds to L1 address
	userWallet := env.NewSignatureSchemeWithFunds()
	userAddress := userWallet.Address()
	userAgentID := coretypes.NewAgentIDFromAddress(userWallet.Address())
	t.Logf(&quot;userAgentID: %s&quot;, userAgentID)

	env.AssertAddressBalance(userAddress, balance.ColorIOTA, 1337)
	chain.AssertAccountBalance(userAgentID, balance.ColorIOTA, 0) // empty on-chain

	// the chain owner (default) send a request to the root contract to grant right to deploy
	// contract on the chain to the use
	req := solo.NewCallParams(root.Interface.Name, root.FuncGrantDeploy, root.ParamDeployer, userAgentID)
	_, err := chain.PostRequest(req, nil)
	require.NoError(t, err)

	// user deploys wasm smart contract on the chain under the name &quot;example1&quot;
	// the wasm binary is in the file
	err = chain.DeployWasmContract(userWallet, &quot;example1&quot;, &quot;../pkg/example_tutorial_bg.wasm&quot;)
	require.NoError(t, err)

	// global ID of the deployed contract
	contractID := coretypes.NewContractID(chain.ChainID, coretypes.Hn(&quot;example1&quot;))
	// contract id in the form of the agent ID
	contractAgentID := coretypes.NewAgentIDFromContractID(contractID)

	// the deployment of the smart contract required 1 requests to the root contract:
	// - to submit binary to the on-chain &quot;blob&quot; registry
	// - to deploy contract from the blob
	// Two tokens were taken from the user account to form requests and then were
	// deposited to the user's account on the chain
	env.AssertAddressBalance(userAddress, balance.ColorIOTA, 1337-2)
	chain.AssertAccountBalance(contractAgentID, balance.ColorIOTA, 0) // empty on-chain
	chain.AssertAccountBalance(userAgentID, balance.ColorIOTA, 2)

	// user send a &quot;storeString&quot; request to the smart contract. It attaches 42 iotas to the request
	// It also takes 1 iota for the request token
	// Result is 42 iotas moved to the smart contract's account
	req = solo.NewCallParams(&quot;example1&quot;, &quot;storeString&quot;, &quot;paramString&quot;, &quot;Hello, world!&quot;).
		WithTransfer(balance.ColorIOTA, 42)
	_, err = chain.PostRequest(req, userWallet)
	require.NoError(t, err)

	chain.AssertAccountBalance(contractAgentID, balance.ColorIOTA, 42)
	chain.AssertAccountBalance(userAgentID, balance.ColorIOTA, 3)
	env.AssertAddressBalance(userAddress, balance.ColorIOTA, 1337-45)

	// user withdraws all iotas from the smart contract back
	// Out of 42 iotas 41 iota is coming back to the user's address, 1 iotas
	// is accrued to the user on chain
	req = solo.NewCallParams(&quot;example1&quot;, &quot;withdrawIota&quot;)
	_, err = chain.PostRequest(req, userWallet)
	require.NoError(t, err)

	chain.AssertAccountBalance(contractAgentID, balance.ColorIOTA, 0)
	chain.AssertAccountBalance(userAgentID, balance.ColorIOTA, 3+1)
	env.AssertAddressBalance(userAddress, balance.ColorIOTA, 1337-45+41)
}
</code></pre>
<p>Next: <a href="node-software/wasp/docs/tutorial/iscp_accounts.html">ISCP accounts. Controlling token balances</a> </p>
<h1 id="setup-a-private-iscp-cluster"><a class="header" href="#setup-a-private-iscp-cluster">Setup a private ISCP Cluster</a></h1>
<h1 id="wasp-cluster"><a class="header" href="#wasp-cluster">wasp-cluster</a></h1>
<p><code>wasp-cluster</code> is a tool that allows to easily run a cluster of Wasp nodes
in a single host, to experiment with smart contracts in a controlled environment.</p>
<p><strong>Note:</strong> <code>wasp-cluster</code> is intended for <strong>testing purposes</strong>, and is <em>not</em>
suitable for running a cluster in a production environment.</p>
<h2 id="before"><a class="header" href="#before">Before</a></h2>
<p>Make sure you have all needed binaries compiled and installed in the system
path:</p>
<ul>
<li><code>wasp</code> (Wasp server)</li>
<li><code>wasp-cli</code> (CLI client for the Wasp node)</li>
<li><code>wasp-cluster</code> (this tool)</li>
</ul>
<p>You can find instructions in
the <a href="node-software/wasp/docs/../../../readme.html#Prerequisites">main README file</a>.</p>
<h2 id="initialize-the-cluster-configuration"><a class="header" href="#initialize-the-cluster-configuration">Initialize the cluster configuration</a></h2>
<pre><code>wasp-cluster init my-cluster
</code></pre>
<p>This will create a directory named <code>my-cluster</code>, containing the cluster
configuration file (<code>cluster.json</code>) and one subdirectory for each node.</p>
<pre><code>my-cluster/
├── cluster.json
├── wasp0
│   └── config.json
├── wasp1
│   └── config.json
├── wasp2
│   └── config.json
└── wasp3
    └── config.json
</code></pre>
<p>By default the cluster contains 4 Wasp nodes. You can change this with the
<code>-n</code> parameter. E.g.: <code>wasp-cluster init my-cluster -n 2</code>.</p>
<p>If you need to change the default configuration of the nodes, you can do so now,
by editing the <code>config.json</code> files.</p>
<p>Note: by default <code>wasp-cluster</code> configures all nodes to store the database in
main memory: all data will be lost when the cluster is stopped (remember that
this tool is used primarily for testing). If you need a persistent database,
change the <code>inMemory</code> setting in all <code>config.json</code> files.</p>
<h2 id="start-the-cluster"><a class="header" href="#start-the-cluster">Start the cluster</a></h2>
<pre><code>cd my-cluster
wasp-cluster start
</code></pre>
<p>(Alternatively: <code>wasp-cluster start my-cluster</code>.)</p>
<p>When done using the cluster, press <code>Ctrl-C</code> to stop it.</p>
<h2 id="connecting-to-an-existing-goshimmer-network"><a class="header" href="#connecting-to-an-existing-goshimmer-network">Connecting to an existing Goshimmer network</a></h2>
<p>By default, <code>wasp-cluster</code> provides a mock Goshimmer node to operate a
simulated ledger without the need for consensus. This is good
for quick tests, but is far from how the ledger works in a production
environment.</p>
<p>To connect the Wasp cluster to a more realistic environment (e.g. to be able to
persist changes in the ledger), you can use the <code>docker-network</code> tool available in the
Goshimmer repository (<code>develop+wasp</code> branch) in order to start a cluster of
Goshimmer nodes.</p>
<p>Example steps:</p>
<ol>
<li>Start a Goshimmer network of 2 nodes:</li>
</ol>
<pre><code>cd &lt;goshimmer&gt;/tools/docker-network
./run.sh 2 0
</code></pre>
<ol start="2">
<li>In another console, initialize a cluster of 4 Wasp nodes (<code>-n 4</code>) with no
mock Goshimmer node (<code>-g</code>).</li>
</ol>
<pre><code>wasp-cluster init my-cluster -n 4 -g
</code></pre>
<ol start="3">
<li>Start the Wasp cluster:</li>
</ol>
<pre><code>$ cd my-cluster
$ wasp-cluster start
</code></pre>
<h2 id="running-a-disposable-cluster"><a class="header" href="#running-a-disposable-cluster">Running a disposable cluster</a></h2>
<p>If you just need to do a quick test, you can run a disposable cluster of nodes
with the default configuration with the command:</p>
<pre><code>wasp-cluster start -d
</code></pre>
<p>No need to call <code>init</code> first; this command will automatically initialize the
cluster configuration in a temporary directory, which will be removed when the
cluster is stopped.</p>
<h1 id="products"><a class="header" href="#products">Products</a></h1>
<h1 id="welcome-4"><a class="header" href="#welcome-4">Welcome</a></h1>
<p>This is the documentation for the official IOTA Stronghold Software.</p>
<p>IOTA Stronghold is a secure software implementation with the sole purpose of isolating digital secrets like IOTA seeds and private keys.</p>
<h2 id="-beta-version-"><a class="header" href="#-beta-version-">🚧 Beta Version 🚧</a></h2>
<p><a href="https://github.com/iotaledger/stronghold.rs"><img src="https://img.shields.io/badge/Status-Beta-green.svg" alt="status" /></a></p>
<h2 id="rustdocs"><a class="header" href="#rustdocs">RUSTDOCS</a></h2>
<ul>
<li><a href="https://stronghold.docs.iota.org/docs/iota_stronghold/index.html">client</a></li>
<li><a href="https://stronghold.docs.iota.org/docs/stronghold_engine/index.html">engine</a></li>
<li><a href="https://stronghold.docs.iota.org/docs/stronghold_communication/index.html">communication</a></li>
</ul>
<p>These libraries have been reviewed internally and are being prepared for a full external security audit in mid 2021, so they are not yet verifiably safe. Until this warning is removed, the IOTA Foundation makes no guarantees to the fitness of these libraries for any purposes.</p>
<p>Nevertheless, we are very interested in feedback about the design and implementation, and encourage you to reach out with any concerns or suggestions you may have.</p>
<h2 id="joining-the-discussion-15"><a class="header" href="#joining-the-discussion-15">Joining the discussion</a></h2>
<p>If you want to get involved in discussions about this library, or you're looking for support, go to the #stronghold-discussion channel on <a href="https://discord.iota.org">Discord</a>.</p>
<h2 id="what-you-will-find-here-2"><a class="header" href="#what-you-will-find-here-2">What you will find here</a></h2>
<p>This documentation has five paths. </p>
<ol>
<li>The Overview, an detailed overview of the project. </li>
<li>Libraries bindings, all avaiable programming languages and their resources.</li>
<li>The Specification, detailed explaination requirements and functionality.</li>
<li>Contribute, how you can work on the Stronghold software.</li>
<li>Get in touch, join the community and become part of the X-Team!</li>
</ol>
<h1 id="overview-11"><a class="header" href="#overview-11">Overview</a></h1>
<p>IOTA Stronghold is a secure software implementation with the sole purpose of isolating digital secrets from exposure to hackers and accidental leaks. It uses encrypted snapshots that can be easily backed up and securely shared between devices. Written in stable rust, it has strong guarantees of memory safety and process integrity.</p>
<p>There are four main components of Stronghold:</p>
<p>There are four main components of Stronghold:</p>
<ol>
<li><strong>Client</strong>: The high-level interface to Stronghold (prefers Riker, functional integration also available)</li>
<li><strong>Engine</strong>: Combines a persistence store (Snapshot) with an in-memory state interface (Vault).</li>
<li><strong>Runtime</strong>: Is a process fork with limited permissions within which cryptographic operations take place</li>
<li><strong>Communication</strong>: Enables Strongholds in different processes or on different devices to communicate with each other securely.</li>
</ol>
<p>Read more about the <a href="https://blog.iota.org/stronghold-alpha-release/">Alpha Release</a>.</p>
<h1 id="iota-stronghold-libraries"><a class="header" href="#iota-stronghold-libraries">IOTA stronghold libraries</a></h1>
<p>This is the location where bindings to other languages will be made available. The general strategy is that a binding will only expose the top level client interface.</p>
<p>This allows the binding to be simple and easy to audit. </p>
<h2 id="available-binding-languages"><a class="header" href="#available-binding-languages">Available binding languages</a></h2>
<ul>
<li><input disabled="" type="checkbox"/>
C</li>
<li><input disabled="" type="checkbox"/>
golang</li>
<li><input disabled="" type="checkbox"/>
node.js (via NEON)</li>
</ul>
<h2 id="why-no-wasm"><a class="header" href="#why-no-wasm">Why no WASM?</a></h2>
<p>While absolutely possible, we will not be providing full WASM bindings to stronghold, because of a number of very serious concerns regarding memory safety which basically destroys the security model that Stronghold seeks to offer.</p>
<h1 id="specification"><a class="header" href="#specification">Specification</a></h1>
<blockquote>
<p>TODO</p>
</blockquote>
<h1 id="contribute-to-the-project-2"><a class="header" href="#contribute-to-the-project-2">Contribute to the project</a></h1>
<p><strong>Thanks for thinking about contributing to the project! We have the following ways that you can contribute.</strong></p>
<h2 id="join-the-iota-stronghold-initiative"><a class="header" href="#join-the-iota-stronghold-initiative">Join the IOTA Stronghold Initiative</a></h2>
<p>The <a href="https://github.com/iota-community/X-Team_IOTA_Stronghold">IOTA Stronghold Initiative</a> is a collaborative effort to help improve the developer experience.</p>
<ul>
<li>Quality assurance and review</li>
<li>Documentation</li>
<li>Code samples</li>
</ul>
<p>If you'd like to get involved, join the #experience channel on <a href="https://discord.iota.org">Discord</a>.</p>
<h2 id="contribute-to-the-projects-github-repository-2"><a class="header" href="#contribute-to-the-projects-github-repository-2">Contribute to the project's GitHub repository</a></h2>
<p>All the code is open source and hosted on <a href="https://github.com/iotaledger/stronghold.rs">GitHub</a> where you can do the following:</p>
<ul>
<li>Report a bug</li>
<li>Suggest a new feature</li>
<li>Contribute to the documentation</li>
</ul>
<h2 id="contribute-to-the-documentation-2"><a class="header" href="#contribute-to-the-documentation-2">Contribute to the documentation</a></h2>
<p>This documentation is also open source and hosted on GitHub.</p>
<p>If you want to contribute new documentation or fix an error, see the <a href="https://github.com/iotaledger/documentation/blob/develop/.github/CONTRIBUTING.md">contribution guidelines</a>.</p>
<h2 id="share-your-knowledge-2"><a class="header" href="#share-your-knowledge-2">Share your knowledge</a></h2>
<p>Helping others is an important part of any open source ecosystem.</p>
<p>By sharing your knowledge with others, you can provide a lot of value to the community and maybe inspire someone else to learn and contribute.</p>
<p>Take a look at what discussions are going on in the #stronghold-discussion channel on <a href="https://discord.iota.org">Discord</a>.</p>
<p>Thanks :heart:</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        <script type="text/javascript" src="./theme/custom/sidebar.js"></script>
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
